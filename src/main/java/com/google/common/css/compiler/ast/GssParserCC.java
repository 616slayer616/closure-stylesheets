/* GssParserCC.java */
/* Generated By:JavaCC: Do not edit this line. GssParserCC.java */
package com.google.common.css.compiler.ast;

import com.google.common.base.CharMatcher;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.css.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * A parser that recognizes GSS files and builds the new AST.
 */
public class GssParserCC implements GssParserCCConstants {

  /**
   * Pattern for functions that are allowed to be separated by spaces.
   *
   * <p>The non-standard {@code rect(0 0 0 0)} is sometimes used for IE instead
   * of the standard {@code rect(0,0,0,0)}.
   *
   * <p>The legacy {@code -webkit-gradient} function takes its arguments in the
   * form:
   * {@code (linear, left center, right center, from(color1), to(color2))}.
   * As does {@code -khtml-gradient}.
   *
   * <p>The gradient proposals for CSS 3 are:
   * <ul>
   * <li>linear-gradient
   * <li>radial-gradient
   * <li>repeating-linear-gradient
   * <li>repeating-radial-gradient
   * </ul>
   * As CSS 3 is in draft stage they come in current browsers with a vendor
   * prefix but leaving out the vendor prefix already works.
   */
  private static final Pattern FUNCTIONS_WITH_SPACE_SEP_OK = Pattern.compile(
        "(?:-(?:O|MOZ|WEBKIT|MS)-)?(?:REPEATING-)?(?:LINEAR|RADIAL)-GRADIENT"
        + "|(?:-(?:O|MOZ|WEBKIT|MS)-)?IMAGE-SET"
        + "|RECT|INSET|CIRCLE|ELLIPSE|POLYGON|-KHTML-GRADIENT|-WEBKIT-GRADIENT"
        + "|(?:-WEBKIT-)?DROP-SHADOW|(?:-WEBKIT-)?CUSTOM|LOCAL",
        Pattern.CASE_INSENSITIVE);

  private static final ImmutableSet<String> URL_FUNCTIONS = ImmutableSet.of(
      "domain", "url", "url-prefix");

  private static final CharMatcher CSS_WHITESPACE =
      CharMatcher.anyOf(" \t\r\n\f");

  private static final Pattern VALID_BLOCK_COMMENT_PATTERN =
      Pattern.compile(".*/\\*.*\\*/.*", Pattern.DOTALL);

  private CssBlockNode globalBlock;
  private SourceCode sourceCode;
  private final CssNodeBuilder nodeBuilder = new CssNodeBuilder();
  private StringCharStream charStream;

  /**
   * CSS Error Handling (http://www.w3.org/TR/css-syntax-3/#error-handling) is implemented by the
   * demand from Play Book. It still may abort throwing GssParserException due to unhandled errors.
   */
  private boolean enableErrorRecovery;


  /**
   * List of handled errors if error handling enabled.
   */
  private final List<GssParserException> handledErrors = Lists.newArrayList();

  public ImmutableList<GssParserException> getHandledErrors() {
    return ImmutableList.copyOf(handledErrors);
  }

  public GssParserCC(CssBlockNode globalBlock, SourceCode sourceCode) {
    this(new StringCharStream(sourceCode.getFileContents()), globalBlock, sourceCode, false);
  }

  public GssParserCC(StringCharStream charStream, CssBlockNode globalBlock, SourceCode sourceCode) {
    this(charStream, globalBlock, sourceCode, false);
  }

  /**
   * @enableErrorRecovery If true, it recovers as many errors as possible and continue parsing
   *                      instead of throwing ParseException and handled errors are available as
   *                      getHandledErrors().
   */
  public GssParserCC(CssBlockNode globalBlock, SourceCode sourceCode, boolean enableErrorRecovery) {
    this(new StringCharStream(sourceCode.getFileContents()), globalBlock, sourceCode,
        enableErrorRecovery);
  }

  public GssParserCC(StringCharStream charStream, CssBlockNode globalBlock, SourceCode sourceCode,
      boolean enableErrorRecovery) {
    this((CharStream) charStream);
    this.charStream = charStream;
    this.sourceCode = sourceCode;
    this.globalBlock = globalBlock;
    this.enableErrorRecovery = enableErrorRecovery;
  }

  private SourceCodeLocation getLocation() {
    return getLocation(token);
  }

  private SourceCodeLocation getLocation(Token t) {
    int lineNumber1 = t.beginLine;
    int indexInLine1 = t.beginColumn;
    int charIndex1 = charStream.convertToCharacterIndex(lineNumber1,
        indexInLine1);
    int lineNumber2 = t.endLine;
    int indexInLine2 = t.endColumn + 1; // Need to advance 1 to be beyond the end of the token.
    int charIndex2 = charStream.convertToCharacterIndex(lineNumber2,
        indexInLine2);
    return new SourceCodeLocation(sourceCode, charIndex1, lineNumber1,
      indexInLine1, charIndex2, lineNumber2, indexInLine2);
  }

  /**
   * Returns a new SourceCodeLocation which covers everything between the
   * beginning of the first location and the end of the second location.
   */
  private SourceCodeLocation mergeLocations(SourceCodeLocation beginLocation,
      SourceCodeLocation endLocation) {
    return SourceCodeLocation.merge(beginLocation, endLocation);
  }

  private SourceCodeLocation mergeLocations(
      Iterable<? extends CssNode> locations) {
    return SourceCodeLocation.merge(locations);
  }

  private CssFunctionNode createUrlFunction(Token t) {
    // We tried using finer-grained tokens for URI parsing, but an
    // unquoted URI can look just like an identifier or even a whole
    // declaration. We tried using lexical states to recognize bare
    // URIs only within URL_FUNCTIONS, but that had two problems:
    // (1) it means ordinary functions can't take bare URLs, which
    // harms orthogonality of GSS and outlaws some custom functions
    // we've found in the wild
    // (2) it means our special lexical state must either exclude
    // ordinary functions, or we must import many other tokens into this
    // new state, which adds complexity for little benefit.
    // Therefore, we ask the lexer to distinguish only big
    // recognizably-URLish chunks of input and break those down here.
    SourceCodeLocation loc = this.getLocation(t);
    int pi = t.image.indexOf('(');
    String funName = t.image.substring(0, pi);
    Preconditions.checkState(URL_FUNCTIONS.contains(funName));
    CssFunctionNode.Function funType = CssFunctionNode.Function.byName(funName);
    CssFunctionNode fun = new CssFunctionNode(funType, loc);
    String parenContents = trim(t.image.substring(pi + 1, t.image.length() - 1));
    CssValueNode arg = new CssLiteralNode(parenContents, loc);
    fun.setArguments(new CssFunctionArgumentsNode(ImmutableList.of(arg)));
    return fun;
  }

  /**
   * Adds the given arguments explicitly separated by the given
   * separator to the given node. If an argument is a composite node
   * separated by commas, this method adds its children explicitly
   * separated by commas instead of the composite node, in order to
   * flatten out the argument list.
   *
   * <p>Separators such as commas in function calls have to be added
   * explicitly, in order to match the output from the old tree
   * converter.
   *
   * @param node The function arguments node to add to
   * @param args The real arguments to add
   * @param numArgs The number of real arguments
   * @param sep The separator to add between real arguments
   */
  private void addArgumentsWithSeparator(
      CssFunctionArgumentsNode node,
      Iterable<CssValueNode> args,
      int numArgs,
      String sep) {
    int current = 0;
    for (CssValueNode arg : args) {
      if (arg instanceof CssCompositeValueNode &&
          ((CssCompositeValueNode) arg).getOperator() == CssCompositeValueNode.Operator.COMMA) {
        CssCompositeValueNode composite = (CssCompositeValueNode) arg;
        addArgumentsWithSeparator(node, composite.getValues(), composite.getValues().size(), ",");
      } else {
        node.addChildToBack(arg);
      }
      current++;
      if (current < numArgs) {
        // Note that the source location for the separator is not entirely
        // accurate, but adding the separators as values is a hack anyways.
        node.addChildToBack(
            new CssLiteralNode(sep, arg.getSourceCodeLocation()));
      }
    }
  }

  private static String trim(String input) {
    return CSS_WHITESPACE.trimFrom(input);
  }

  public void parse() throws GssParserException {
    try {
      start();
    } catch (ParseException e) {
      // token.next can be null if there is an error after EOF, such as an unterminated block
      // comment.
      Token tokenWithError = token.next == null ? token : token.next;
      throw new GssParserException(this.getLocation(tokenWithError), e);
    }
  }

  /**
   * Wrapper around {@code parse()} that (re-)initializes the parser and
   * clears its state afterwards.

   * @param globalBlock the place to store parsing result
   * @param sourceCode the source code to parse
   * @param errorHandling whether error handling is enabled
   * @param parsingErrors the place to store errors occured during parsing
   */
  public void parse(CssBlockNode globalBlock,
      SourceCode sourceCode,
      boolean errorHandling,
      ImmutableList.Builder<GssParserException> parsingErrors)
      throws GssParserException {
    try {
      initialize(globalBlock, sourceCode, errorHandling);
      parse();
    } finally {
      parsingErrors.addAll(handledErrors);
      clearState();
    }
  }

  /**
   * This helper class takes care of the creation of nodes of the AST, and
   * attaching comments to them.
   */
  private class CssNodeBuilder {

    protected CssNode attachComments(List<Token> tokens, CssNode node) {
      for (Token t : tokens) {
        node = attachComment(t, node);
      }
      return node;
    }

    public CssNode attachComment(Token t, CssNode node) {
      if (t.specialToken == null) {
        return node;
      }
      Token special = t.specialToken;
      // Walking back the special token chain until we reach the first special token
      // which is after the previous regular (non-comment) token.
      while (special.specialToken != null) {
        special = special.specialToken;
      }
      // Visiting comments in their normal appearing order.
      while (special != null) {
        node.appendComment(new CssCommentNode(trim(special.image), getLocation(special)));
        special = special.next;
      }
      return node;
    }

    public CssStringNode buildStringNode(CssStringNode.Type type,
        String image, SourceCodeLocation location, Token token) {
        Preconditions.checkNotNull(image, "image should be non-null");
        Preconditions.checkArgument(
            image.length() > 1, "the image argument must be quoted", image);
        CssStringNode node = new CssStringNode(type, location);
        attachComments(Lists.newArrayList(token), node);
        return node;
    }

    public CssHexColorNode buildHexColorNode(String image,
        SourceCodeLocation location, List<Token> tokens) {
      CssHexColorNode node = new CssHexColorNode(image, location);
      attachComments(tokens, node);
      return node;
    }

    public CssRulesetNode buildRulesetNode(CssDeclarationBlockNode declarations,
        CssSelectorListNode selectors, SourceCodeLocation location,
        List<Token> tokens) {
      CssRulesetNode node = new CssRulesetNode(declarations);
      node.setSelectors(selectors);
      node.setSourceCodeLocation(location);
      attachComments(tokens, node);
      return node;
    }

    public CssKeyframeRulesetNode buildKeyframeRulesetNode(CssDeclarationBlockNode declarations,
        CssKeyListNode keys, List<Token> tokens) {
      CssKeyframeRulesetNode node = new CssKeyframeRulesetNode(declarations);
      node.setKeys(keys);
      attachComments(tokens, node);
      return node;
    }

    public CssKeyNode buildKeyNode(Token token, String value, SourceCodeLocation location) {
      CssKeyNode node = new CssKeyNode(value, location);
      if (token != null) {
        attachComment(token, node);
      }
      return node;
    }

    public CssClassSelectorNode buildClassSelectorNode(String name,
        SourceCodeLocation location, CssClassSelectorNode.ComponentScoping scoping,
        List<Token> tokens) {
      CssClassSelectorNode node = new CssClassSelectorNode(name, scoping, location);
      attachComments(tokens, node);
      return node;
    }

    public CssIdSelectorNode buildIdSelectorNode(String id,
        SourceCodeLocation location, List<Token> tokens) {
      CssIdSelectorNode node = new CssIdSelectorNode(id, location);
      attachComments(tokens, node);
      return node;
    }

    public CssPseudoClassNode buildPseudoClassNode(String name,
        SourceCodeLocation location, List<Token> tokens) {
      CssPseudoClassNode node = new CssPseudoClassNode(name, location);
      attachComments(tokens, node);
      return node;
    }

    public CssPseudoClassNode buildPseudoClassNode(
        CssPseudoClassNode.FunctionType functionType, String name,
        String argument, SourceCodeLocation location, List<Token> tokens) {
      CssPseudoClassNode node = new CssPseudoClassNode(functionType, name,
          argument, location);
      attachComments(tokens, node);
      return node;
    }

    public CssPseudoClassNode buildPseudoClassNode(String name,
        CssSelectorNode notSelector, SourceCodeLocation location,
        List<Token> tokens) {
      CssPseudoClassNode node = new CssPseudoClassNode(name, notSelector,
          location);
      attachComments(tokens, node);
      return node;
    }

    public CssPseudoElementNode buildPseudoElementNode(String name,
        SourceCodeLocation location, List<Token> tokens) {
      CssPseudoElementNode node = new CssPseudoElementNode(name, location);
      attachComments(tokens, node);
      return node;
    }

    public CssAttributeSelectorNode buildAttributeSelectorNode(
        CssAttributeSelectorNode.MatchType matchType, String attribute,
        CssValueNode value, SourceCodeLocation location, List<Token> tokens) {
      CssAttributeSelectorNode node = new CssAttributeSelectorNode(matchType,
          attribute, value, location);
      attachComments(tokens, node);
      return node;
    }

    public CssSelectorNode buildSelectorNode(Token token, SourceCodeLocation location,
        CssRefinerListNode refiners) {
      String name = "";
      if (token != null) {
        name = token.image;
      }
      CssSelectorNode node = new CssSelectorNode(name, location);
      if (token != null) {
        attachComment(token, node);
      }
      node.setRefiners(refiners);
      return node;
    }

    public CssCombinatorNode buildCombinatorNode(CssCombinatorNode.Combinator combinator,
        SourceCodeLocation location, List<Token> tokens) {
      CssCombinatorNode node = new CssCombinatorNode(combinator, location);
      attachComments(tokens, node);
      return node;
    }

    public CssDeclarationNode buildDeclarationNode(CssPropertyNode property,
        CssPropertyValueNode value, List<Token> tokens) {
      try {
        CssDeclarationNode node =
            new CssDeclarationNode(
                property,
                value,
                mergeLocations(property.getSourceCodeLocation(), value.getSourceCodeLocation()));
        attachComments(tokens, node);
        return node;
      } catch (NullPointerException e){
        StringBuffer valueValue = new StringBuffer();
        for (CssValueNode n : value.getChildren()) {
          valueValue.append(n.getValue());
          valueValue.append("<");
          valueValue.append(n.getSourceCodeLocation());
          valueValue.append("> ");
        }
        throw new RuntimeException("property: " + property.toString() + ", " + valueValue.toString(), e);
      }
    }

    public CssCompositeValueNode buildCompositeValueNode(List<CssValueNode> list,
        CssCompositeValueNode.Operator op, SourceCodeLocation location, List<Token> tokens) {
      CssCompositeValueNode node =  new CssCompositeValueNode(list, op, location);
      attachComments(tokens, node);
      return node;
    }


    public CssBooleanExpressionNode buildBoolExpressionNode(CssBooleanExpressionNode.Type type,
        String value, CssBooleanExpressionNode left, CssBooleanExpressionNode right,
            SourceCodeLocation loc, List<Token> tokens) {
      CssBooleanExpressionNode node = new CssBooleanExpressionNode(type, value, left, right, loc);
      attachComments(tokens, node);
      return node;
    }

    public CssLiteralNode buildLiteralNode(String value, SourceCodeLocation location,
        List<Token> tokens) {
      CssLiteralNode node = new CssLiteralNode(value, location);
      attachComments(tokens, node);
      return node;
    }

    public CssUnicodeRangeNode buildUnicodeRangeNode(String value, SourceCodeLocation location,
        List<Token> tokens) {
      CssUnicodeRangeNode node = new CssUnicodeRangeNode(value, location);
      attachComments(tokens, node);
      return node;
    }

    public CssNumericNode buildNumericNode(String num, String unit, SourceCodeLocation location,
        List<Token> tokens) {
      CssNumericNode node = new CssNumericNode(num, unit, location);
      attachComments(tokens, node);
      return node;
    }

    public CssLiteralNode buildLoopVariableNode(String value, SourceCodeLocation location,
        List<Token> tokens) {
      CssLoopVariableNode node = new CssLoopVariableNode(value, location);
      attachComments(tokens, node);
      return node;
    }

    public CssFunctionNode buildFunctionNode(String name, SourceCodeLocation location,
        CssFunctionArgumentsNode args, List<Token> tokens) {
      CssFunctionNode.Function functionType = CssFunctionNode.Function.byName(name);
      if (functionType == null) {
        functionType = CssFunctionNode.Function.CUSTOM;
      }
      CssFunctionNode functionNode = (functionType != CssFunctionNode.Function.CUSTOM) ?
          new CssFunctionNode(functionType, location) :
          new CssCustomFunctionNode(name, location);
      functionNode.setArguments(args);
      attachComments(tokens, functionNode);
      return functionNode;
    }

    public CssPriorityNode buildPriorityNode(SourceCodeLocation location, List<Token> tokens) {
      CssPriorityNode node = new CssPriorityNode(CssPriorityNode.PriorityType.IMPORTANT, location);
      attachComments(tokens, node);
      return node;
    }

    public CssUnknownAtRuleNode buildUnknownAtRuleNode(CssLiteralNode name,
        CssAbstractBlockNode block, SourceCodeLocation location,
        List<CssValueNode> parameters, List<Token> tokens) {
      boolean hasBlock = (block != null);
      CssUnknownAtRuleNode at = new CssUnknownAtRuleNode(name, hasBlock);
      at.setSourceCodeLocation(location);
      if (hasBlock) {
        at.setBlock(block);
      }
      at.setParameters(parameters);
      attachComments(tokens, at);
      return at;
    }

    public CssKeyframesNode buildWebkitKeyframesNode(CssLiteralNode name,
        CssBlockNode block, SourceCodeLocation location,
        List<CssValueNode> parameters, List<Token> tokens) {
      CssKeyframesNode at = new CssKeyframesNode(name);
      at.setSourceCodeLocation(location);
      at.setBlock(block);
      at.setParameters(parameters);
      attachComments(tokens, at);
      return at;
    }
  }

  private void initialize(CssBlockNode globalBlock, SourceCode sourceCode,
      boolean errorHandling) {
    this.enableErrorRecovery = errorHandling;
    this.sourceCode = sourceCode;
    this.globalBlock = globalBlock;
    this.handledErrors.clear();
    StringCharStream charStream =
        new StringCharStream(sourceCode.getFileContents());
    this.charStream = charStream;
    this.ReInit(charStream);
  }

  private void clearState() {
    this.sourceCode = null;
    this.globalBlock = null;
    this.handledErrors.clear();
    this.charStream = null;
  }

// The rest of the file contains the production rules of the grammar and to
// increase readability every rule also has a comment with the rule it
// implements in Extended Backusâ€“Naur Form (EBNF) that follows this syntax:
// name_of_rule
//   : X
//   ;
// where X is the actual production consisting of non terminals and terminals.
// Terminals that exactly represent some characters are not written with their
// name but the characters are written instead, e.g. '(' instead of LEFTROUND,
// but IDENTIFIER stays the same.

// string
//   : DOUBLE_QUOTED_STRING | SINGLE_QUOTED_STRING
//   ;
  final public CssStringNode string() throws ParseException {Token t;
  CssStringNode.Type type;
  SourceCodeLocation beginLocation;
beginLocation = this.getLocation(token.next);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOUBLE_QUOTED_STRING:{
      t = jj_consume_token(DOUBLE_QUOTED_STRING);
type = CssStringNode.Type.DOUBLE_QUOTED_STRING;
      break;
      }
    case SINGLE_QUOTED_STRING:{
      t = jj_consume_token(SINGLE_QUOTED_STRING);
type = CssStringNode.Type.SINGLE_QUOTED_STRING;
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
SourceCodeLocation endLocation = this.getLocation();
    {if ("" != null) return nodeBuilder.buildStringNode(
        type, t.image, this.mergeLocations(beginLocation, endLocation), t);}
    throw new Error("Missing return statement in function");
  }

// ruleset
//   : selector_list '{' style_declarations '}'
//   ;
  final public CssRulesetNode ruleSet() throws ParseException {CssSelectorListNode selectors;
  CssDeclarationBlockNode declarations;
  Token t;
  List<Token> tokens = Lists.newArrayList();
    try {
      try {
        selectors = selectorList();
        t = jj_consume_token(LEFTBRACE);
tokens.add(t);
      } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
      skipComponentValuesToAfter(LEFTBRACE);
      {if (true) throw e;}
      }
      declarations = styleDeclaration();
      t = jj_consume_token(RIGHTBRACE);
tokens.add(t);
CssRulesetNode ruleSet = nodeBuilder.buildRulesetNode(declarations,
          selectors, mergeLocations(selectors.getSourceCodeLocation(), getLocation()), tokens);
      {if ("" != null) return ruleSet;}
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    skipComponentValuesToAfter(RIGHTBRACE);
    {if (true) throw e;}
    }
    throw new Error("Missing return statement in function");
  }

// selector_list
//   : selector [ ',' S* selector ]*
//   ;
  final public CssSelectorListNode selectorList() throws ParseException {CssSelectorListNode list = new CssSelectorListNode();
  CssSelectorNode selector;
  Token t;
    selector = selector();
list.addChildToBack(selector);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      t = jj_consume_token(COMMA);
nodeBuilder.attachComment(t, selector);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        jj_consume_token(S);
      }
      selector = selector();
list.addChildToBack(selector);
    }
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
  }

// selector
//   : simple_selector [ combinator simple_selector ]* S*
//   ;
  final public CssSelectorNode selector() throws ParseException {CssSelectorNode first;
  CssCombinatorNode c;
  CssSelectorNode next;
  CssSelectorNode prev;
  Token t;
  List<Token> tokens = Lists.newArrayList();
    first = simpleSelector();
prev = first;
    label_3:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_3;
      }
      c = combinator();
      next = simpleSelector();
c.setSelector(next);
      prev.setCombinator(c);
      prev = next;
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_4;
      }
      t = jj_consume_token(S);
tokens.add(t);
    }
nodeBuilder.attachComments(tokens, first);
    {if ("" != null) return first;}
    throw new Error("Missing return statement in function");
  }

// class
//   : '.' IDENTIFIER
//   ;
  final public CssClassSelectorNode className() throws ParseException {Token t;
  List<Token> tokens = Lists.newArrayList();
  CssClassSelectorNode.ComponentScoping scoping = CssClassSelectorNode.ComponentScoping.DEFAULT;
    t = jj_consume_token(DOT);
tokens.add(t);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PERCENT:
    case CARET:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERCENT:{
        jj_consume_token(PERCENT);
scoping = CssClassSelectorNode.ComponentScoping.FORCE_SCOPED;
        break;
        }
      case CARET:{
        jj_consume_token(CARET);
scoping = CssClassSelectorNode.ComponentScoping.FORCE_UNSCOPED;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    t = jj_consume_token(IDENTIFIER);
tokens.add(t);
    {if ("" != null) return nodeBuilder.buildClassSelectorNode(t.image, this.getLocation(), scoping, tokens);}
    throw new Error("Missing return statement in function");
  }

// id
//   : HASH_NAME
//   ;
  final public CssRefinerNode id() throws ParseException {Token t;
  List<Token> tokens = Lists.newArrayList();
    t = jj_consume_token(HASH_NAME);
tokens.add(t);
    String name = t.image.substring(1);
    {if ("" != null) return nodeBuilder.buildIdSelectorNode(name, this.getLocation(), tokens);}
    throw new Error("Missing return statement in function");
  }

// pseudo
//   : ':' [ IDENT | [ ':' IDENT ] | [ 'not(' S* simple_selector S* ')' ]
//         | [ 'lang(' S* IDENT S* ')' ] | [ FUNCTION S* nth S* ')' ] ]?
//   ;
  final public CssRefinerNode pseudo() throws ParseException {Token t;
  SourceCodeLocation beginLocation = null;
  SourceCodeLocation endLocation = null;
  String pseudo = null;
  String argument = null;
  List<Token> tokens = Lists.newArrayList();
  CssSelectorNode notSelector = null;
    t = jj_consume_token(COLON);
beginLocation = this.getLocation(); tokens.add(t);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLON:
    case IDENTIFIER:
    case NOTFUNCTION:
    case LANGFUNCTION:
    case FUNCTION:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        t = jj_consume_token(IDENTIFIER);
pseudo = t.image; tokens.add(t);
        break;
        }
      case COLON:{
        // ::identifier (pseudo-element)
              t = jj_consume_token(COLON);
tokens.add(t);
        t = jj_consume_token(IDENTIFIER);
pseudo = t.image; tokens.add(t);
          endLocation = this.getLocation();
          {if ("" != null) return nodeBuilder.buildPseudoElementNode(pseudo,
              this.mergeLocations(beginLocation, endLocation), tokens);}
        break;
        }
      case NOTFUNCTION:{
        // :not( simple_selector )
              t = jj_consume_token(NOTFUNCTION);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[6] = jj_gen;
            break label_5;
          }
          jj_consume_token(S);
        }
beginLocation = this.getLocation();
          pseudo = t.image; tokens.add(t);
        notSelector = simpleSelector();
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[7] = jj_gen;
            break label_6;
          }
          jj_consume_token(S);
        }
        t = jj_consume_token(RIGHTROUND);
tokens.add(t);
          endLocation = this.getLocation();
          {if ("" != null) return nodeBuilder.buildPseudoClassNode(pseudo, notSelector,
              this.mergeLocations(beginLocation, endLocation), tokens);}
        break;
        }
      case LANGFUNCTION:{
        // :lang( <IDENTIFIER> )
              t = jj_consume_token(LANGFUNCTION);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[8] = jj_gen;
            break label_7;
          }
          jj_consume_token(S);
        }
beginLocation = this.getLocation();
          pseudo = t.image; tokens.add(t);
        t = jj_consume_token(IDENTIFIER);
argument = t.image; tokens.add(t);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[9] = jj_gen;
            break label_8;
          }
          jj_consume_token(S);
        }
        t = jj_consume_token(RIGHTROUND);
tokens.add(t);
          endLocation = this.getLocation();
          {if ("" != null) return nodeBuilder.buildPseudoClassNode(
              CssPseudoClassNode.FunctionType.LANG, pseudo, argument,
              this.mergeLocations(beginLocation, endLocation), tokens);}
        break;
        }
      case FUNCTION:{
        // :nth-function( nth )
              t = jj_consume_token(FUNCTION);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[10] = jj_gen;
            break label_9;
          }
          jj_consume_token(S);
        }
beginLocation = this.getLocation();
          pseudo = t.image; tokens.add(t);
        argument = nth();
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[11] = jj_gen;
            break label_10;
          }
          jj_consume_token(S);
        }
        t = jj_consume_token(RIGHTROUND);
tokens.add(t);
          endLocation = this.getLocation();
          {if ("" != null) return nodeBuilder.buildPseudoClassNode(
              CssPseudoClassNode.FunctionType.NTH, pseudo, argument,
              this.mergeLocations(beginLocation, endLocation), tokens);}
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      ;
    }
// non-function pseudo-class
    endLocation = this.getLocation();
    {if ("" != null) return nodeBuilder.buildPseudoClassNode(pseudo,
        this.mergeLocations(beginLocation, endLocation), tokens);}
    throw new Error("Missing return statement in function");
  }

// nth
//   : [ [ [ S* '+' ] | '-' | NUMBER | IDENTIFIER | FOR_VARIABLE ] S* ]+
//   ;
  final public String nth() throws ParseException {Token t;
  StringBuilder argument = new StringBuilder();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WPLUS:{
        t = jj_consume_token(WPLUS);
argument.append(t.image);
        break;
        }
      case MINUS:{
        t = jj_consume_token(MINUS);
argument.append(t.image);
        break;
        }
      case WMINUSW:{
        t = jj_consume_token(WMINUSW);
argument.append(trim(t.image));
        break;
        }
      case NUMBER:{
        t = jj_consume_token(NUMBER);
argument.append(t.image);
        break;
        }
      case IDENTIFIER:{
        t = jj_consume_token(IDENTIFIER);
argument.append(t.image);
        break;
        }
      case FOR_VARIABLE:{
        t = jj_consume_token(FOR_VARIABLE);
argument.append(t.image);
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[15] = jj_gen;
          break label_12;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MINUS:
      case WMINUSW:
      case WPLUS:
      case NUMBER:
      case FOR_VARIABLE:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        break label_11;
      }
    }
{if ("" != null) return argument.toString();}
    throw new Error("Missing return statement in function");
  }

// attribute
//   : '[' S* IDENT S* [
//        [ '=' | '~=' | '^=' | '$=' | '*=' | '|=' ] S* [ IDENTIFIER | STRING ]
//        S*
//      ]? ']'
//   ;
  final public CssAttributeSelectorNode attribute() throws ParseException {Token t;
  CssStringNode stringNode = null;
  CssLiteralNode idNode = null;
  String attribute;
  List<Token> tokens = Lists.newArrayList();
  SourceCodeLocation beginLocation;
  CssAttributeSelectorNode.MatchType matchType =
      CssAttributeSelectorNode.MatchType.ANY;
    t = jj_consume_token(LEFTSQUARE);
beginLocation = this.getLocation(); tokens.add(t);
    try {
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          break label_13;
        }
        jj_consume_token(S);
      }
      t = jj_consume_token(IDENTIFIER);
attribute = t.image; tokens.add(t);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[18] = jj_gen;
          break label_14;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQUALS:
      case TILDE_EQUALS:
      case CARET_EQUALS:
      case DOLLAR_EQUALS:
      case ASTERISK_EQUALS:
      case PIPE_EQUALS:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EQUALS:{
          t = jj_consume_token(EQUALS);
tokens.add(t);
            matchType = CssAttributeSelectorNode.MatchType.EXACT;
          break;
          }
        case TILDE_EQUALS:{
          t = jj_consume_token(TILDE_EQUALS);
tokens.add(t);
            matchType = CssAttributeSelectorNode.MatchType.ONE_WORD;
          break;
          }
        case CARET_EQUALS:{
          t = jj_consume_token(CARET_EQUALS);
tokens.add(t);
            matchType = CssAttributeSelectorNode.MatchType.PREFIX;
          break;
          }
        case DOLLAR_EQUALS:{
          t = jj_consume_token(DOLLAR_EQUALS);
tokens.add(t);
            matchType = CssAttributeSelectorNode.MatchType.SUFFIX;
          break;
          }
        case ASTERISK_EQUALS:{
          t = jj_consume_token(ASTERISK_EQUALS);
tokens.add(t);
            matchType = CssAttributeSelectorNode.MatchType.CONTAINS;
          break;
          }
        case PIPE_EQUALS:{
          t = jj_consume_token(PIPE_EQUALS);
tokens.add(t);
            matchType = CssAttributeSelectorNode.MatchType.EXACT_OR_DASH;
          break;
          }
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[20] = jj_gen;
            break label_15;
          }
          jj_consume_token(S);
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          t = jj_consume_token(IDENTIFIER);
idNode = new CssLiteralNode(t.image, this.getLocation());
          tokens.add(t);
          break;
          }
        case DOUBLE_QUOTED_STRING:
        case SINGLE_QUOTED_STRING:{
          stringNode = string();
          break;
          }
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[22] = jj_gen;
            break label_16;
          }
          jj_consume_token(S);
        }
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      t = jj_consume_token(RIGHTSQUARE);
tokens.add(t);
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    skipComponentValuesToAfter(RIGHTSQUARE);
    {if (true) throw e;}
    }
SourceCodeLocation endLocation = this.getLocation();
    CssValueNode v;
    if (stringNode != null) {
      v = stringNode;
    } else if (idNode != null) {
      v = idNode;
    } else {
      v = new CssLiteralNode("");
    }
    {if ("" != null) return nodeBuilder.buildAttributeSelectorNode(
        matchType, attribute, v,
        this.mergeLocations(beginLocation, endLocation), tokens);}
    throw new Error("Missing return statement in function");
  }

// simple_selector
//   : [ element_name [ id | class | attribute | pseudo ]* ]
//     | [ id | class | attribute | pseudo ]+
//   ;
  final public CssSelectorNode simpleSelector() throws ParseException {Token t;
  CssRefinerNode n = null;
  Token selectorName = null;
  CssRefinerListNode refiners = new CssRefinerListNode();
  SourceCodeLocation beginLocation;
beginLocation = this.getLocation(token.next);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASTERISK:
    case IDENTIFIER:{
      selectorName = elementName();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:
        case DOT:
        case LEFTSQUARE:
        case HASH_NAME:{
          ;
          break;
          }
        default:
          jj_la1[24] = jj_gen;
          break label_17;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case HASH_NAME:{
          n = id();
          break;
          }
        case DOT:{
          n = className();
          break;
          }
        case LEFTSQUARE:{
          n = attribute();
          break;
          }
        case COLON:{
          n = pseudo();
          break;
          }
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
refiners.addChildToBack(n);
      }
      break;
      }
    case COLON:
    case DOT:
    case LEFTSQUARE:
    case HASH_NAME:{
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case HASH_NAME:{
          n = id();
          break;
          }
        case DOT:{
          n = className();
          break;
          }
        case LEFTSQUARE:{
          n = attribute();
          break;
          }
        case COLON:{
          n = pseudo();
          break;
          }
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
refiners.addChildToBack(n);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:
        case DOT:
        case LEFTSQUARE:
        case HASH_NAME:{
          ;
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          break label_18;
        }
      }
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
SourceCodeLocation endLocation = this.getLocation();
    CssSelectorNode selectorNode = nodeBuilder.buildSelectorNode(selectorName,
         this.mergeLocations(beginLocation, endLocation), refiners);
    {if ("" != null) return selectorNode;}
    throw new Error("Missing return statement in function");
  }

// element_name
//   : IDENTIFIER | '*'
//   ;
  final public Token elementName() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      t = jj_consume_token(IDENTIFIER);
      break;
      }
    case ASTERISK:{
      t = jj_consume_token(ASTERISK);
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

// combinator
//   : [ '+' S* ] | [ '>' S* ] | [ '~' S* ] | [ WDEEP S*] | S+
//   ;
  final public CssCombinatorNode combinator() throws ParseException {Token t;
  List<Token> tokens = Lists.newArrayList();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WPLUS:{
      t = jj_consume_token(WPLUS);
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[30] = jj_gen;
          break label_19;
        }
        jj_consume_token(S);
      }
tokens.add(t);
      {if ("" != null) return nodeBuilder.buildCombinatorNode(
          CssCombinatorNode.Combinator.ADJACENT_SIBLING, this.getLocation(),
          tokens);}
      break;
      }
    case WGREATER:{
      t = jj_consume_token(WGREATER);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          break label_20;
        }
        jj_consume_token(S);
      }
tokens.add(t);
      {if ("" != null) return nodeBuilder.buildCombinatorNode(
          CssCombinatorNode.Combinator.CHILD, this.getLocation(), tokens);}
      break;
      }
    case WTILDE:{
      t = jj_consume_token(WTILDE);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[32] = jj_gen;
          break label_21;
        }
        jj_consume_token(S);
      }
tokens.add(t);
      {if ("" != null) return nodeBuilder.buildCombinatorNode(
          CssCombinatorNode.Combinator.GENERAL_SIBLING, this.getLocation(),
          tokens);}
      break;
      }
    case WDEEP:{
      t = jj_consume_token(WDEEP);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[33] = jj_gen;
          break label_22;
        }
        jj_consume_token(S);
      }
tokens.add(t);
      {if ("" != null) return nodeBuilder.buildCombinatorNode(
          CssCombinatorNode.Combinator.DEEP, this.getLocation(), tokens);}
      break;
      }
    case S:{
      label_23:
      while (true) {
        t = jj_consume_token(S);
tokens. add(t);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          break label_23;
        }
      }
{if ("" != null) return nodeBuilder.buildCombinatorNode(
          CssCombinatorNode.Combinator.DESCENDANT, this.getLocation(), tokens);}
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// style_declaration
//   : S* standard_declaration? S*
//     [
//        [ inner_at_rule S* standard_declaration ]
//      | ';' S* standard_declaration
//     ]*
//   ;
// This production rule returns a block that contains a list of declarations and
// @-rules. The declarations and rules must be separated by semicolons. If the
// last thing in the block is a declaration, the trailing semicolon is optional.
// Note that the trailing semicolon is NOT optional if the last thing is an
// @-rule. This is a limitation of the current grammar.
  final public CssDeclarationBlockNode styleDeclaration() throws ParseException {CssDeclarationBlockNode block = new CssDeclarationBlockNode();
  CssNode decl;
    try {
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[36] = jj_gen;
          break label_24;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:
      case IDENTIFIER:
      case CUSTOM_PROPERTY_NAME:{
        decl = declaration();
block.addChildToBack(decl);
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[38] = jj_gen;
          break label_25;
        }
        jj_consume_token(S);
      }
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));
    }
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMICOLON:
      case ATKEYWORD:{
        ;
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        break label_26;
      }
      try {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ATKEYWORD:{
          try {
            decl = innerAtRule();
block.addChildToBack(decl);
          } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
          handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));
          }
          label_27:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case S:{
              ;
              break;
              }
            default:
              jj_la1[40] = jj_gen;
              break label_27;
            }
            jj_consume_token(S);
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ASTERISK:
          case IDENTIFIER:
          case CUSTOM_PROPERTY_NAME:{
            decl = declaration();
block.addChildToBack(decl);
            break;
            }
          default:
            jj_la1[41] = jj_gen;
            ;
          }
          break;
          }
        case SEMICOLON:{
          jj_consume_token(SEMICOLON);
          label_28:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case S:{
              ;
              break;
              }
            default:
              jj_la1[42] = jj_gen;
              break label_28;
            }
            jj_consume_token(S);
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ASTERISK:
          case IDENTIFIER:
          case CUSTOM_PROPERTY_NAME:{
            decl = declaration();
block.addChildToBack(decl);
            break;
            }
          default:
            jj_la1[43] = jj_gen;
            ;
          }
          break;
          }
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
      handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));
      }
    }
{if ("" != null) return block;}
    throw new Error("Missing return statement in function");
  }

  final public CssNode declaration() throws ParseException {CssNode decl;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASTERISK:
    case IDENTIFIER:{
      decl = standardDeclaration();
      break;
      }
    case CUSTOM_PROPERTY_NAME:{
      decl = customDeclaration();
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return decl;}
    throw new Error("Missing return statement in function");
  }

// custom_declaration
//   : CUSTOM_PROPERTY_NAME S* ':' custom_declaration_value
//   ;
  final public CssDeclarationNode customDeclaration() throws ParseException {Token t;
  CssPropertyNode property;
  String value;
  CssPropertyValueNode valueNode;
  List<Token> tokens = Lists.newArrayList();
    try {
      t = jj_consume_token(CUSTOM_PROPERTY_NAME);
property = new CssPropertyNode(t.image, this.getLocation());
      tokens.add(t);
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[46] = jj_gen;
          break label_29;
        }
        jj_consume_token(S);
      }
      t = jj_consume_token(COLON);
tokens.add(t);
      label_30:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[47] = jj_gen;
          break label_30;
        }
        jj_consume_token(S);
      }
      valueNode = customDeclarationValue();
{if ("" != null) return nodeBuilder.buildDeclarationNode(property, valueNode, tokens);}
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    skipComponentValuesToBefore(RIGHTBRACE, SEMICOLON);
    {if (true) throw e;}
    }
    throw new Error("Missing return statement in function");
  }

// For the time being, we have decided to be more restrictive in what we accept here. Instead of
// following spec, we have decided to parse CSS expressions only. At some point, this may be
// revisited.
//
// custom_declaration_value
//   : expr()
//   ;
  final public CssPropertyValueNode customDeclarationValue() throws ParseException {CssPropertyValueNode value;
    value = expr();
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

// standard_declaration
//   : '*'? IDENTIFIER S* ':' S* expr S* important?
//   ;
  final public CssDeclarationNode standardDeclaration() throws ParseException {Token t;
  CssPropertyNode property;
  CssPropertyValueNode valueNode;
  CssPriorityNode priority = null;
  List<Token> tokens = Lists.newArrayList();
  String propertyName = "";
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:{
        t = jj_consume_token(ASTERISK);
tokens.add(t); propertyName = "*";
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      // allows "star hack"
          t = jj_consume_token(IDENTIFIER);
propertyName = propertyName + t.image;
      property = new CssPropertyNode(propertyName, this.getLocation());
      tokens.add(t);
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[49] = jj_gen;
          break label_31;
        }
        jj_consume_token(S);
      }
      t = jj_consume_token(COLON);
tokens.add(t);
      label_32:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[50] = jj_gen;
          break label_32;
        }
        jj_consume_token(S);
      }
      valueNode = expr();
      label_33:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[51] = jj_gen;
          break label_33;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IMPORTANT_SYM:{
        priority = important();
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        ;
      }
if (priority != null) {
        valueNode.addChildToBack(priority);
      }
      CssDeclarationNode node = nodeBuilder.buildDeclarationNode(property, valueNode, tokens);
      {if ("" != null) return node;}
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    skipComponentValuesToBefore(RIGHTBRACE, SEMICOLON);
    {if (true) throw e;}
    }
    throw new Error("Missing return statement in function");
  }

// expr
//   : composite_term [ composite_term ]*
//   ;
  final public CssPropertyValueNode expr() throws ParseException {List<CssValueNode> lst = Lists.newArrayList();
  CssValueNode value;
    value = composite_term();
lst.add(value);
    label_34:
    while (true) {
      if (jj_2_2(1)) {
        ;
      } else {
        break label_34;
      }
      value = composite_term();
lst.add(value);
    }
CssPropertyValueNode result = new CssPropertyValueNode(lst);
    result.setSourceCodeLocation(mergeLocations(lst));
    {if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// composite_term
//   : assign_term [ ',' assign_term ]*
//   ;
  final public CssValueNode composite_term() throws ParseException {CssValueNode value;
  List<CssValueNode> lst = Lists.newArrayList();
  SourceCodeLocation beginLocation;
  Token t;
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    value = assign_term();
lst.add(value);
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        break label_35;
      }
      t = jj_consume_token(COMMA);
tokens.add(t);
      label_36:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[54] = jj_gen;
          break label_36;
        }
        jj_consume_token(S);
      }
      value = assign_term();
lst.add(value);
    }
if (lst.size() == 1) {
      {if ("" != null) return lst.get(0);}
    } else {
      {if ("" != null) return nodeBuilder.buildCompositeValueNode(lst, CssCompositeValueNode.Operator.COMMA,
          this.mergeLocations(beginLocation, this.getLocation()), tokens);}
    }
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// assign_term
//   : slash_term [ '=' slash_term ]*
//   ;
  final public CssValueNode assign_term() throws ParseException {CssValueNode value;
  List<CssValueNode> lst = Lists.newArrayList();
  SourceCodeLocation beginLocation;
  Token t;
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    value = slash_term();
lst.add(value);
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQUALS:{
        ;
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        break label_37;
      }
      t = jj_consume_token(EQUALS);
tokens.add(t);
      label_38:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[56] = jj_gen;
          break label_38;
        }
        jj_consume_token(S);
      }
      value = slash_term();
lst.add(value);
    }
if (lst.size() == 1) {
      {if ("" != null) return lst.get(0);}
    }
    {if ("" != null) return nodeBuilder.buildCompositeValueNode(lst, CssCompositeValueNode.Operator.EQUALS,
        this.mergeLocations(beginLocation, this.getLocation()), tokens);}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// slash_term
//   : term [ '/' term ]*
//   ;
  final public CssValueNode slash_term() throws ParseException {CssValueNode value;
  List<CssValueNode> lst = Lists.newArrayList();
  SourceCodeLocation beginLocation;
  Token t;
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    value = term();
lst.add(value);
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLASH:{
        ;
        break;
        }
      default:
        jj_la1[57] = jj_gen;
        break label_39;
      }
      t = jj_consume_token(SLASH);
tokens.add(t);
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[58] = jj_gen;
          break label_40;
        }
        jj_consume_token(S);
      }
      value = term();
lst.add(value);
    }
if (lst.size() == 1) {
      {if ("" != null) return lst.get(0);}
    } else {
      {if ("" != null) return nodeBuilder.buildCompositeValueNode(lst, CssCompositeValueNode.Operator.SLASH,
          this.mergeLocations(beginLocation, this.getLocation()), tokens);}
    }
    throw new Error("Missing return statement in function");
  }

// term
//   : unary_operator?
//     [ [ NUMBER [ PERCENT | IDENTIFIER ] ] | STRING | IDENT | FOR_VARIABLE
//       | '(' S? IDENT ':' S* NUMBER [ S* '/' S* NUMBER | IDENT ]? ')'
//       | URI | hexcolor | function | math
//     ] S*
//   ;
  final public CssValueNode term() throws ParseException {Token t = null;
  Token dim = null;
  String unit = null;
  String unop = "";
  CssFunctionNode function = null;
  CssStringNode stringNode = null;
  List<Token> tokens = Lists.newArrayList();
  boolean hexcolor = false;
  boolean loopVariable = false;
  boolean unicodeRange = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MINUS:
    case WPLUS:
    case NUMBER:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MINUS:
      case WPLUS:{
        t = unary_operator();
unop = trim(t.image);   tokens.add(t);
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      // Number with optional arbitrary dimension or percent.
            t = jj_consume_token(NUMBER);
unit = CssNumericNode.NO_UNITS; tokens.add(t);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERCENT:
      case IDENTIFIER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PERCENT:{
          dim = jj_consume_token(PERCENT);
          break;
          }
        case IDENTIFIER:{
          dim = jj_consume_token(IDENTIFIER);
          break;
          }
        default:
          jj_la1[60] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
unit = dim.image.toLowerCase(); tokens.add(dim);
        break;
        }
      default:
        jj_la1[61] = jj_gen;
        ;
      }
      break;
      }
    case UNICODE_RANGE:{
      t = jj_consume_token(UNICODE_RANGE);
unicodeRange = true; tokens.add(t);
      break;
      }
    case DOUBLE_QUOTED_STRING:
    case SINGLE_QUOTED_STRING:{
      stringNode = string();
      break;
      }
    default:
      jj_la1[70] = jj_gen;
      if (jj_2_3(1)) {
        if (getToken(2).kind != DOT && getToken(2).kind != COLON) {

        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        t = jj_consume_token(IDENTIFIER);
tokens.add(t);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FOR_VARIABLE:{
          // For variables will be evaluated to a number eventually.
                t = jj_consume_token(FOR_VARIABLE);
loopVariable = true; tokens.add(t);
          break;
          }
        default:
          jj_la1[71] = jj_gen;
          if (jj_2_4(1)) {
            if (getToken(1).kind == LEFTROUND
                        && (getToken(3).kind == COLON || getToken(4).kind == COLON)) {

            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
            t = jj_consume_token(LEFTROUND);
tokens.add(t);
            try {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case S:{
                jj_consume_token(S);
                break;
                }
              default:
                jj_la1[62] = jj_gen;
                ;
              }
              t = jj_consume_token(IDENTIFIER);
tokens.add(t);
              t = jj_consume_token(COLON);
tokens.add(t);
              label_41:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                case S:{
                  ;
                  break;
                  }
                default:
                  jj_la1[63] = jj_gen;
                  break label_41;
                }
                jj_consume_token(S);
              }
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case NUMBER:{
                t = jj_consume_token(NUMBER);
tokens.add(t);
                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                case SLASH:
                case S:{
                  label_42:
                  while (true) {
                    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                    case S:{
                      ;
                      break;
                      }
                    default:
                      jj_la1[64] = jj_gen;
                      break label_42;
                    }
                    jj_consume_token(S);
                  }
                  t = jj_consume_token(SLASH);
tokens.add(t);
                  label_43:
                  while (true) {
                    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                    case S:{
                      ;
                      break;
                      }
                    default:
                      jj_la1[65] = jj_gen;
                      break label_43;
                    }
                    jj_consume_token(S);
                  }
                  t = jj_consume_token(NUMBER);
tokens.add(t);
                  break;
                  }
                default:
                  jj_la1[66] = jj_gen;
                  ;
                }
                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                case IDENTIFIER:{
                  dim = jj_consume_token(IDENTIFIER);
tokens.add(dim);
                  break;
                  }
                default:
                  jj_la1[67] = jj_gen;
                  ;
                }
                break;
                }
              case IDENTIFIER:{
                t = jj_consume_token(IDENTIFIER);
tokens.add(t);
                break;
                }
              default:
                jj_la1[68] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              label_44:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                case S:{
                  ;
                  break;
                  }
                default:
                  jj_la1[69] = jj_gen;
                  break label_44;
                }
                jj_consume_token(S);
              }
              t = jj_consume_token(RIGHTROUND);
tokens.add(t);
            } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
          skipComponentValuesToAfter(RIGHTROUND);
          {if (true) throw e;}
            }
          } else if (getToken(1).kind == URI) {
            function = uri();
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case HASH_NAME:{
              t = hexcolor();
tokens.add(t); hexcolor = true;
              break;
              }
            case CALC:{
              function = calc();
              break;
              }
            case VARFUNCTION:{
              function = var();
              break;
              }
            case IDENTIFIER:
            case FUNCTION:{
              function = function();
              break;
              }
            default:
              jj_la1[72] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[73] = jj_gen;
        break label_45;
      }
      jj_consume_token(S);
    }
if (unit != null) {
      SourceCodeLocation location;
      if (dim != null) {
        location = this.mergeLocations(this.getLocation(t), this.getLocation(dim));
      } else {
        location = this.getLocation(t);
      }
      {if ("" != null) return nodeBuilder.buildNumericNode(unop + t.image, unit, location, tokens);}
    } else if (function != null) {
      {if ("" != null) return function;}
    } else if (hexcolor) {
      {if ("" != null) return nodeBuilder.buildHexColorNode(t.image, this.getLocation(t), tokens);}
    } else if (stringNode != null) {
      {if ("" != null) return stringNode;}
    } else {
      StringBuilder sb = new StringBuilder();
      for (Token token : tokens) {
        sb.append(token.image);
      }
      if (loopVariable) {
        {if ("" != null) return nodeBuilder.buildLoopVariableNode(sb.toString(), this.getLocation(t), tokens);}
      } else if (unicodeRange) {
        {if ("" != null) return nodeBuilder.buildUnicodeRangeNode(sb.toString(), this.getLocation(t), tokens);}
      } else {
        {if ("" != null) return nodeBuilder.buildLiteralNode(sb.toString(), this.getLocation(t), tokens);}
      }
    }
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// extended_term
//   : boolean_and_term [ '||' S* boolean_and_term ]*
//   ;
  final public CssBooleanExpressionNode extended_term() throws ParseException {SourceCodeLocation beginLocation;
  SourceCodeLocation endLocation;
  CssBooleanExpressionNode newNode = null;
  CssBooleanExpressionNode left = null;
  CssBooleanExpressionNode right = null;
  String value = "";
  Token t;
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    left = boolean_and_term();
value += left.toString();
    label_46:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OR:{
        ;
        break;
        }
      default:
        jj_la1[74] = jj_gen;
        break label_46;
      }
      t = jj_consume_token(OR);
tokens.add(t);
      label_47:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[75] = jj_gen;
          break label_47;
        }
        jj_consume_token(S);
      }
      right = boolean_and_term();
value += right.toString();
        endLocation = this.getLocation();
        newNode = nodeBuilder.buildBoolExpressionNode(
            CssBooleanExpressionNode.Type.OR, value, left, right,
                this.mergeLocations(beginLocation, endLocation), tokens);
        left = newNode;
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// boolean_and_term
//   :  [ boolean_negated_term | basic_term]
//      [ '&&' S* [ boolean_negated_term | basic_term ] ]*
//   ;
  final public CssBooleanExpressionNode boolean_and_term() throws ParseException {SourceCodeLocation beginLocation = null;
  SourceCodeLocation endLocation;
  CssBooleanExpressionNode newNode= null;
  CssBooleanExpressionNode left= null;
  CssBooleanExpressionNode right = null;
  String value = "";
  Token t;
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXCL_MARK:{
      left = boolean_negated_term();
      break;
      }
    default:
      jj_la1[76] = jj_gen;
      if (jj_2_5(1)) {
        left = basic_term();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
value += left.toString();
    label_48:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[77] = jj_gen;
        break label_48;
      }
      t = jj_consume_token(AND);
tokens.add(t);
      label_49:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[78] = jj_gen;
          break label_49;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXCL_MARK:{
        right = boolean_negated_term();
        break;
        }
      default:
        jj_la1[79] = jj_gen;
        if (jj_2_6(1)) {
          right = basic_term();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
value += right.toString();
        endLocation = this.getLocation();
        newNode = nodeBuilder.buildBoolExpressionNode(
            CssBooleanExpressionNode.Type.AND, value, left, right,
                this.mergeLocations(beginLocation, endLocation), tokens);
        left = newNode;
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// boolean_negated_term
//   : '!' S* basic_term
//   ;
  final public CssBooleanExpressionNode boolean_negated_term() throws ParseException {SourceCodeLocation beginLocation;
  String value = "";
  CssBooleanExpressionNode boolNode = null;
  Token t;
  List<Token> tokens = Lists.newArrayList();
    t = jj_consume_token(EXCL_MARK);
value = "!";
      beginLocation = this.getLocation();
      tokens.add(t);
    label_50:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[80] = jj_gen;
        break label_50;
      }
      jj_consume_token(S);
    }
    boolNode = basic_term();
SourceCodeLocation endLocation = this.getLocation();
    {if ("" != null) return nodeBuilder.buildBoolExpressionNode(CssBooleanExpressionNode.Type.NOT,
        value, boolNode, null, this.mergeLocations(beginLocation, endLocation), tokens);}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// basic_term
//   :  term | parenthesized_term
//   ;
  final public CssBooleanExpressionNode basic_term() throws ParseException {SourceCodeLocation beginLocation;
  String value = "";
  CssBooleanExpressionNode node = null;
  CssValueNode termNode = null;
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    if (jj_2_7(1)) {
      termNode = term();
value = termNode.toString();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFTROUND:{
        node = parenthesized_term();
value = node.toString();
        break;
        }
      default:
        jj_la1[81] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
SourceCodeLocation endLocation = this.getLocation();
    if (node == null) {
      {if ("" != null) return nodeBuilder.buildBoolExpressionNode(CssBooleanExpressionNode.Type.CONSTANT,
          value, null, null, this.mergeLocations(beginLocation, endLocation), tokens);}
    } else {
      {if ("" != null) return node;}
    }
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// parenthesized_term
//   : '(' S* extended_term ')' S*
//   ;
  final public CssBooleanExpressionNode parenthesized_term() throws ParseException {Token t;
  List<Token> tokens = Lists.newArrayList();
  CssBooleanExpressionNode node;
    t = jj_consume_token(LEFTROUND);
tokens.add(t);
    try {
      label_51:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[82] = jj_gen;
          break label_51;
        }
        jj_consume_token(S);
      }
      node = extended_term();
      t = jj_consume_token(RIGHTROUND);
tokens.add(t);
      label_52:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[83] = jj_gen;
          break label_52;
        }
        jj_consume_token(S);
      }
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    skipComponentValuesToAfter(RIGHTROUND);
    {if (true) throw e;}
    }
nodeBuilder.attachComments(tokens, node);
    {if ("" != null) return node;}
    throw new Error("Missing return statement in function");
  }

// unary_operator
//   : '-' | '+'
//   ;
  final public Token unary_operator() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MINUS:{
      t = jj_consume_token(MINUS);
      break;
      }
    case WPLUS:{
      t = jj_consume_token(WPLUS);
      break;
      }
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

/*
 * There is a constraint on the color that it must
 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
 */
// hexcolor
//   : HASH_NAME S*
//   ;
  final public Token hexcolor() throws ParseException {Token t;
    t = jj_consume_token(HASH_NAME);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

  final public CssFunctionNode var() throws ParseException {Token t;
  SourceCodeLocation beginLocation;
  StringBuilder functionName = new StringBuilder();
  CssPropertyValueNode defaultValueNode = null;
  List<Token> tokens = Lists.newArrayList();
  List<CssValueNode> arguments = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    t = jj_consume_token(VARFUNCTION);
functionName.append(t.image);
    functionName.setLength(functionName.length() - 1);
    tokens.add(t);
    label_53:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[85] = jj_gen;
        break label_53;
      }
      jj_consume_token(S);
    }
    t = jj_consume_token(CUSTOM_PROPERTY_NAME);
arguments.add(new CssPropertyNode(t.image, this.getLocation()));
    tokens.add(t);
    label_54:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[86] = jj_gen;
        break label_54;
      }
      jj_consume_token(S);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      t = jj_consume_token(COMMA);
tokens.add(t);
      label_55:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[87] = jj_gen;
          break label_55;
        }
        jj_consume_token(S);
      }
      defaultValueNode = customDeclarationValue();
arguments.add(defaultValueNode.getChildAt(0));
      break;
      }
    default:
      jj_la1[88] = jj_gen;
      ;
    }
    t = jj_consume_token(RIGHTROUND);
tokens.add(t);
    SourceCodeLocation endLocation = this.getLocation(t);
    CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();
    addArgumentsWithSeparator(args, arguments, arguments.size(), ",");
    {if ("" != null) return nodeBuilder.buildFunctionNode(
        functionName.toString(),
        this.mergeLocations(beginLocation, endLocation), args, tokens);}
    throw new Error("Missing return statement in function");
  }

  final public CssFunctionNode uri() throws ParseException {Token t;
  String funName;
  CssValueNode arg = null;
  CssPropertyValueNode expr = null;
  SourceCodeLocation beginLocation;
beginLocation = this.getLocation(token.next);
    t = jj_consume_token(URI);
{if ("" != null) return createUrlFunction(t);}
    throw new Error("Missing return statement in function");
  }

// function
//   : [ FUNCTION
//     | [ IDENTIFIER [ '.' | ':' ] [ IDENTIFIER [ '.' | ':' ] ]* FUNCTION ]
//     S* expr ')' S*
//   ;
// Note: We allow the function name to have : and . to support non-standard IE
// functions.
  final public CssFunctionNode function() throws ParseException {Token t;
  CssPropertyValueNode expr;
  SourceCodeLocation beginLocation;
  StringBuilder functionName = new StringBuilder();
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FUNCTION:{
      t = jj_consume_token(FUNCTION);
functionName.append(t.image); functionName.setLength(functionName.length() - 1); tokens.add(t);
      break;
      }
    case IDENTIFIER:{
      t = jj_consume_token(IDENTIFIER);
functionName.append(t.image);  tokens.add(t);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        jj_consume_token(DOT);
functionName.append(".");
        break;
        }
      case COLON:{
        jj_consume_token(COLON);
functionName.append(":");
        break;
        }
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_56:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[90] = jj_gen;
          break label_56;
        }
        t = jj_consume_token(IDENTIFIER);
functionName.append(t.image);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DOT:{
          jj_consume_token(DOT);
functionName.append(".");
          break;
          }
        case COLON:{
          jj_consume_token(COLON);
functionName.append(":");
          break;
          }
        default:
          jj_la1[91] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      t = jj_consume_token(FUNCTION);
functionName.append(t.image); functionName.setLength(functionName.length() - 1);
      break;
      }
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_57:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[93] = jj_gen;
        break label_57;
      }
      jj_consume_token(S);
    }
    expr = expr();
    t = jj_consume_token(RIGHTROUND);
tokens.add(t);
SourceCodeLocation endLocation = this.getLocation();
    CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();
    if (expr.numChildren() == 1) {
      CssValueNode child = expr.getChildAt(0);
      CssCompositeValueNode composite = null;
      if (child instanceof CssCompositeValueNode) {
        composite = (CssCompositeValueNode) child;
      }
      addArgumentsWithSeparator(args, ImmutableList.of(child), 1, " ");
    } else if (FUNCTIONS_WITH_SPACE_SEP_OK.matcher(functionName).matches()) {
      addArgumentsWithSeparator(args, expr.childIterable(), expr.numChildren(), " ");
    } else {
      {if (true) throw generateParseException();}
    }
    CssFunctionNode functionNode = nodeBuilder.buildFunctionNode(
        functionName.toString(),
        this.mergeLocations(beginLocation, endLocation), args, tokens);
    {if ("" != null) return functionNode;}
    throw new Error("Missing return statement in function");
  }

// calc
//  : "calc(" S* sum S* ")"
//  ;
// TODO(user): this production disallows nested calc() expressions like calc(1 + calc(2*3)).
// (This is equivalent to calc(1 + (2*3)), which is allowed by this production.)
  final public CssFunctionNode calc() throws ParseException {Token t;
  SourceCodeLocation beginLocation;
  StringBuilder functionName = new StringBuilder();
  CssValueNode math;
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    t = jj_consume_token(CALC);
functionName.append(t.image);
    functionName.setLength(functionName.length() - 1);
    tokens.add(t);
    label_58:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[94] = jj_gen;
        break label_58;
      }
      jj_consume_token(S);
    }
    math = sum(/* hasParenthesis */ false);
    label_59:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[95] = jj_gen;
        break label_59;
      }
      jj_consume_token(S);
    }
    t = jj_consume_token(RIGHTROUND);
tokens.add(t);
SourceCodeLocation endLocation = this.getLocation(t);
    CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();
    addArgumentsWithSeparator(args, ImmutableList.<CssValueNode>of(math), 1, "");
    {if ("" != null) return nodeBuilder.buildFunctionNode(
        functionName.toString(),
        this.mergeLocations(beginLocation, endLocation), args, tokens);}
    throw new Error("Missing return statement in function");
  }

// sum
//  : product [ S+ [ "+" | "-" ] S+ product ]*
//  ;
  final public CssValueNode sum(boolean hasParenthesis) throws ParseException {Token t;
  CssValueNode operand;
  List<CssValueNode> operands = new ArrayList<CssValueNode>();
  List<CssCompositeValueNode.Operator> operators = new ArrayList<CssCompositeValueNode.Operator>();
    operand = product(hasParenthesis);
operands.add(operand);
    label_60:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WMINUSW:
      case WPLUS:{
        ;
        break;
        }
      default:
        jj_la1[96] = jj_gen;
        break label_60;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WPLUS:{
        jj_consume_token(WPLUS);
        label_61:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[97] = jj_gen;
            break label_61;
          }
          jj_consume_token(S);
        }
operators.add(CssCompositeValueNode.Operator.ADD);
        break;
        }
      case WMINUSW:{
        jj_consume_token(WMINUSW);
operators.add(CssCompositeValueNode.Operator.SUB);
        break;
        }
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      operand = product(/* hasParenthesis */ false);
operands.add(operand);
    }
{if ("" != null) return CssMathNode.createFromOperandsAndOperators(operands, operators, hasParenthesis);}
    throw new Error("Missing return statement in function");
  }

// product
//  : unit [ S* [ "*" S* unit | "/" S* NUMBER ] ]*
//  ;
  final public CssValueNode product(boolean hasParenthesis) throws ParseException {Token t;
  String u = "";
  CssValueNode operand;
  List<CssValueNode> operands = new ArrayList<CssValueNode>();
  List<CssCompositeValueNode.Operator> operators = new ArrayList<CssCompositeValueNode.Operator>();
    operand = unit();
operands.add(operand);
    label_62:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:
      case SLASH:
      case S:{
        ;
        break;
        }
      default:
        jj_la1[99] = jj_gen;
        break label_62;
      }
      label_63:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[100] = jj_gen;
          break label_63;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:{
        jj_consume_token(ASTERISK);
operators.add(CssCompositeValueNode.Operator.MULT);
        label_64:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[101] = jj_gen;
            break label_64;
          }
          jj_consume_token(S);
        }
        operand = unit();
operands.add(operand);
        break;
        }
      case SLASH:{
        jj_consume_token(SLASH);
operators.add(CssCompositeValueNode.Operator.DIV);
        label_65:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[102] = jj_gen;
            break label_65;
          }
          jj_consume_token(S);
        }
        t = jj_consume_token(NUMBER);
operands.add(new CssNumericNode(t.image, ""));
        break;
        }
      default:
        jj_la1[103] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return CssMathNode.createFromOperandsAndOperators(operands, operators, hasParenthesis);}
    throw new Error("Missing return statement in function");
  }

// unit
//  : [ var | IDENTIFIER | NUMBER | DIMENSION | PERCENTAGE | "(" S* sum S* ")" ];
//  ;
  final public CssValueNode unit() throws ParseException {Token t = null;
  String sign = "";
  Token dim = null;
  CssValueNode node = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MINUS:
    case WPLUS:
    case NUMBER:
    case IDENTIFIER:
    case VARFUNCTION:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VARFUNCTION:{
        node = var();
{if ("" != null) return node;}
        break;
        }
      case IDENTIFIER:{
        t = jj_consume_token(IDENTIFIER);
{if ("" != null) return new CssLiteralNode(t.image, this.getLocation(t));}
        break;
        }
      case MINUS:
      case WPLUS:
      case NUMBER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MINUS:
        case WPLUS:{
          t = unary_operator();
sign = t.image;
          break;
          }
        default:
          jj_la1[104] = jj_gen;
          ;
        }
        t = jj_consume_token(NUMBER);

        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PERCENT:
        case IDENTIFIER:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case PERCENT:{
            dim = jj_consume_token(PERCENT);
            break;
            }
          case IDENTIFIER:{
            dim = jj_consume_token(IDENTIFIER);
            break;
            }
          default:
            jj_la1[105] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }

          break;
          }
        default:
          jj_la1[106] = jj_gen;
          ;
        }
{if ("" != null) return new CssNumericNode(sign + t.image, dim != null ? dim.image.toLowerCase() : "", this.getLocation(t));}
        break;
        }
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    case LEFTROUND:{
      jj_consume_token(LEFTROUND);

      try {
        label_66:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[108] = jj_gen;
            break label_66;
          }
          jj_consume_token(S);
        }
        node = sum(/* hasParenthesis */ true);

        label_67:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[109] = jj_gen;
            break label_67;
          }
          jj_consume_token(S);
        }
        jj_consume_token(RIGHTROUND);
{if ("" != null) return node;}
      } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
          skipComponentValuesToAfter(RIGHTROUND);
          {if (true) throw e;}
      }
      break;
      }
    default:
      jj_la1[110] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// at_function
//   : FUNCTION S* expr? ')' S*
//   ;
  final public CssFunctionNode atFunction() throws ParseException {Token t;
  CssPropertyValueNode expr = null;
  SourceCodeLocation beginLocation;
  StringBuilder functionName = new StringBuilder();
  List<Token> tokens = Lists.newArrayList();
beginLocation = this.getLocation(token.next);
    t = jj_consume_token(FUNCTION);
functionName.append(t.image);
    functionName.setLength(functionName.length() - 1);
    tokens.add(t);
    label_68:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[111] = jj_gen;
        break label_68;
      }
      jj_consume_token(S);
    }
    if (jj_2_8(1)) {
      expr = expr();
    } else {
      ;
    }
    t = jj_consume_token(RIGHTROUND);
tokens.add(t);
    label_69:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[112] = jj_gen;
        break label_69;
      }
      jj_consume_token(S);
    }
SourceCodeLocation endLocation = this.getLocation();
    CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();
    if (expr != null && expr.numChildren() == 1) {
      CssValueNode child = expr.getChildAt(0);
      addArgumentsWithSeparator(args, ImmutableList.of(child), 1, " ");
    } else if (expr != null) {
      addArgumentsWithSeparator(args, expr.childIterable(), expr.numChildren(),
          " ");
    }
    CssFunctionNode functionNode = nodeBuilder.buildFunctionNode(
        functionName.toString(),
        this.mergeLocations(beginLocation, endLocation), args, tokens);
    {if ("" != null) return functionNode;}
    throw new Error("Missing return statement in function");
  }

// important
//   : IMPORTANT_SYM S*
//   ;
  final public CssPriorityNode important() throws ParseException {Token t;
  List<Token> tokens = Lists.newArrayList();
  SourceCodeLocation beginLocation, endLocation;
    t = jj_consume_token(IMPORTANT_SYM);
beginLocation = this.getLocation();
    endLocation = this.getLocation();
    tokens.add(t);
    label_70:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[113] = jj_gen;
        break label_70;
      }
      jj_consume_token(S);
    }
{if ("" != null) return nodeBuilder.buildPriorityNode(this.mergeLocations(beginLocation, endLocation), tokens);}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// at_rule
//   : ATKEYWORD S* [ [ composite_term | extended_term ] S* ]*
//     [ [ '{' S* block  '}'  ] | ';' ] S*
//   ;
  final public CssAtRuleNode at_rule() throws ParseException {Token t;
  SourceCodeLocation beginLocation = null;
  CssLiteralNode name;
  CssValueNode v;
  CssBlockNode block = null;
  List<CssValueNode> parameters = Lists.newArrayList();
  List<Token> tokens = Lists.newArrayList();
    try {
      t = jj_consume_token(ATKEYWORD);
beginLocation = this.getLocation(t);
      name = new CssLiteralNode(t.image.substring(1), beginLocation);
      tokens.add(t);
      label_71:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[114] = jj_gen;
          break label_71;
        }
        jj_consume_token(S);
      }
      label_72:
      while (true) {
        if (jj_2_9(1)) {
          ;
        } else {
          break label_72;
        }
        if (jj_2_10(1)) {
          v = composite_term();
        } else if (jj_2_11(1)) {
          v = extended_term();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
parameters.add(v);
        label_73:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[115] = jj_gen;
            break label_73;
          }
          jj_consume_token(S);
        }
      }
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
      skipComponentValuesToAfter(RIGHTBRACE);
    }
    {if (true) throw e;}
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFTBRACE:{
      t = jj_consume_token(LEFTBRACE);
tokens.add(t);
      try {
        label_74:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[116] = jj_gen;
            break label_74;
          }
          jj_consume_token(S);
        }
        block = block(true);
        t = jj_consume_token(RIGHTBRACE);
tokens.add(t);
      } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
        skipComponentValuesToAfter(RIGHTBRACE);
        {if (true) throw e;}
      }
      break;
      }
    case SEMICOLON:{
      t = jj_consume_token(SEMICOLON);
tokens.add(t);
      break;
      }
    default:
      jj_la1[117] = jj_gen;
ParseException e = generateParseException();
      if (enableErrorRecovery && e.currentToken != null) {
        if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
          skipComponentValuesToAfter(RIGHTBRACE);
        }
      }
      {if (true) throw e;}
    }
SourceCodeLocation endLocation = getLocation(t);
    CssAtRuleNode at = nodeBuilder.buildUnknownAtRuleNode(name, block,
        this.mergeLocations(beginLocation, endLocation), parameters, tokens);
    {if ("" != null) return at;}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// at_rule_with_decl_block
//   : ATRULESWITHDECLBLOCK S*
//     [  at_function
//      | [ IDENT? ':' IDENT S* ]
//      | [ [ composite_term | extended_term ] S* ]*
//     ]
//     [ [ '{' S* style_declaration '}  ] | ';' ] S*
//   ;
// TODO(fbenz): Try to reuse selctor parsing instead of [ IDENT? ':' IDENT S* ].
// The problem is that @-rules take a list of value nodes and selectors are not
// value nodes.
  final public CssAtRuleNode atRuleWithDeclBlock() throws ParseException {Token t;
  SourceCodeLocation beginLocation = null;
  CssLiteralNode name;
  CssValueNode v;
  CssAbstractBlockNode block = null;
  List<CssValueNode> parameters = Lists.newArrayList();
  List<Token> tokens = Lists.newArrayList();
  List<Token> pseudoPageTokens = Lists.newArrayList();
    try {
      t = jj_consume_token(ATRULESWITHDECLBLOCK);
beginLocation = this.getLocation(t);
      name = new CssLiteralNode(t.image.substring(1), beginLocation);
      tokens.add(t);
      label_75:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[118] = jj_gen;
          break label_75;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FUNCTION:{
        v = atFunction();
parameters.add(v);
        break;
        }
      default:
        jj_la1[122] = jj_gen;
        if (jj_2_15(1)) {
          if (getToken(1).kind == COLON || getToken(2).kind == COLON) {

          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case IDENTIFIER:{
            t = jj_consume_token(IDENTIFIER);
pseudoPageTokens.add(t);
            v = nodeBuilder.buildLiteralNode(t.image, getLocation(t), pseudoPageTokens);
            parameters.add(v);
            pseudoPageTokens.clear();
            break;
            }
          default:
            jj_la1[119] = jj_gen;
            ;
          }
          t = jj_consume_token(COLON);
pseudoPageTokens.add(t);
          t = jj_consume_token(IDENTIFIER);
pseudoPageTokens.add(t);
          v = nodeBuilder.buildLiteralNode(":" + t.image, getLocation(t), pseudoPageTokens);
          parameters.add(v);
          label_76:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case S:{
              ;
              break;
              }
            default:
              jj_la1[120] = jj_gen;
              break label_76;
            }
            jj_consume_token(S);
          }
        } else {
          label_77:
          while (true) {
            if (jj_2_12(1)) {
              ;
            } else {
              break label_77;
            }
            if (jj_2_13(1)) {
              v = composite_term();
            } else if (jj_2_14(1)) {
              v = extended_term();
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
parameters.add(v);
            label_78:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case S:{
                ;
                break;
                }
              default:
                jj_la1[121] = jj_gen;
                break label_78;
              }
              jj_consume_token(S);
            }
          }
        }
      }
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
      skipComponentValuesToAfter(RIGHTBRACE);
    }
    {if (true) throw e;}
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFTBRACE:{
      t = jj_consume_token(LEFTBRACE);
tokens.add(t);
      try {
        label_79:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[123] = jj_gen;
            break label_79;
          }
          jj_consume_token(S);
        }
        block = styleDeclaration();
        t = jj_consume_token(RIGHTBRACE);
tokens.add(t);
      } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
        skipComponentValuesToAfter(RIGHTBRACE);
        {if (true) throw e;}
      }
      break;
      }
    case SEMICOLON:{
      t = jj_consume_token(SEMICOLON);
tokens.add(t);
      break;
      }
    default:
      jj_la1[124] = jj_gen;
ParseException e = generateParseException();
      if (enableErrorRecovery && e.currentToken != null) {
        if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
          skipComponentValuesToAfter(RIGHTBRACE);
        }
      }
      {if (true) throw e;}
    }
SourceCodeLocation endLocation = getLocation(t);
    CssAtRuleNode at = nodeBuilder.buildUnknownAtRuleNode(name, block,
        this.mergeLocations(beginLocation, endLocation), parameters, tokens);
    {if ("" != null) return at;}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// inner_at_rule
//   : ATKEYWORD S*
//    [  at_function
//     | [ IDENT? ':' IDENT S* ]
//     | [[ composite_term | extended_term ] S* ]*
//    ]
//    [ [ '{' S* style_declaration '} ] | ';' ] S*
//   ;
  final public CssAtRuleNode innerAtRule() throws ParseException {Token t;
  SourceCodeLocation beginLocation = null;
  CssLiteralNode name;
  CssValueNode v;
  CssAbstractBlockNode block = null;
  List<CssValueNode> parameters = Lists.newArrayList();
  List<Token> tokens = Lists.newArrayList();
  List<Token> pseudoPageTokens = Lists.newArrayList();
    try {
      t = jj_consume_token(ATKEYWORD);
beginLocation = this.getLocation(t);
      name = new CssLiteralNode(t.image.substring(1), beginLocation);
      tokens.add(t);
      label_80:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[125] = jj_gen;
          break label_80;
        }
        jj_consume_token(S);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FUNCTION:{
        v = atFunction();
parameters.add(v);
        break;
        }
      default:
        jj_la1[129] = jj_gen;
        if (jj_2_19(1)) {
          if (getToken(1).kind == COLON || getToken(2).kind == COLON) {

          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case IDENTIFIER:{
            t = jj_consume_token(IDENTIFIER);
pseudoPageTokens.add(t);
          v = nodeBuilder.buildLiteralNode(t.image, getLocation(t), pseudoPageTokens);
          parameters.add(v);
          pseudoPageTokens.clear();
            break;
            }
          default:
            jj_la1[126] = jj_gen;
            ;
          }
          t = jj_consume_token(COLON);
pseudoPageTokens.add(t);
          t = jj_consume_token(IDENTIFIER);
pseudoPageTokens.add(t);
          v = nodeBuilder.buildLiteralNode(":" + t.image, getLocation(t), pseudoPageTokens);
          parameters.add(v);
          label_81:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case S:{
              ;
              break;
              }
            default:
              jj_la1[127] = jj_gen;
              break label_81;
            }
            jj_consume_token(S);
          }
        } else {
          label_82:
          while (true) {
            if (jj_2_16(1)) {
              ;
            } else {
              break label_82;
            }
            if (jj_2_17(1)) {
              v = composite_term();
            } else if (jj_2_18(1)) {
              v = extended_term();
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
parameters.add(v);
            label_83:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case S:{
                ;
                break;
                }
              default:
                jj_la1[128] = jj_gen;
                break label_83;
              }
              jj_consume_token(S);
            }
          }
        }
      }
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
      skipComponentValuesToAfter(RIGHTBRACE);
    }
    {if (true) throw e;}
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFTBRACE:{
      t = jj_consume_token(LEFTBRACE);
tokens.add(t);
      try {
        label_84:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case S:{
            ;
            break;
            }
          default:
            jj_la1[130] = jj_gen;
            break label_84;
          }
          jj_consume_token(S);
        }
        block = styleDeclaration();
        t = jj_consume_token(RIGHTBRACE);
tokens.add(t);
      } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
        skipComponentValuesToAfter(RIGHTBRACE);
        {if (true) throw e;}
      }
      break;
      }
    case SEMICOLON:{
      t = jj_consume_token(SEMICOLON);
tokens.add(t);
      break;
      }
    default:
      jj_la1[131] = jj_gen;
ParseException e = generateParseException();
      if (enableErrorRecovery && e.currentToken != null) {
        if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
          skipComponentValuesToAfter(RIGHTBRACE);
        }
      }
      {if (true) throw e;}
    }
SourceCodeLocation endLocation = getLocation(t);
    CssAtRuleNode at = nodeBuilder.buildUnknownAtRuleNode(name, block,
        this.mergeLocations(beginLocation, endLocation), parameters, tokens);
    {if ("" != null) return at;}
    throw new Error("Missing return statement in function");
  }

// (WebKit specific extension. We need a separate rule for the
//  WebKit keyframes, because they don't follow the standard grammar exactly.)
// webkit_keyframes_rule
//   : '@-webkit-keyframes' S* IDENTIFIER S*
//     '{' S* webkit_keyframes_block  '}'*
//   ;
  final public CssAtRuleNode webkit_keyframes_rule() throws ParseException {Token t;
  SourceCodeLocation beginLocation = null;
  CssLiteralNode name;
  CssBlockNode block = null;
  List<CssValueNode> parameters = Lists.newArrayList();
  List<Token> tokens = Lists.newArrayList();
    try {
      t = jj_consume_token(WEBKITKEYFRAMES);
beginLocation = this.getLocation(t);
      name = new CssLiteralNode(t.image.substring(1), beginLocation);
      tokens.add(t);
      label_85:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[132] = jj_gen;
          break label_85;
        }
        jj_consume_token(S);
      }
      t = jj_consume_token(IDENTIFIER);
List<Token> identifierTokens = Lists.newArrayList();
      identifierTokens.add(t);
      CssLiteralNode l =
        nodeBuilder.buildLiteralNode(t.image, getLocation(t), identifierTokens);
      parameters.add(l);
      label_86:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[133] = jj_gen;
          break label_86;
        }
        jj_consume_token(S);
      }
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
      skipComponentValuesToAfter(RIGHTBRACE);
    }
    {if (true) throw e;}
    }
    t = jj_consume_token(LEFTBRACE);
tokens.add(t);
    try {
      label_87:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[134] = jj_gen;
          break label_87;
        }
        jj_consume_token(S);
      }
      block = webkit_keyframes_block();
      t = jj_consume_token(RIGHTBRACE);
tokens.add(t);
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
      skipComponentValuesToAfter(RIGHTBRACE);
      {if (true) throw e;}
    }
SourceCodeLocation endLocation = getLocation(t);
    CssAtRuleNode at = nodeBuilder.buildWebkitKeyframesNode(name, block,
        this.mergeLocations(beginLocation, endLocation), parameters, tokens);
    {if ("" != null) return at;}
    throw new Error("Missing return statement in function");
  }

// (WebKit specific extension)
// webkit_keyframes_block
//   : [ webkit_keyframe_ruleset S* ]*
//   ;
  final public CssBlockNode webkit_keyframes_block() throws ParseException {CssBlockNode block;
  CssNode n;
block = new CssBlockNode(true);
    label_88:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUMBER:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[135] = jj_gen;
        break label_88;
      }
      n = webkit_keyframe_ruleSet();
block.addChildToBack(n);
      label_89:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[136] = jj_gen;
          break label_89;
        }
        jj_consume_token(S);
      }
    }
{if ("" != null) return block;}
    throw new Error("Missing return statement in function");
  }

// (WebKit specific extension)
// webkit_keyframe_ruleset
//   : key_list '{' style_declarations '}'
//   ;
  final public CssKeyframeRulesetNode webkit_keyframe_ruleSet() throws ParseException {CssKeyListNode keys;
  CssDeclarationBlockNode declarations;
  Token t;
  List<Token> tokens = Lists.newArrayList();
    try {
      keys = keyList();
      t = jj_consume_token(LEFTBRACE);
tokens.add(t);
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {
      skipComponentValuesToAfter(RIGHTBRACE);
    }
    {if (true) throw e;}
    }
    try {
      declarations = styleDeclaration();
      t = jj_consume_token(RIGHTBRACE);
tokens.add(t);
    } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
    skipComponentValuesToAfter(RIGHTBRACE);
    {if (true) throw e;}
    }
CssKeyframeRulesetNode ruleSet =
        nodeBuilder.buildKeyframeRulesetNode(declarations, keys, tokens);
    {if ("" != null) return ruleSet;}
    throw new Error("Missing return statement in function");
  }

// (WebKit specific extension)
// key_list
//   : key [ ',' S* key ]*
//   ;
  final public CssKeyListNode keyList() throws ParseException {CssKeyListNode list = new CssKeyListNode();
  CssKeyNode key;
  Token t;
    key = key();
list.addChildToBack(key);
    label_90:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[137] = jj_gen;
        break label_90;
      }
      t = jj_consume_token(COMMA);
nodeBuilder.attachComment(t, key);
      label_91:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          ;
          break;
          }
        default:
          jj_la1[138] = jj_gen;
          break label_91;
        }
        jj_consume_token(S);
      }
      key = key();
list.addChildToBack(key);
    }
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
  }

// (WebKit specific extension)
// key
//   : PERCENTAGE | IDENTIFIER
//   ;
  final public CssKeyNode key() throws ParseException {CssKeyNode n;
  Token key, t, dim;
  String value;
  List<Token> tokens = Lists.newArrayList();
  SourceCodeLocation beginLocation;
beginLocation = this.getLocation(token.next);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:{
      key = jj_consume_token(NUMBER);
tokens.add(key);
      dim = jj_consume_token(PERCENT);
tokens.add(dim); value = key.image + dim.image;
      break;
      }
    case IDENTIFIER:{
      key = jj_consume_token(IDENTIFIER);
tokens.add(key); value = key.image;
      break;
      }
    default:
      jj_la1[139] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_92:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[140] = jj_gen;
        break label_92;
      }
      t = jj_consume_token(S);
tokens.add(t);
    }
SourceCodeLocation endLocation = this.getLocation();
    CssKeyNode keyNode = nodeBuilder.buildKeyNode(key, value,
         this.mergeLocations(beginLocation, endLocation));
    nodeBuilder.attachComments(tokens, keyNode);
    {if ("" != null) return keyNode;}
    throw new Error("Missing return statement in function");
  }

// (non-standard GSS extension)
// block
//   : [ [  ruleset | at_rule | webkit_keyframes_rule
//        | at_rule_with_decl_block
//       ] S*
//     ]*
//   ;
  final public CssBlockNode block(boolean isEnclosedWithBraces) throws ParseException {CssBlockNode block;
  CssNode n;
if (isEnclosedWithBraces) {
      block = new CssBlockNode(isEnclosedWithBraces);
    } else {
      block = globalBlock;
    }
    label_93:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COLON:
      case DOT:
      case ASTERISK:
      case LEFTSQUARE:
      case HASH_NAME:
      case IDENTIFIER:
      case ATLIST:
      case WEBKITKEYFRAMES:
      case ATRULESWITHDECLBLOCK:
      case ATKEYWORD:{
        ;
        break;
        }
      default:
        jj_la1[141] = jj_gen;
        break label_93;
      }
      try {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:
        case DOT:
        case ASTERISK:
        case LEFTSQUARE:
        case HASH_NAME:
        case IDENTIFIER:{
          n = ruleSet();
          break;
          }
        default:
          jj_la1[142] = jj_gen;
          if (jj_2_20(2147483647)) {
            n = atRuleWithCrazySyntax();
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case ATKEYWORD:{
              n = at_rule();
              break;
              }
            case WEBKITKEYFRAMES:{
              n = webkit_keyframes_rule();
              break;
              }
            case ATRULESWITHDECLBLOCK:{
              n = atRuleWithDeclBlock();
              break;
              }
            default:
              jj_la1[143] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
block.addChildToBack(n);
      } catch (ParseException e) {
if (!enableErrorRecovery || e.currentToken == null) {if (true) throw e;}
      handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));
      }
      label_94:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CDO:
        case CDC:
        case S:{
          ;
          break;
          }
        default:
          jj_la1[144] = jj_gen;
          break label_94;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case S:{
          jj_consume_token(S);
          break;
          }
        case CDO:{
          jj_consume_token(CDO);
          break;
          }
        case CDC:{
          jj_consume_token(CDC);
          break;
          }
        default:
          jj_la1[145] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return block;}
    throw new Error("Missing return statement in function");
  }

  final public void start() throws ParseException {
    label_95:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CDO:
      case CDC:
      case S:{
        ;
        break;
        }
      default:
        jj_la1[146] = jj_gen;
        break label_95;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        jj_consume_token(S);
        break;
        }
      case CDO:{
        jj_consume_token(CDO);
        break;
        }
      case CDC:{
        jj_consume_token(CDC);
        break;
        }
      default:
        jj_la1[147] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    block(false);
    jj_consume_token(0);
try {
      validateFinalBlockCommentIfPresent();
    } catch (ParseException e) {
      if (!enableErrorRecovery) {if (true) throw e;}
      handledErrors.add(new GssParserException(getLocation(), e));
    }
  }

// CSS3 has very few syntactic constraints on at-rules. We shouldn't let
// our inability to understand the details of future or non-standard at-rules
// prevent us from parsing the rest of the stylesheet.
// at_rule_with_crazy_syntax
//   : ATKEYWORD S* [^;{] LOOKAHEAD( ( ';' | <?LEFTBRACE> ) ) ';'?
  final public CssAtRuleNode atRuleWithCrazySyntax() throws ParseException {Token t;
  String s;
  SourceCodeLocation beginLocation = null;
  CssLiteralNode name;
  CssLiteralNode nonBlockContent;
  CssLiteralNode blockishContent = null;
  List<Token> tokens = Lists.newArrayList();
  SourceCodeLocation endLocation = null;
    // Don't add more special cases like this one and the webkit keyframes
      // one. If you want to support a new block type that follows the CSS 2.1
      // and 3 grammars and doesn't quite fit into the traditional GssParser
      // expectations, just change ATLIST below to ATKEYWORD, move the
      // use site in the block() to the bottom of its disjunction, and use
      // syntactic LOOKAHEAD(foo()) as needed for each foo() in the other choices
      // at that disjunction to ensure that the parser eventually falls back to
      // this rule. It will cost about 1.5% cpu time, but it will keep us from
      // adding any more code complexity here.
      t = jj_consume_token(ATLIST);
beginLocation = this.getLocation(t);
    name = new CssLiteralNode(t.image.substring(1), beginLocation);
    tokens.add(t);
    label_96:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[148] = jj_gen;
        break label_96;
      }
      jj_consume_token(S);
    }
    s = scanCrazyContent(";{");
nonBlockContent = new CssLiteralNode(s);
    tokens.add(t);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFTBRACE:{
      blockishContent = crazyBlockBrace();
      break;
      }
    default:
      jj_la1[149] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      t = jj_consume_token(SEMICOLON);
tokens.add(t);
      break;
      }
    default:
      jj_la1[150] = jj_gen;
      ;
    }
endLocation = this.getLocation(tokens.get(tokens.size() - 1));
    List<CssValueNode> parameters = Lists.newArrayList();
    if (nonBlockContent == null) {
      {if (true) throw new AssertionError("nonBlockContent should not be null");}
    }
    parameters.add(nonBlockContent);
    if (blockishContent != null) {
      parameters.add(blockishContent);
    }
    {if ("" != null) return nodeBuilder.buildUnknownAtRuleNode(
        name, null, this.mergeLocations(beginLocation, endLocation),
        parameters,
        tokens);}
    throw new Error("Missing return statement in function");
  }

// A last-resort, minimally-restrictive brace-delimited production.
  final public CssLiteralNode crazyBlockBrace() throws ParseException {Token t;
  String s;
  SourceCodeLocation beginLocation;
  SourceCodeLocation endLocation;
  CssLiteralNode childContent = null;
  CssLiteralNode childCrazy = null;
  StringBuilder result = new StringBuilder();
    t = jj_consume_token(LEFTBRACE);
    label_97:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[151] = jj_gen;
        break label_97;
      }
      jj_consume_token(S);
    }
    s = scanCrazyContent("{[()]}");
childContent = new CssLiteralNode(s);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFTSQUARE:
    case LEFTROUND:
    case LEFTBRACE:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFTBRACE:{
        childCrazy = crazyBlockBrace();
        break;
        }
      case LEFTSQUARE:{
        childCrazy = crazyBlockBracket();
        break;
        }
      case LEFTROUND:{
        childCrazy = crazyBlockParen();
        break;
        }
      default:
        jj_la1[152] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[153] = jj_gen;
      ;
    }
    t = jj_consume_token(RIGHTBRACE);
endLocation = this.getLocation(t);
result.append("{");
    if (childContent != null) result.append(childContent.getValue());
    if (childContent != null && childCrazy != null) result.append(" ");
    if (childCrazy != null) result.append(childCrazy.getValue());
    result.append("}");
    {if ("" != null) return new CssLiteralNode(result.toString());}
    throw new Error("Missing return statement in function");
  }

// Inside blocks, brackets, parens, and braces must be balanced.
  final public CssLiteralNode crazyBlockBracket() throws ParseException {Token t;
  String s;
  SourceCodeLocation beginLocation;
  SourceCodeLocation endLocation;
  CssLiteralNode childContent = null;
  CssLiteralNode childCrazy = null;
  StringBuilder result = new StringBuilder();
    t = jj_consume_token(LEFTSQUARE);
    label_98:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[154] = jj_gen;
        break label_98;
      }
      jj_consume_token(S);
    }
    s = scanCrazyContent("{[()]}");
childContent = new CssLiteralNode(s);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFTSQUARE:
    case LEFTROUND:
    case LEFTBRACE:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFTBRACE:{
        childCrazy = crazyBlockBrace();
        break;
        }
      case LEFTSQUARE:{
        childCrazy = crazyBlockBracket();
        break;
        }
      case LEFTROUND:{
        childCrazy = crazyBlockParen();
        break;
        }
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[156] = jj_gen;
      ;
    }
    t = jj_consume_token(RIGHTSQUARE);
endLocation = this.getLocation(t);
result.append("[");
    if (childContent != null) result.append(childContent.getValue());
    if (childContent != null && childCrazy != null) result.append(" ");
    if (childCrazy != null) result.append(childCrazy.getValue());
    result.append("]");
    {if ("" != null) return new CssLiteralNode(result.toString());}
    throw new Error("Missing return statement in function");
  }

// Inside blocks, brackets, parens, and braces must be balanced.
  final public CssLiteralNode crazyBlockParen() throws ParseException {Token t;
  String s;
  SourceCodeLocation beginLocation;
  SourceCodeLocation endLocation;
  CssLiteralNode childContent = null;
  CssLiteralNode childCrazy = null;
  StringBuilder result = new StringBuilder();
    t = jj_consume_token(LEFTROUND);
    label_99:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case S:{
        ;
        break;
        }
      default:
        jj_la1[157] = jj_gen;
        break label_99;
      }
      jj_consume_token(S);
    }
    s = scanCrazyContent("{[()]}");
childContent = new CssLiteralNode(s);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFTSQUARE:
    case LEFTROUND:
    case LEFTBRACE:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFTBRACE:{
        childCrazy = crazyBlockBrace();
        break;
        }
      case LEFTSQUARE:{
        childCrazy = crazyBlockBracket();
        break;
        }
      case LEFTROUND:{
        childCrazy = crazyBlockParen();
        break;
        }
      default:
        jj_la1[158] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[159] = jj_gen;
      ;
    }
    t = jj_consume_token(RIGHTROUND);
endLocation = this.getLocation(t);
result.append("(");
    if (childContent != null) result.append(childContent.getValue());
    if (childContent != null && childCrazy != null) result.append(" ");
    if (childCrazy != null) result.append(childCrazy.getValue());
    result.append(")");
    {if ("" != null) return new CssLiteralNode(result.toString());}
    throw new Error("Missing return statement in function");
  }

  String scanCrazyContent(String endChars) throws ParseException {StringBuilder sb = new StringBuilder();
  Token t;
  while (true) {
    t = getToken(1);
    if (t.kind == EOF) {
      break;
    }
    if (t.image.length() == 1
        && endChars.indexOf(t.image) != -1) {
        break;
    }
    sb.append(t.image);
    t = getNextToken();
  }
  if (sb.length() < 1) {
    throw generateParseException();
  }
  return sb.toString();
  }

  int skipComponentValuesToBefore(Integer... kinds) throws ParseException {Set<Integer> kindset = ImmutableSet.<Integer>builder().add(EOF).add(kinds).build();
  Token t;
  do {
    t = getToken(1);
    if (kindset.contains(t.kind)) {
      return t.kind;
    }
    getNextToken();
  } while ((t.kind != LEFTBRACE || skipComponentValuesToAfter(RIGHTBRACE) != EOF)
      && (t.kind != LEFTROUND || skipComponentValuesToAfter(RIGHTROUND) != EOF)
      && (t.kind != LEFTSQUARE || skipComponentValuesToAfter(RIGHTSQUARE) != EOF));
  return EOF;
  }

  int skipComponentValuesToAfter(Integer... kinds) throws ParseException {int kind = skipComponentValuesToBefore(kinds);
  if (kind != EOF) {
    getNextToken();
  }
  return kind;
  }

  void validateFinalBlockCommentIfPresent() throws ParseException, ParseException {if (token.specialToken != null
      && !VALID_BLOCK_COMMENT_PATTERN.matcher(token.specialToken.image).matches()) {
    // Manually construct a ParseException since this syntax error occurs after the last token,
    // and we don't want the ParseException to reference a non-existent token.
    throw new ParseException("unterminated block comment at EOF");
  }
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_3R_130()
 {
    if (jj_3R_143()) return true;
    return false;
  }

  private boolean jj_3R_129()
 {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_128()
 {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_127()
 {
    if (jj_3R_140()) return true;
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_126()
 {
    if (jj_3R_139()) return true;
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_113()
 {
    if (jj_scan_token(WPLUS)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(45)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_100()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_136()
 {
    if (jj_scan_token(LEFTROUND)) return true;
    return false;
  }

  private boolean jj_3R_104()
 {
    return false;
  }

  private boolean jj_3R_133()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) return true;
    }
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_158()
 {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_103()
 {
    return false;
  }

  private boolean jj_3_16()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3_18()) return true;
    }
    return false;
  }

  private boolean jj_3_4()
 {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == LEFTROUND
            && (getToken(3).kind == COLON || getToken(4).kind == COLON);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_104()) return true;
    if (jj_scan_token(LEFTROUND)) return true;
    return false;
  }

  private boolean jj_3R_148()
 {
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_147()
 {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_121()
 {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_146()
 {
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_111()
 {
    return false;
  }

  private boolean jj_3R_145()
 {
    if (jj_3R_155()) return true;
    return false;
  }

  private boolean jj_3R_125()
 {
    if (jj_scan_token(FOR_VARIABLE)) return true;
    return false;
  }

  private boolean jj_3R_134()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_141()
 {
    if (jj_scan_token(CALC)) return true;
    return false;
  }

  private boolean jj_3R_119()
 {
    Token xsp;
    if (jj_3R_134()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_134()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_3()
 {
    jj_lookingAhead = true;
    jj_semLA = getToken(2).kind != DOT && getToken(2).kind != COLON;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_103()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_105()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) return true;
    }
    return false;
  }

  private boolean jj_3R_124()
 {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_112()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_123()
 {
    if (jj_scan_token(UNICODE_RANGE)) return true;
    return false;
  }

  private boolean jj_3R_118()
 {
    if (jj_3R_133()) return true;
    return false;
  }

  private boolean jj_3R_137()
 {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3_19()
 {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == COLON || getToken(2).kind == COLON;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_111()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_112()) jj_scanpos = xsp;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_155()
 {
    if (jj_scan_token(HASH_NAME)) return true;
    return false;
  }

  private boolean jj_3R_122()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_137()) jj_scanpos = xsp;
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_101()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    }
    return false;
  }

  private boolean jj_3R_106()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == URI;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_154()
 {
    if (jj_scan_token(EXCL_MARK)) return true;
    return false;
  }

  private boolean jj_3R_156()
 {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_153()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_152()
 {
    if (jj_scan_token(FUNCTION)) return true;
    return false;
  }

  private boolean jj_3R_143()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) return true;
    }
    return false;
  }

  private boolean jj_3R_135()
 {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_100()) return true;
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_144()
 {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_139()
 {
    if (jj_scan_token(URI)) return true;
    return false;
  }

  private boolean jj_3R_131()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3_5()) return true;
    }
    return false;
  }

  private boolean jj_3R_120()
 {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_157()
 {
    if (jj_scan_token(LEFTSQUARE)) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3_14()) return true;
    }
    return false;
  }

  private boolean jj_3R_109()
 {
    return false;
  }

  private boolean jj_3R_110()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_102()
 {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind == COLON || getToken(2).kind == COLON;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_109()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) jj_scanpos = xsp;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_108()
 {
    if (jj_3R_131()) return true;
    return false;
  }

  private boolean jj_3R_142()
 {
    if (jj_scan_token(VARFUNCTION)) return true;
    return false;
  }

  private boolean jj_3R_132()
 {
    if (jj_scan_token(S)) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_107()
 {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_117()
 {
    Token xsp;
    if (jj_3R_132()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_132()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_140()
 {
    if (jj_scan_token(HASH_NAME)) return true;
    return false;
  }

  private boolean jj_3R_116()
 {
    if (jj_scan_token(WDEEP)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(45)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_151()
 {
    if (jj_scan_token(SINGLE_QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_150()
 {
    if (jj_scan_token(DOUBLE_QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_scan_token(ATLIST)) return true;
    return false;
  }

  private boolean jj_3R_138()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) return true;
    }
    return false;
  }

  private boolean jj_3R_115()
 {
    if (jj_scan_token(WTILDE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(45)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_149()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) return true;
    }
    return false;
  }

  private boolean jj_3R_114()
 {
    if (jj_scan_token(WGREATER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(45)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** Generated Token Manager. */
  public GssParserCCTokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[160];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x8000,0x0,0x0,0x8020000,0x8020000,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x80,0x0,0x80,0x0,0x0,0x100,0x0,0x0,0x0,0x100,0x218,0x218,0x218,0x218,0x238,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x4,0x0,0x20,0x0,0x20,0x4,0x20,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x8000,0x0,0x100,0x0,0x40,0x0,0x80,0x20000,0x20000,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x80000000,0x0,0x10000,0x40000000,0x0,0x10000,0x0,0x800,0x0,0x0,0x80,0x0,0x0,0x0,0x8000,0x18,0x0,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x60,0x80,0x20000,0x20000,0x80,0x0,0x0,0x880,0x0,0x0,0x0,0x0,0x0,0x0,0x2004,0x0,0x0,0x0,0x0,0x0,0x0,0x2004,0x0,0x0,0x0,0x0,0x0,0x0,0x2004,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x238,0x238,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x4,0x0,0x2a00,0x2a00,0x0,0x2a00,0x2a00,0x0,0x2a00,0x2a00,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x60000000,0x0,0x2000,0x2000,0x0,0x0,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x0,0x0,0x4030000,0x2000,0x4030000,0x2000,0x2000,0x1f,0x2000,0x60000000,0x2000,0x1f,0x8000000,0x8000000,0x8000000,0x8000000,0x8000000,0x0,0x2000,0x2000,0x2000,0x2000,0x2000,0x1e2000,0x2000,0x0,0x2000,0x0,0x2000,0x0,0x2000,0x0,0x0,0x0,0x2000,0x2000,0x0,0x2000,0x2000,0x2000,0x10000000,0x0,0x2000,0x0,0x2000,0x0,0x2000,0x20000,0x0,0x0,0x2000,0x2000,0x2000,0x2000,0x2000,0x0,0x4000000,0x2000,0x64020000,0x0,0x8000000,0x2000,0x0,0x2000,0x0,0x0,0x2000,0x0,0x2000,0x0,0x2000,0x2000,0x20000,0x2000,0x2000,0x2000,0x0,0x0,0x0,0x0,0x0,0x2000,0x2000,0x2000,0x30000,0x2000,0x30000,0x2000,0x2000,0x2000,0x2000,0x0,0x20000,0x0,0x0,0x4020000,0x2000,0x2000,0x4020000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x0,0x2000,0x0,0x2000,0x2000,0x0,0x2000,0x0,0x2000,0x0,0x2000,0x2000,0x0,0x2000,0x0,0x2000,0x2000,0x2000,0x4000000,0x2000,0x0,0x2000,0x4000000,0x2000,0x8000000,0x8000000,0x0,0x2060,0x2060,0x2060,0x2060,0x2000,0x0,0x0,0x2000,0x0,0x0,0x2000,0x0,0x0,0x2000,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x434,0x434,0x6,0x0,0x6,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x4000,0x0,0xc,0x0,0xc,0x4000,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x200,0x2,0x4c4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x404,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x84,0x0,0x0,0x84,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x400,0x0,0x0,0x0,0x4,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x4,0x0,0x7804,0x4,0x7000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[20];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with user supplied CharStream. */
  public GssParserCC(CharStream stream) {
    token_source = new GssParserCCTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 160; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
    jj_lookingAhead = false;
    jj_gen = 0;
    for (int i = 0; i < 160; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public GssParserCC(GssParserCCTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 160; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(GssParserCCTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 160; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private List<int[]> jj_expentries = new ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) {
       return;
    }

    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];

      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }

      for (int[] oldentry : jj_expentries) {
        if (oldentry.length == jj_expentry.length) {
          boolean isMatched = true;

          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              isMatched = false;
              break;
            }

          }
          if (isMatched) {
            jj_expentries.add(jj_expentry);
            break;
          }
        }
      }

      if (pos != 0) {
        jj_lasttokens[(jj_endpos = pos) - 1] = kind;
      }
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[80];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 160; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 80; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 20; i++) {
      try {
        JJCalls p = jj_2_rtns[i];

        do {
          if (p.gen > jj_gen) {
            jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
            switch (i) {
              case 0: jj_3_1(); break;
              case 1: jj_3_2(); break;
              case 2: jj_3_3(); break;
              case 3: jj_3_4(); break;
              case 4: jj_3_5(); break;
              case 5: jj_3_6(); break;
              case 6: jj_3_7(); break;
              case 7: jj_3_8(); break;
              case 8: jj_3_9(); break;
              case 9: jj_3_10(); break;
              case 10: jj_3_11(); break;
              case 11: jj_3_12(); break;
              case 12: jj_3_13(); break;
              case 13: jj_3_14(); break;
              case 14: jj_3_15(); break;
              case 15: jj_3_16(); break;
              case 16: jj_3_17(); break;
              case 17: jj_3_18(); break;
              case 18: jj_3_19(); break;
              case 19: jj_3_20(); break;
            }
          }
          p = p.next;
        } while (p != null);

        } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }

    p.gen = jj_gen + xla - jj_la;
    p.first = token;
    p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
