<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PassRunner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">closure-stylesheets</a> &gt; <a href="index.source.html" class="el_package">com.google.common.css.compiler.passes</a> &gt; <span class="el_source">PassRunner.java</span></div><h1>PassRunner.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.css.compiler.passes;

import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.css.JobDescription;
import com.google.common.css.PrefixingSubstitutionMap;
import com.google.common.css.RecordingSubstitutionMap;
import com.google.common.css.SubstitutionMap;
import com.google.common.css.compiler.ast.CssCompilerPass;
import com.google.common.css.compiler.ast.CssTree;
import com.google.common.css.compiler.ast.ErrorManager;
import com.google.common.css.compiler.ast.GssFunction;

import javax.annotation.Nullable;
import java.util.Map;

/**
 * {@link PassRunner} runs applies a sequence of {@link CssCompilerPass}es to a
 * {@link CssTree}.
 *
 * @author bolinfest@google.com (Michael Bolin)
 */
public class PassRunner {

    private static final ImmutableMap&lt;String, GssFunction&gt;
<span class="fc" id="L43">            EMPTY_GSS_FUNCTION_MAP = ImmutableMap.of();</span>

    private final JobDescription job;
    private final ErrorManager errorManager;
    private final RecordingSubstitutionMap recordingSubstitutionMap;

    public PassRunner(JobDescription job, ErrorManager errorManager) {
<span class="fc" id="L50">        this(job, errorManager, createSubstitutionMap(job));</span>
<span class="fc" id="L51">    }</span>

    public PassRunner(JobDescription job, ErrorManager errorManager,
<span class="fc" id="L54">                      RecordingSubstitutionMap recordingSubstitutionMap) {</span>
<span class="fc" id="L55">        this.job = job;</span>
<span class="fc" id="L56">        this.errorManager = errorManager;</span>
<span class="fc" id="L57">        this.recordingSubstitutionMap = recordingSubstitutionMap;</span>
<span class="fc" id="L58">    }</span>

    /**
     * Runs the passes on the specified {@link CssTree}. This method may be
     * invoked multiple times, as one compilation job may have one {@link CssTree}
     * per input file.
     */
    public void runPasses(CssTree cssTree) {
<span class="fc" id="L66">        new CheckDependencyNodes(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L67">                errorManager, job.suppressDependencyCheck).runPass();</span>
<span class="fc" id="L68">        new CreateStandardAtRuleNodes(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L69">                errorManager).runPass();</span>
<span class="fc" id="L70">        new CreateMixins(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L71">                errorManager).runPass();</span>
<span class="fc" id="L72">        new CreateDefinitionNodes(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L73">                errorManager).runPass();</span>
<span class="fc" id="L74">        new CreateConstantReferences(cssTree.getMutatingVisitController())</span>
<span class="fc" id="L75">                .runPass();</span>
<span class="fc" id="L76">        new CreateConditionalNodes(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L77">                errorManager).runPass();</span>
<span class="fc" id="L78">        new CreateForLoopNodes(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L79">                errorManager).runPass();</span>
<span class="fc" id="L80">        new CreateComponentNodes(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L81">                errorManager).runPass();</span>
<span class="fc" id="L82">        new ValidatePropertyValues(cssTree.getVisitController(), errorManager).runPass();</span>
<span class="fc" id="L83">        new WarnOnCustomProperty(cssTree.getVisitController(), errorManager).runPass();</span>

<span class="fc" id="L85">        new HandleUnknownAtRuleNodes(cssTree.getMutatingVisitController(),</span>
                errorManager, job.allowedAtRules,
<span class="fc" id="L87">                true /* report */, false /* remove */).runPass();</span>
<span class="pc bpc" id="L88" title="3 of 4 branches missed.">        new ProcessKeyframes(cssTree.getMutatingVisitController(),</span>
                errorManager, job.allowKeyframes || job.allowWebkitKeyframes,
<span class="fc" id="L90">                job.simplifyCss).runPass();</span>
<span class="fc" id="L91">        new CreateVendorPrefixedKeyframes(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L92">                errorManager).runPass();</span>
<span class="fc" id="L93">        new EvaluateCompileConstants(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L94">                job.compileConstants).runPass();</span>
<span class="fc" id="L95">        new UnrollLoops(cssTree.getMutatingVisitController(), errorManager).runPass();</span>
<span class="fc" id="L96">        new ProcessRefiners(cssTree.getMutatingVisitController(), errorManager,</span>
<span class="fc" id="L97">                job.simplifyCss).runPass();</span>

        // Eliminate conditional nodes.
<span class="fc" id="L100">        new EliminateConditionalNodes(</span>
<span class="fc" id="L101">                cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L102">                ImmutableSet.copyOf(job.trueConditionNames)).runPass();</span>

        // Collect mixin definitions and replace mixins
<span class="fc" id="L105">        CollectMixinDefinitions collectMixinDefinitions =</span>
<span class="fc" id="L106">                new CollectMixinDefinitions(cssTree.getMutatingVisitController(),</span>
                        errorManager);
<span class="fc" id="L108">        collectMixinDefinitions.runPass();</span>
<span class="fc" id="L109">        new ReplaceMixins(cssTree.getMutatingVisitController(), errorManager,</span>
<span class="fc" id="L110">                collectMixinDefinitions.getDefinitions()).runPass();</span>

<span class="fc" id="L112">        new ProcessComponents&lt;Object&gt;(cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L113">                errorManager).runPass();</span>
        // Collect constant definitions.
<span class="fc" id="L115">        CollectConstantDefinitions collectConstantDefinitionsPass =</span>
                new CollectConstantDefinitions(cssTree);
<span class="fc" id="L117">        collectConstantDefinitionsPass.runPass();</span>
        // Replace constant references.
<span class="fc" id="L119">        ReplaceConstantReferences replaceConstantReferences =</span>
                new ReplaceConstantReferences(cssTree,
<span class="fc" id="L121">                        collectConstantDefinitionsPass.getConstantDefinitions(),</span>
                        true /* removeDefs */, errorManager, job.allowUndefinedConstants);
<span class="fc" id="L123">        replaceConstantReferences.runPass();</span>

<span class="fc" id="L125">        Map&lt;String, GssFunction&gt; gssFunctionMap = getGssFunctionMap();</span>
<span class="fc" id="L126">        new ResolveCustomFunctionNodes(</span>
<span class="fc" id="L127">                cssTree.getMutatingVisitController(), errorManager,</span>
                gssFunctionMap, job.allowUnrecognizedFunctions,
                job.allowedNonStandardFunctions)
<span class="fc" id="L130">                .runPass();</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (job.simplifyCss) {</span>
            // Eliminate empty rules.
<span class="nc" id="L134">            new EliminateEmptyRulesetNodes(cssTree.getMutatingVisitController())</span>
<span class="nc" id="L135">                    .runPass();</span>
            // Eliminating units for zero values.
<span class="nc" id="L137">            new EliminateUnitsFromZeroNumericValues(</span>
<span class="nc" id="L138">                    cssTree.getMutatingVisitController()).runPass();</span>
            // Optimize color values.
<span class="nc" id="L140">            new ColorValueOptimizer(</span>
<span class="nc" id="L141">                    cssTree.getMutatingVisitController()).runPass();</span>
            // Compress redundant top-right-bottom-left value lists.
<span class="nc" id="L143">            new AbbreviatePositionalValues(</span>
<span class="nc" id="L144">                    cssTree.getMutatingVisitController()).runPass();</span>
        }
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (job.eliminateDeadStyles) {</span>
            // Report errors for duplicate declarations
<span class="nc" id="L148">            new DisallowDuplicateDeclarations(</span>
<span class="nc" id="L149">                    cssTree.getVisitController(), errorManager).runPass();</span>
            // Split rules by selector and declaration.
<span class="nc" id="L151">            new SplitRulesetNodes(cssTree.getMutatingVisitController()).runPass();</span>
            // Dead code elimination.
<span class="nc" id="L153">            new MarkRemovableRulesetNodes(cssTree).runPass();</span>
<span class="nc" id="L154">            new EliminateUselessRulesetNodes(cssTree).runPass();</span>
            // Merge of rules with same selector.
<span class="nc" id="L156">            new MergeAdjacentRulesetNodesWithSameSelector(cssTree).runPass();</span>
<span class="nc" id="L157">            new EliminateUselessRulesetNodes(cssTree).runPass();</span>
            // Merge of rules with same styles.
<span class="nc" id="L159">            new MergeAdjacentRulesetNodesWithSameDeclarations(cssTree).runPass();</span>
<span class="nc" id="L160">            new EliminateUselessRulesetNodes(cssTree).runPass();</span>
        }
        // Perform BiDi flipping if required.
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (job.needsBiDiFlipping()) {</span>
<span class="nc" id="L164">            new MarkNonFlippableNodes(cssTree.getVisitController(),</span>
<span class="nc" id="L165">                    errorManager).runPass();</span>
<span class="nc" id="L166">            new BiDiFlipper(cssTree.getMutatingVisitController(),</span>
<span class="nc" id="L167">                    job.swapLtrRtlInUrl, job.swapLeftRightInUrl).runPass();</span>
        }
        // If specified, remove all vendor-specific properties except for the
        // whitelisted vendor.
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (job.vendor != null) {</span>
<span class="nc" id="L172">            new RemoveVendorSpecificProperties(job.vendor,</span>
<span class="nc" id="L173">                    cssTree.getMutatingVisitController()).runPass();</span>
        }
        // Unless all unrecognized properties are allowed, check for unrecognized
        // properties.
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (!job.allowUnrecognizedProperties) {</span>
<span class="fc" id="L178">            new VerifyRecognizedProperties(job.allowedUnrecognizedProperties,</span>
<span class="fc" id="L179">                    cssTree.getVisitController(), errorManager).runPass();</span>
        }
        // Rename class names
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (recordingSubstitutionMap != null) {</span>
<span class="fc" id="L183">            new CssClassRenaming(</span>
<span class="fc" id="L184">                    cssTree.getMutatingVisitController(),</span>
<span class="fc" id="L185">                    recordingSubstitutionMap, null).runPass();</span>
        }
<span class="fc" id="L187">    }</span>

    @Nullable
    public RecordingSubstitutionMap getRecordingSubstitutionMap() {
<span class="fc" id="L191">        return recordingSubstitutionMap;</span>
    }

    /**
     * Creates the CSS class substitution map from the provider, if any.
     * Wraps it in a substitution map that optionally prefixes all of the renamed
     * classes. Additionaly wraps in a recording substituion map which excludes a
     * blacklist of classnames and allows the map to produced as an output.
     */
    private static RecordingSubstitutionMap createSubstitutionMap(
            JobDescription job) {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (job.cssSubstitutionMapProvider != null) {</span>
<span class="nc" id="L203">            SubstitutionMap baseMap = job.cssSubstitutionMapProvider.get();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (baseMap != null) {</span>
<span class="nc" id="L205">                SubstitutionMap map = baseMap;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                if (!job.cssRenamingPrefix.isEmpty()) {</span>
<span class="nc" id="L207">                    map = new PrefixingSubstitutionMap(baseMap, job.cssRenamingPrefix);</span>
                }
<span class="nc" id="L209">                RecordingSubstitutionMap recording =</span>
                        new RecordingSubstitutionMap.Builder()
<span class="nc" id="L211">                                .withSubstitutionMap(map)</span>
<span class="nc" id="L212">                                .shouldRecordMappingForCodeGeneration(</span>
<span class="nc" id="L213">                                        Predicates.not(Predicates.in(job.excludedClassesFromRenaming)))</span>
<span class="nc" id="L214">                                .build();</span>
<span class="nc" id="L215">                recording.initializeWithMappings(job.inputRenamingMap);</span>
<span class="nc" id="L216">                return recording;</span>
            }
        }
<span class="fc" id="L219">        return null;</span>
    }

    /**
     * Gets the GSS function map from the provider, if any.
     *
     * @return the provided map or an empty map if none is provided
     */
    private Map&lt;String, GssFunction&gt; getGssFunctionMap() {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (job.gssFunctionMapProvider == null) {</span>
<span class="fc" id="L229">            return EMPTY_GSS_FUNCTION_MAP;</span>
        }

<span class="nc" id="L232">        Map&lt;String, GssFunction&gt; map =</span>
<span class="nc" id="L233">                job.gssFunctionMapProvider.get(GssFunction.class);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L235">            return EMPTY_GSS_FUNCTION_MAP;</span>
        }

<span class="nc" id="L238">        return map;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>