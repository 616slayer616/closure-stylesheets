<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplaceMixins.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">closure-stylesheets</a> &gt; <a href="index.source.html" class="el_package">com.google.common.css.compiler.passes</a> &gt; <span class="el_source">ReplaceMixins.java</span></div><h1>ReplaceMixins.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.css.compiler.passes;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.css.SourceCodeLocation;
import com.google.common.css.compiler.ast.*;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Stack;

/**
 * Compiler pass that replaces mixins with the corresponding mixin definitions
 * and replaces the variables in the definitions with the values given by the
 * mixin.
 *
 * &lt;p&gt;In addition, this pass ensures that each mixin has a matching definition
 * and that the argument count of the use and the definition is equal.
 *
 * &lt;p&gt;{@link CollectMixinDefinitions} has to run before.
 * {@link ReplaceConstantReferences} has to run afterwards.
 *
 * @author fbenz@google.com (Florian Benz)
 */
public class ReplaceMixins extends DefaultTreeVisitor
        implements CssCompilerPass {
    @VisibleForTesting
    static final String NO_MATCHING_MIXIN_DEFINITION_ERROR_MESSAGE =
            &quot;The name of the mixin matches no mixin definition name&quot;;
    @VisibleForTesting
    static final String ARGUMENT_MISMATCH_ERROR_MESSAGE =
            &quot;The number of arguments of the mixin and the corresponding definition &quot;
                    + &quot;are different&quot;;
    @VisibleForTesting
    static final String CYCLE_ERROR_MESSAGE =
            &quot;A nested mixin call produces a cycle&quot;;
    @VisibleForTesting
    static final String NO_MATCHING_MIXIN_FOR_REF_ERROR_MESSAGE =
            &quot;Internal compiler error: The current definition reference belongs to &quot;
                    + &quot;a mixin but does not match the mixin on top of the stack&quot;;

    private final MutatingVisitController visitController;
    private final ErrorManager errorManager;
    private final Map&lt;String, CssMixinDefinitionNode&gt; definitions;

    /**
     * the current call stack of the mixins
     */
    private Stack&lt;StackFrame&gt; currentMixinStack;

    public ReplaceMixins(MutatingVisitController visitController,
                         ErrorManager errorManager,
<span class="fc" id="L73">                         Map&lt;String, CssMixinDefinitionNode&gt; definitions) {</span>
<span class="fc" id="L74">        this.visitController = visitController;</span>
<span class="fc" id="L75">        this.errorManager = errorManager;</span>
<span class="fc" id="L76">        this.definitions = definitions;</span>
<span class="fc" id="L77">        this.currentMixinStack = new Stack&lt;StackFrame&gt;();</span>
<span class="fc" id="L78">    }</span>

    @Override
    public void leaveMixin(CssMixinNode node) {
<span class="fc bfc" id="L82" title="All 2 branches covered.">        if (!currentMixinStack.empty()) {</span>
<span class="fc" id="L83">            currentMixinStack.peek().decreaseDeclarationCount();</span>
        }
        // This pushes the mixin on the stack if the corresponding definition
        // contains at least one declaration.
<span class="fc" id="L87">        replaceMixin(node);</span>
        // Goes up the stack if this is the last declaration inserted by a mixin.
        // This is done for the case where no mixin is added to the stack.
<span class="fc bfc" id="L90" title="All 2 branches covered.">        while (!currentMixinStack.empty()</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">                &amp;&amp; currentMixinStack.peek().isDeclarationCountZero()) {</span>
<span class="fc" id="L92">            currentMixinStack.pop();</span>
        }
<span class="fc" id="L94">    }</span>

    @Override
    public void leaveDeclaration(CssDeclarationNode node) {
        // Updates the stacks if the last declaration that was added by the last
        // mixin call is reached.
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (currentMixinStack.empty()) {</span>
<span class="fc" id="L101">            return;</span>
        }
        // get the number of declarations left that were added by the last
        // mixin call
<span class="fc" id="L105">        currentMixinStack.peek().decreaseDeclarationCount();</span>
        // go up the stack if this is the last declaration inserted by a mixin
<span class="fc bfc" id="L107" title="All 2 branches covered.">        while (!currentMixinStack.empty()</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">                &amp;&amp; currentMixinStack.peek().isDeclarationCountZero()) {</span>
<span class="fc" id="L109">            currentMixinStack.pop();</span>
        }
<span class="fc" id="L111">    }</span>

    @Override
    public void leaveDeclarationBlock(CssDeclarationBlockNode node) {
<span class="fc" id="L115">        currentMixinStack.clear();</span>
<span class="fc" id="L116">    }</span>

    /**
     * Replaces a variable inside the copy of the mixin definition with the
     * value given by the mixin.
     */
    @Override
    public boolean enterValueNode(CssValueNode node) {
<span class="fc" id="L124">        return replaceReference(node, false /* isArgument */);</span>
    }

    @Override
    public boolean enterArgumentNode(CssValueNode node) {
<span class="fc" id="L129">        return replaceReference(node, true /* isArgument */);</span>
    }

    private boolean replaceReference(CssValueNode node, boolean isArgument) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (!(node instanceof CssConstantReferenceNode)) {</span>
<span class="fc" id="L134">            return true;</span>
        }
<span class="fc" id="L136">        List&lt;CssValueNode&gt; values = getValuesForReference(</span>
                (CssConstantReferenceNode) node, isArgument);
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (values == null) {</span>
<span class="fc" id="L139">            return true;</span>
        }
<span class="fc" id="L141">        visitController.replaceCurrentBlockChildWith(values, false);</span>
<span class="fc" id="L142">        return true;</span>
    }

    /**
     * Replaces a mixin with the declarations of the corresponding definition.
     */
    private void replaceMixin(CssMixinNode mixin) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (containsCycle(mixin)) {</span>
<span class="fc" id="L150">            return;</span>
        }
<span class="fc" id="L152">        CssMixinDefinitionNode currentMixinDefinition</span>
<span class="fc" id="L153">                = definitions.get(mixin.getDefinitionName());</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (currentMixinDefinition == null) {</span>
<span class="fc" id="L155">            errorManager.report(new GssError(</span>
                    NO_MATCHING_MIXIN_DEFINITION_ERROR_MESSAGE,
<span class="fc" id="L157">                    mixin.getSourceCodeLocation()));</span>
<span class="fc" id="L158">            return;</span>
        }
        // Adds deep copies of the declarations in the definition to the current
        // declaration block. The variables are visited and replaced afterwards.
<span class="fc" id="L162">        List&lt;CssNode&gt; mixinDecls =</span>
<span class="fc" id="L163">                currentMixinDefinition.getBlock().deepCopy().getChildren();</span>
<span class="fc" id="L164">        visitController.replaceCurrentBlockChildWith(mixinDecls,</span>
                /* visitTheReplacementNodes */ true);
        // Create a mapping so that references can easily be replaced by their
        // value.
<span class="fc" id="L168">        Map&lt;String, List&lt;CssValueNode&gt;&gt; refMap = createReferenceMapping(mixin,</span>
                currentMixinDefinition);
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (refMap == null) {</span>
<span class="nc" id="L171">            visitController.stopVisit();</span>
<span class="nc" id="L172">            return;</span>
        }
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (mixinDecls.size() == 0) {</span>
<span class="fc" id="L175">            return;</span>
        }
        // Add the mixin and the number of declarations to the stack
<span class="fc" id="L178">        currentMixinStack.push(new StackFrame(mixin, mixinDecls.size(), refMap));</span>
<span class="fc" id="L179">    }</span>

    /**
     * Returns the value of the given reference. The value is defined by the
     * mixin referring to the mixin definition the reference is in.
     */
    private List&lt;CssValueNode&gt; getValuesForReference(
            CssConstantReferenceNode ref, boolean isArgument) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (!(ref.getScope() instanceof CssMixinDefinitionNode)) {</span>
<span class="fc" id="L188">            return null;</span>
        }

<span class="fc" id="L191">        String defName = ref.getValue();</span>
<span class="fc" id="L192">        CssMixinDefinitionNode currentMixinDefinition =</span>
<span class="fc" id="L193">                (CssMixinDefinitionNode) ref.getScope();</span>
<span class="fc" id="L194">        CssMixinNode currentMixin = currentMixinStack.peek().getMixin();</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (!currentMixin.getDefinitionName().equals(</span>
<span class="fc" id="L196">                currentMixinDefinition.getDefinitionName())) {</span>
<span class="nc" id="L197">            errorManager.report(new GssError(</span>
                    NO_MATCHING_MIXIN_FOR_REF_ERROR_MESSAGE,
<span class="nc" id="L199">                    ref.getSourceCodeLocation()));</span>
<span class="nc" id="L200">            return null;</span>
        }

<span class="fc" id="L203">        List&lt;CssValueNode&gt; values = currentMixinStack.peek().getValuesForReference(</span>
<span class="fc" id="L204">                ref.getValue());</span>
<span class="fc" id="L205">        Preconditions.checkNotNull(values);</span>

        // Create deep copies because the values can be inserted in several places.
<span class="fc" id="L208">        ImmutableList.Builder&lt;CssValueNode&gt; builder = ImmutableList.builder();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (CssValueNode val : values) {</span>
<span class="fc bfc" id="L210" title="All 4 branches covered.">            if (isArgument || !&quot; &quot;.equals(val.getValue())) {</span>
                // Values only containing a whitespace are only added if they inside
                // the argument of a function as they are inserted by the parser to
                // separate values that are together seen as one argument.
<span class="fc" id="L214">                builder.add(val.deepCopy());</span>
            }
<span class="fc" id="L216">        }</span>
<span class="fc" id="L217">        return builder.build();</span>
    }

    /**
     * Ensures that no cyclic mixin calls occur.
     */
    private boolean containsCycle(CssMixinNode mixin) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (StackFrame frame : currentMixinStack) {</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (mixin.getDefinitionName().equals(</span>
<span class="fc" id="L226">                    frame.getMixin().getDefinitionName())) {</span>
<span class="fc" id="L227">                errorManager.report(new GssError(</span>
                        CYCLE_ERROR_MESSAGE,
<span class="fc" id="L229">                        frame.getMixin().getSourceCodeLocation()));</span>
<span class="fc" id="L230">                return true;</span>
            }
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">        return false;</span>
    }

    /**
     * Creates a mapping between argument names of the mixin definition and the
     * values that are provided by the mixin.
     */
    private Map&lt;String, List&lt;CssValueNode&gt;&gt; createReferenceMapping(
            CssMixinNode mixin, CssMixinDefinitionNode def) {
<span class="fc" id="L242">        Map&lt;String, List&lt;CssValueNode&gt;&gt; refMap = Maps.newHashMap();</span>
<span class="fc" id="L243">        List&lt;CssValueNode&gt; currentValues = Lists.newArrayList();</span>
<span class="fc" id="L244">        Iterator&lt;CssValueNode&gt; definitionArgumentIterator =</span>
<span class="fc" id="L245">                def.getArguments().getChildIterator();</span>
        // Collects all values up to a comma and then adds these values to the map.
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (CssValueNode arg : mixin.getArguments().getChildren()) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (&quot;,&quot;.equals(arg.getValue())) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if (!addValuesToMap(refMap, definitionArgumentIterator, currentValues,</span>
<span class="fc" id="L250">                        arg.getSourceCodeLocation())) {</span>
<span class="fc" id="L251">                    return null;</span>
                }
<span class="fc" id="L253">                currentValues.clear();</span>
            } else {
<span class="fc" id="L255">                currentValues.add(arg);</span>
            }
<span class="fc" id="L257">        }</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (!currentValues.isEmpty()) {</span>
            // Add values for last argument.
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (!addValuesToMap(refMap, definitionArgumentIterator, currentValues,</span>
<span class="fc" id="L261">                    mixin.getSourceCodeLocation())) {</span>
<span class="fc" id="L262">                return null;</span>
            }
        }
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (definitionArgumentIterator.hasNext()) {</span>
            // The definition takes more arguments than the mixin provides.
<span class="fc" id="L267">            errorManager.report(new GssError(</span>
                    ARGUMENT_MISMATCH_ERROR_MESSAGE,
<span class="fc" id="L269">                    mixin.getSourceCodeLocation()));</span>
<span class="fc" id="L270">            return null;</span>
        }
<span class="fc" id="L272">        return refMap;</span>
    }

    /**
     * Adds the given values to the map that maps argument names to their values.
     */
    private boolean addValuesToMap(Map&lt;String, List&lt;CssValueNode&gt;&gt; refMap,
                                   Iterator&lt;CssValueNode&gt; definitionArgumentIterator,
                                   List&lt;CssValueNode&gt; values, SourceCodeLocation location) {
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">        if (values.isEmpty() || !definitionArgumentIterator.hasNext()) {</span>
            // There is no value between two commas or the mixin provides more
            // arguments than the definition takes.
<span class="fc" id="L284">            errorManager.report(new GssError(</span>
                    ARGUMENT_MISMATCH_ERROR_MESSAGE,
                    location));
<span class="fc" id="L287">            return false;</span>
        }
<span class="fc" id="L289">        CssValueNode argument = definitionArgumentIterator.next();</span>
        // Commas are skipped.
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (&quot;,&quot;.equals(argument.getValue())) {</span>
<span class="pc bpc" id="L292" title="2 of 4 branches missed.">            if (values.isEmpty() || !definitionArgumentIterator.hasNext()) {</span>
<span class="nc" id="L293">                errorManager.report(new GssError(</span>
                        ARGUMENT_MISMATCH_ERROR_MESSAGE,
                        location));
<span class="nc" id="L296">                return false;</span>
            }
<span class="fc" id="L298">            argument = definitionArgumentIterator.next();</span>
        }
<span class="fc" id="L300">        refMap.put(argument.getValue(), ImmutableList.copyOf(values));</span>
<span class="fc" id="L301">        return true;</span>
    }

    @Override
    public void runPass() {
<span class="fc" id="L306">        visitController.startVisit(this);</span>
<span class="fc" id="L307">    }</span>

    /**
     * Helper class that is used to keep track of the called mixins inside of
     * other mixins.
     */
    private static class StackFrame {
        private CssMixinNode mixin;
        private int declarationCount;
        private final Map&lt;String, List&lt;CssValueNode&gt;&gt; valueMap;

        StackFrame(CssMixinNode mixin, int declarationCount,
<span class="fc" id="L319">                   Map&lt;String, List&lt;CssValueNode&gt;&gt; valueMap) {</span>
<span class="fc" id="L320">            Preconditions.checkNotNull(mixin);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            Preconditions.checkArgument(declarationCount &gt; 0);</span>
<span class="fc" id="L322">            Preconditions.checkNotNull(valueMap);</span>
<span class="fc" id="L323">            this.mixin = mixin;</span>
<span class="fc" id="L324">            this.declarationCount = declarationCount;</span>
<span class="fc" id="L325">            this.valueMap = valueMap;</span>
<span class="fc" id="L326">        }</span>

        CssMixinNode getMixin() {
<span class="fc" id="L329">            return mixin;</span>
        }

        void decreaseDeclarationCount() {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (declarationCount &gt; 0) {</span>
<span class="fc" id="L334">                declarationCount--;</span>
            }
<span class="fc" id="L336">        }</span>

        boolean isDeclarationCountZero() {
<span class="fc bfc" id="L339" title="All 2 branches covered.">            return this.declarationCount == 0;</span>
        }

        List&lt;CssValueNode&gt; getValuesForReference(String refName) {
<span class="fc" id="L343">            return valueMap.get(refName);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>