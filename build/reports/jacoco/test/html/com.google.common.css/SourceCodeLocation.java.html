<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SourceCodeLocation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">closure-stylesheets</a> &gt; <a href="index.source.html" class="el_package">com.google.common.css</a> &gt; <span class="el_source">SourceCodeLocation.java</span></div><h1>SourceCodeLocation.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.css;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterables;
import com.google.common.primitives.Ints;

import javax.annotation.Nullable;
import java.util.Iterator;

/**
 * A location in source code. A location is a sequence of adjacent characters
 * that usually represent a token or a larger language construct.
 *
 * &lt;p&gt;Error messages represent the most common use of this class, as an error
 * message usually relates to a source code location. The location related to
 * some messages might not be known; this class has a special value that
 * represents an &quot;unknown&quot; location.
 *
 * &lt;p&gt;Character sequences this class points to can have 0 length. If that is the
 * case, the actual location is that &quot;point&quot; between two source code characters.
 * This usually means that something happens from that point onwards, or that an
 * error has been detected at that point but there is no information regarding
 * the actual token that caused the error.
 *
 * &lt;p&gt;Instances of this class are immutable.
 */
public class SourceCodeLocation implements Comparable&lt;SourceCodeLocation&gt; {

    /**
     * This describes a point in a string. A point is the location between two
     * characters and is indicated by the character index of the immediately
     * following character. For example, in the string &quot;abc&quot;, point 0 refers to
     * the location immediately before the 'a' and point 2 to the location before
     * the 'c'.
     *
     * &lt;p&gt;For convenience we also store the line number of the point (the line
     * that contains the character following the point) and the index in that
     * line. Both of these indices start at 1. The first line of a file is line 1
     * and the point before its first character has index 1 on line 1.
     *
     * &lt;p&gt;The exact definition of lines depends on the language conventions and is
     * best left for the parser to handle. If you want to display the text at that
     * location, either use the character index or use the line number and the
     * index in the line together with lines as they were split by the parser.
     *
     * &lt;p&gt;It might happen that the source code point for something is not known.
     * This is modeled by a point with the special value -1 for the character
     * index. The line and the index on the line must be 0 in this case.
     *
     * &lt;p&gt;Instances of this class are immutable.
     */
    @VisibleForTesting
    public static class SourceCodePoint implements Comparable&lt;SourceCodePoint&gt; {

        /**
         * The index of the character immediately after the source code point.
         * Indices start at 0; -1 means the location is not known.
         */
        private final int characterIndex;

        /**
         * The number of the line that contains the character at characterIndex.
         * Numbers start at 1; 0 means the location is not known.
         */
        private final int lineNumber;

        /**
         * The index in the line identified by lineNumber of the character at
         * characterIndex. Numbers start at 1; 0 means the location is not known.
         */
        private final int indexInLine;

<span class="fc" id="L91">        SourceCodePoint(int characterIndex, int lineNumber, int indexInLine) {</span>
<span class="fc" id="L92">            this.lineNumber = lineNumber;</span>
<span class="fc" id="L93">            this.indexInLine = indexInLine;</span>
<span class="fc" id="L94">            this.characterIndex = characterIndex;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (!hasValidKnownCoordinates()</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">                    &amp;&amp; !hasValidUnknownCoordinates()) {</span>
<span class="nc" id="L97">                throw new IllegalArgumentException(</span>
<span class="nc" id="L98">                        String.format(</span>
                                &quot;The location passed &quot;
                                        + &quot;(lineNumber %d, indexInLine %d, characterIndex %d) &quot;
                                        + &quot;is not valid.&quot;,
<span class="nc" id="L102">                                lineNumber, indexInLine, characterIndex));</span>
            }
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">            if (!hasPlausibleCoordinates()) {</span>
<span class="nc" id="L105">                throw new IllegalArgumentException(</span>
<span class="nc" id="L106">                        String.format(</span>
                                &quot;The location passed &quot;
                                        + &quot;(lineNumber %d, indexInLine %d, characterIndex %d) &quot;
                                        + &quot;is not plausible.&quot;,
<span class="nc" id="L110">                                lineNumber, indexInLine, characterIndex));</span>
            }
<span class="fc" id="L112">        }</span>

        SourceCodePoint(SourceCodePoint that) {
<span class="nc" id="L115">            this(that.characterIndex, that.lineNumber, that.indexInLine);</span>
<span class="nc" id="L116">        }</span>

        boolean hasValidKnownCoordinates() {
<span class="pc bpc" id="L119" title="2 of 6 branches missed.">            return lineNumber &gt;= 1 &amp;&amp; indexInLine &gt;= 1 &amp;&amp; characterIndex &gt;= 0;</span>
        }

        boolean hasValidUnknownCoordinates() {
<span class="pc bpc" id="L123" title="3 of 6 branches missed.">            return characterIndex == -1 &amp;&amp; lineNumber == 0 &amp;&amp; indexInLine == 0;</span>
        }

        boolean hasPlausibleCoordinates() {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">            return characterIndex &gt;= lineNumber - 1 + indexInLine - 1;</span>
        }

        int getCharacterIndex() {
<span class="fc" id="L131">            return characterIndex;</span>
        }

        int getLineNumber() {
<span class="fc" id="L135">            return lineNumber;</span>
        }

        int getIndexInLine() {
<span class="fc" id="L139">            return indexInLine;</span>
        }

        boolean isUnknown() {
<span class="fc bfc" id="L143" title="All 2 branches covered.">            return characterIndex == -1;</span>
        }

        @Override
        public boolean equals(@Nullable Object o) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (o == null) {</span>
<span class="nc" id="L149">                return false;</span>
            }
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (!(o instanceof SourceCodePoint)) {</span>
<span class="nc" id="L152">                return false;</span>
            }
<span class="fc" id="L154">            SourceCodePoint other = (SourceCodePoint) o;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            boolean areEqual = this.characterIndex == other.characterIndex;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">            if (areEqual) {</span>
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">                Preconditions.checkState((this.lineNumber == other.lineNumber)</span>
                                &amp;&amp; (this.indexInLine == other.indexInLine),
                        &quot;Character indexes are equal but line numbers and indexes within &quot; +
                                &quot;the line do not match.&quot;);
            } else {
<span class="pc bpc" id="L162" title="1 of 4 branches missed.">                Preconditions.checkState((this.lineNumber != other.lineNumber)</span>
                                || (this.indexInLine != other.indexInLine),
                        &quot;Line numbers and indexes within the line match but character &quot; +
                                &quot;indexes are not equal&quot;);
            }
<span class="fc" id="L167">            return areEqual;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L172">            return characterIndex;</span>
        }

        @Override
        public int compareTo(SourceCodePoint o) {
<span class="fc" id="L177">            Preconditions.checkNotNull(o);</span>
<span class="fc" id="L178">            return Ints.compare(this.characterIndex, o.characterIndex);</span>
        }
    }

<span class="fc" id="L182">    private static final SourceCode UNKNOWN_SOURCE_CODE =</span>
            new SourceCode(&quot;unknown&quot;, &quot;&quot;);

<span class="fc" id="L185">    private static final Function&lt;Locatable, SourceCodeLocation&gt; LOCATABLE_TO_LOCATION =</span>
<span class="fc" id="L186">            new Function&lt;Locatable, SourceCodeLocation&gt;() {</span>
                @Override
                public SourceCodeLocation apply(Locatable locatable) {
<span class="fc" id="L189">                    return locatable.getSourceCodeLocation();</span>
                }
            };

    /**
     * Returns an unknown location.
     */
    public static SourceCodeLocation getUnknownLocation() {
<span class="fc" id="L197">        SourceCodeLocation result = new SourceCodeLocation(</span>
                UNKNOWN_SOURCE_CODE,
                -1 /* beginCharacterIndex */,
                0 /* beginLineNumber */,
                0 /* beginIndexInLine */,
                -1 /* endCharacterindex */,
                0 /* endLineNumber */,
                0 /* endIndexInLine */);
<span class="fc" id="L205">        Preconditions.checkState(result.isUnknown());</span>
<span class="fc" id="L206">        Preconditions.checkState(result.begin.hasValidUnknownCoordinates());</span>
<span class="fc" id="L207">        Preconditions.checkState(result.end.hasValidUnknownCoordinates());</span>
<span class="fc" id="L208">        return result;</span>
    }

    /**
     * Returns a new SourceCodeLocation which covers everything between the beginning of the first
     * location and the end of the second location.
     */
    public static SourceCodeLocation merge(
            SourceCodeLocation beginLocation, SourceCodeLocation endLocation) {
<span class="fc" id="L217">        Preconditions.checkNotNull(beginLocation, &quot;Begin location can not be null&quot;);</span>
<span class="fc" id="L218">        Preconditions.checkNotNull(endLocation, &quot;End location can not be null&quot;);</span>
<span class="fc" id="L219">        Preconditions.checkArgument(</span>
<span class="fc" id="L220">                beginLocation.sourceCode.equals(endLocation.sourceCode),</span>
                &quot;Locations %s and %s come from different files; they cannot be merged&quot;,
                beginLocation,
                endLocation);
<span class="fc" id="L224">        Preconditions.checkArgument(</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">                beginLocation.compareTo(endLocation) &lt;= 0,</span>
                &quot;Begin location %s must be less than or equal to end location %s&quot;,
                beginLocation,
                endLocation);
<span class="fc" id="L229">        return new SourceCodeLocation(</span>
                beginLocation.sourceCode,
<span class="fc" id="L231">                beginLocation.getBeginCharacterIndex(),</span>
<span class="fc" id="L232">                beginLocation.getBeginLineNumber(),</span>
<span class="fc" id="L233">                beginLocation.getBeginIndexInLine(),</span>
<span class="fc" id="L234">                endLocation.getEndCharacterIndex(),</span>
<span class="fc" id="L235">                endLocation.getEndLineNumber(),</span>
<span class="fc" id="L236">                endLocation.getEndIndexInLine());</span>
    }

    /**
     * Merges the locations of all of the given locations. If the locations span {@code SourceCode}s,
     * only the locations in the first {@code SourceCode} are used. If locations are out of order,
     * the bounding locations are used.
     */
    public static SourceCodeLocation mergeAll(Iterable&lt;SourceCodeLocation&gt; locations) {
<span class="fc" id="L245">        Iterator&lt;SourceCodeLocation&gt; i = locations.iterator();</span>

<span class="fc" id="L247">        SourceCodeLocation loc = null;</span>
<span class="fc bfc" id="L248" title="All 4 branches covered.">        while (i.hasNext() &amp;&amp; loc == null) {</span>
<span class="fc" id="L249">            loc = i.next();</span>
        }
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (!i.hasNext()) {</span>
<span class="fc" id="L252">            return loc; // NOTE(flan): Many places assume that missing locations are null, not unknown.</span>
        }

<span class="fc" id="L255">        SourceCode sourceCode = loc.sourceCode;</span>
<span class="fc" id="L256">        SourceCodePoint begin = loc.begin;</span>
<span class="fc" id="L257">        SourceCodePoint end = loc.end;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        while (i.hasNext()) {</span>
<span class="fc" id="L259">            loc = i.next();</span>
<span class="pc bpc" id="L260" title="2 of 6 branches missed.">            if (loc == null || loc.isUnknown() || !loc.sourceCode.equals(sourceCode)) {</span>
<span class="fc" id="L261">                continue;</span>
            }
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (loc.begin.compareTo(begin) &lt; 0) {</span>
<span class="fc" id="L264">                begin = loc.begin;</span>
            }
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (loc.end.compareTo(end) &gt; 0) {</span>
<span class="fc" id="L267">                end = loc.end;</span>
            }
        }
<span class="fc" id="L270">        return new SourceCodeLocation(sourceCode, begin, end);</span>
    }

    /**
     * Merges the locations of all of the given locations. If the locations span {@code SourceCode}s,
     * only the locations in the first {@code SourceCode} are used.
     */
    public static SourceCodeLocation merge(Iterable&lt;? extends Locatable&gt; locations) {
<span class="fc" id="L278">        return mergeAll(Iterables.transform(locations, LOCATABLE_TO_LOCATION));</span>
    }

    private final SourceCode sourceCode;

    /**
     * The sequence starts at the character immediately following the begin point.
     */
    private final SourceCodePoint begin;

    /**
     * The sequence ends at the character immediately before the end point. The
     * character immediately after the end point (the one indicated by the end's
     * {@link SourceCodePoint#characterIndex}) is not part of the sequence. The
     * empty sequence's begin point and end point are the same:
     * {@code begin.equals(end)}.
     */
    private final SourceCodePoint end;

    @VisibleForTesting
<span class="fc" id="L298">    public SourceCodeLocation(SourceCode sourceCode, SourceCodePoint begin, SourceCodePoint end) {</span>
<span class="fc" id="L299">        Preconditions.checkNotNull(sourceCode);</span>
<span class="fc" id="L300">        this.sourceCode = sourceCode;</span>
<span class="fc" id="L301">        this.begin = begin;</span>
<span class="fc" id="L302">        this.end = end;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        Preconditions.checkArgument(begin.compareTo(end) &lt;= 0,</span>
                &quot;Beginning location must come before the end location.&quot;);
<span class="fc" id="L305">    }</span>

    @VisibleForTesting
    public SourceCodeLocation(
            SourceCode sourceCode,
            int beginCharacterIndex,
            int beginLineNumber,
            int beginIndexInLine,
            int endCharacterIndex,
            int endLineNumber,
            int endIndexInLine) {
<span class="fc" id="L316">        this(</span>
                sourceCode,
                new SourceCodePoint(beginCharacterIndex, beginLineNumber, beginIndexInLine),
                new SourceCodePoint(endCharacterIndex, endLineNumber, endIndexInLine));
<span class="fc" id="L320">    }</span>

    public SourceCode getSourceCode() {
<span class="fc" id="L323">        return sourceCode;</span>
    }

    public boolean isUnknown() {
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        Preconditions.checkState(begin.isUnknown() == end.isUnknown());</span>
<span class="fc" id="L328">        return begin.isUnknown();</span>
    }

    public int getBeginCharacterIndex() {
<span class="fc" id="L332">        return begin.getCharacterIndex();</span>
    }

    /**
     * The index of the line that contains the first character of the node. Indexes start at 1; 0
     * means the location is not known.
     */
    public int getBeginLineNumber() {
<span class="fc" id="L340">        return begin.getLineNumber();</span>
    }

    /**
     * The index of the column that contains the first character of the node. Indexes start at 1; 0
     * means the location is not known.
     */
    public int getBeginIndexInLine() {
<span class="fc" id="L348">        return begin.getIndexInLine();</span>
    }

    public int getEndCharacterIndex() {
<span class="fc" id="L352">        return end.getCharacterIndex();</span>
    }

    /**
     * The index of the line that contains the last character of the node. Indexes start at 1; 0 means
     * the location is not known.
     */
    public int getEndLineNumber() {
<span class="fc" id="L360">        return end.getLineNumber();</span>
    }

    /**
     * The index of the column that comes after the last character of the node. Indexes start at 1; 0
     * means the location is not known.
     */
    public int getEndIndexInLine() {
<span class="fc" id="L368">        return end.getIndexInLine();</span>
    }

    public int getCharacterIndex() {
<span class="fc" id="L372">        return getBeginCharacterIndex();</span>
    }

    public int getLineNumber() {
<span class="fc" id="L376">        return getBeginLineNumber();</span>
    }

    public int getIndexInLine() {
<span class="nc" id="L380">        return getBeginIndexInLine();</span>
    }

    public SourceCodePoint getBegin() {
<span class="fc" id="L384">        return begin;</span>
    }

    public SourceCodePoint getEnd() {
<span class="fc" id="L388">        return end;</span>
    }

    @Override
    public boolean equals(@Nullable Object o) {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (o == null) {</span>
<span class="fc" id="L394">            return false;</span>
        }
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (!(o instanceof SourceCodeLocation)) {</span>
<span class="nc" id="L397">            return false;</span>
        }
<span class="fc" id="L399">        SourceCodeLocation other = (SourceCodeLocation) o;</span>
<span class="fc bfc" id="L400" title="All 4 branches covered.">        return sourceCode == other.sourceCode &amp;&amp; begin.equals(other.begin)</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                &amp;&amp; end.equals(other.end);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L406">        return sourceCode.hashCode() ^ begin.hashCode() ^ (end.hashCode() &lt;&lt; 16);</span>
    }

    /**
     * Comparison and ordering of locations for source code in different
     * input files is supported because we don't always preserve
     * locations during AST mutations and yet we still want to be able
     * to sort error reports, doing the best job we can for the errors
     * that have known locations. For the semantics of this method, see
     * {@link Comparable#compareTo(Object)}.
     */
    @Override
    public int compareTo(SourceCodeLocation o) {
<span class="fc" id="L419">        Preconditions.checkNotNull(o);</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        if (sourceCode != o.sourceCode) {</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (sourceCode == null) {</span>
<span class="nc" id="L422">                return -1;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            } else if (o.sourceCode == null) {</span>
<span class="nc" id="L424">                return 1;</span>
            } else {
<span class="nc" id="L426">                return sourceCode.hashCode() - o.sourceCode.hashCode();</span>
            }
        }
<span class="fc" id="L429">        int startPointsComparison = begin.compareTo(o.begin);</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (startPointsComparison != 0) {</span>
<span class="fc" id="L431">            return startPointsComparison;</span>
        }
<span class="fc" id="L433">        return end.compareTo(o.end);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L438">        return String.format(</span>
                &quot;%s: [line %d, col %d -&gt; line %d, col %d)&quot;, // half-open interval notation
<span class="fc" id="L440">                sourceCode.getFileName(),</span>
<span class="fc" id="L441">                begin.getLineNumber(),</span>
<span class="fc" id="L442">                begin.getIndexInLine(),</span>
<span class="fc" id="L443">                end.getLineNumber(),</span>
<span class="fc" id="L444">                end.getIndexInLine());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>