<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GssParserCC.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">closure-stylesheets</a> &gt; <a href="index.source.html" class="el_package">com.google.common.css.compiler.ast</a> &gt; <span class="el_source">GssParserCC.java</span></div><h1>GssParserCC.java</h1><pre class="source lang-java linenums">/* GssParserCC.java */
/* Generated By:JavaCC: Do not edit this line. GssParserCC.java */
package com.google.common.css.compiler.ast;

import com.google.common.base.CharMatcher;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.css.SourceCode;
import com.google.common.css.SourceCodeLocation;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * A parser that recognizes GSS files and builds the new AST.
 */
@SuppressWarnings({&quot;java:S3776&quot;, &quot;java:S1199&quot;})
public class GssParserCC implements GssParserCCConstants {

    /**
     * Pattern for functions that are allowed to be separated by spaces.
     *
     * &lt;p&gt;The non-standard {@code rect(0 0 0 0)} is sometimes used for IE instead
     * of the standard {@code rect(0,0,0,0)}.
     *
     * &lt;p&gt;The legacy {@code -webkit-gradient} function takes its arguments in the
     * form:
     * {@code (linear, left center, right center, from(color1), to(color2))}.
     * As does {@code -khtml-gradient}.
     *
     * &lt;p&gt;The gradient proposals for CSS 3 are:
     * &lt;ul&gt;
     * &lt;li&gt;linear-gradient
     * &lt;li&gt;radial-gradient
     * &lt;li&gt;repeating-linear-gradient
     * &lt;li&gt;repeating-radial-gradient
     * &lt;/ul&gt;
     * As CSS 3 is in draft stage they come in current browsers with a vendor
     * prefix but leaving out the vendor prefix already works.
     */
<span class="fc" id="L45">    private static final Pattern FUNCTIONSWITHSPACESEPOK = Pattern.compile(</span>
            &quot;(?:-(?:O|MOZ|WEBKIT|MS)-)?(?:REPEATING-)?(?:LINEAR|RADIAL)-GRADIENT&quot;
                    + &quot;|(?:-(?:O|MOZ|WEBKIT|MS)-)?IMAGE-SET&quot;
                    + &quot;|RECT|INSET|CIRCLE|ELLIPSE|POLYGON|-KHTML-GRADIENT|-WEBKIT-GRADIENT&quot;
                    + &quot;|(?:-WEBKIT-)?DROP-SHADOW|(?:-WEBKIT-)?CUSTOM|LOCAL&quot;,
            Pattern.CASE_INSENSITIVE);

<span class="fc" id="L52">    private static final ImmutableSet&lt;String&gt; URLFUNCTIONS = ImmutableSet.of(</span>
            &quot;domain&quot;, &quot;url&quot;, &quot;url-prefix&quot;);

<span class="fc" id="L55">    private static final CharMatcher CSSWHITESPACE =</span>
<span class="fc" id="L56">            CharMatcher.anyOf(&quot; \t\r\n\f&quot;);</span>

<span class="fc" id="L58">    private static final Pattern VALIDBLOCKCOMMENTPATTERN =</span>
<span class="fc" id="L59">            Pattern.compile(&quot;.*/\\*.*\\*/.*&quot;, Pattern.DOTALL);</span>

    private CssBlockNode globalBlock;
    private SourceCode sourceCode;
<span class="fc" id="L63">    private final CssNodeBuilder nodeBuilder = new CssNodeBuilder();</span>
    private StringCharStream charStream;

    /**
     * CSS Error Handling (http://www.w3.org/TR/css-syntax-3/#error-handling) is implemented by the
     * demand from Play Book. It still may abort throwing GssParserException due to unhandled errors.
     */
    private boolean enableErrorRecovery;


    /**
     * List of handled errors if error handling enabled.
     */
<span class="fc" id="L76">    private final List&lt;GssParserException&gt; handledErrors = Lists.newArrayList();</span>

    private SourceCodeLocation getLocation() {
<span class="fc" id="L79">        return getLocation(token);</span>
    }

    private SourceCodeLocation getLocation(Token t) {
<span class="fc" id="L83">        int lineNumber1 = t.beginLine;</span>
<span class="fc" id="L84">        int indexInLine1 = t.beginColumn;</span>
<span class="fc" id="L85">        int charIndex1 = charStream.convertToCharacterIndex(lineNumber1,</span>
                indexInLine1);
<span class="fc" id="L87">        int lineNumber2 = t.endLine;</span>
<span class="fc" id="L88">        int indexInLine2 = t.endColumn + 1; // Need to advance 1 to be beyond the end of the token.</span>
<span class="fc" id="L89">        int charIndex2 = charStream.convertToCharacterIndex(lineNumber2,</span>
                indexInLine2);
<span class="fc" id="L91">        return new SourceCodeLocation(sourceCode, charIndex1, lineNumber1,</span>
                indexInLine1, charIndex2, lineNumber2, indexInLine2);
    }

    /**
     * Returns a new SourceCodeLocation which covers everything between the
     * beginning of the first location and the end of the second location.
     */
    private SourceCodeLocation mergeLocations(SourceCodeLocation beginLocation,
                                              SourceCodeLocation endLocation) {
<span class="fc" id="L101">        return SourceCodeLocation.merge(beginLocation, endLocation);</span>
    }

    private SourceCodeLocation mergeLocations(
            Iterable&lt;? extends CssNode&gt; locations) {
<span class="fc" id="L106">        return SourceCodeLocation.merge(locations);</span>
    }

    private CssFunctionNode createUrlFunction(Token t) {
        // We tried using finer-grained tokens for URI parsing, but an
        // unquoted URI can look just like an identifier or even a whole
        // declaration. We tried using lexical states to recognize bare
        // URIs only within URLFUNCTIONS, but that had two problems:
        // (1) it means ordinary functions can't take bare URLs, which
        // harms orthogonality of GSS and outlaws some custom functions
        // we've found in the wild
        // (2) it means our special lexical state must either exclude
        // ordinary functions, or we must import many other tokens into this
        // new state, which adds complexity for little benefit.
        // Therefore, we ask the lexer to distinguish only big
        // recognizably-URLish chunks of input and break those down here.
<span class="fc" id="L122">        SourceCodeLocation loc = this.getLocation(t);</span>
<span class="fc" id="L123">        int pi = t.image.indexOf('(');</span>
<span class="fc" id="L124">        String funName = t.image.substring(0, pi);</span>
<span class="fc" id="L125">        Preconditions.checkState(URLFUNCTIONS.contains(funName));</span>
<span class="fc" id="L126">        CssFunctionNode.Function funType = CssFunctionNode.Function.byName(funName);</span>
<span class="fc" id="L127">        CssFunctionNode fun = new CssFunctionNode(funType, loc);</span>
<span class="fc" id="L128">        String parenContents = trim(t.image.substring(pi + 1, t.image.length() - 1));</span>
<span class="fc" id="L129">        CssValueNode arg = new CssLiteralNode(parenContents, loc);</span>
<span class="fc" id="L130">        fun.setArguments(new CssFunctionArgumentsNode(ImmutableList.of(arg)));</span>
<span class="fc" id="L131">        return fun;</span>
    }

    /**
     * Adds the given arguments explicitly separated by the given
     * separator to the given node. If an argument is a composite node
     * separated by commas, this method adds its children explicitly
     * separated by commas instead of the composite node, in order to
     * flatten out the argument list.
     *
     * &lt;p&gt;Separators such as commas in function calls have to be added
     * explicitly, in order to match the output from the old tree
     * converter.
     *
     * @param node    The function arguments node to add to
     * @param args    The real arguments to add
     * @param numArgs The number of real arguments
     * @param sep     The separator to add between real arguments
     */
    private void addArgumentsWithSeparator(
            CssFunctionArgumentsNode node,
            Iterable&lt;CssValueNode&gt; args,
            int numArgs,
            String sep) {
<span class="fc" id="L155">        int current = 0;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (CssValueNode arg : args) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (arg instanceof CssCompositeValueNode &amp;&amp;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                    ((CssCompositeValueNode) arg).getOperator() == CssCompositeValueNode.Operator.COMMA) {</span>
<span class="fc" id="L159">                CssCompositeValueNode composite = (CssCompositeValueNode) arg;</span>
<span class="fc" id="L160">                addArgumentsWithSeparator(node, composite.getValues(), composite.getValues().size(), &quot;,&quot;);</span>
<span class="fc" id="L161">            } else {</span>
<span class="fc" id="L162">                node.addChildToBack(arg);</span>
            }
<span class="fc" id="L164">            current++;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (current &lt; numArgs) {</span>
                // Note that the source location for the separator is not entirely
                // accurate, but adding the separators as values is a hack anyways.
<span class="fc" id="L168">                node.addChildToBack(</span>
<span class="fc" id="L169">                        new CssLiteralNode(sep, arg.getSourceCodeLocation()));</span>
            }
<span class="fc" id="L171">        }</span>
<span class="fc" id="L172">    }</span>

    private static String trim(String input) {
<span class="fc" id="L175">        return CSSWHITESPACE.trimFrom(input);</span>
    }

    public void parse() throws GssParserException {
        try {
<span class="fc" id="L180">            start();</span>
<span class="fc" id="L181">        } catch (ParseException e) {</span>
            // token.next can be null if there is an error after EOF, such as an unterminated block
            // comment.
<span class="fc bfc" id="L184" title="All 2 branches covered.">            Token tokenWithError = token.next == null ? token : token.next;</span>
<span class="fc" id="L185">            throw new GssParserException(this.getLocation(tokenWithError), e);</span>
<span class="fc" id="L186">        }</span>
<span class="fc" id="L187">    }</span>

    /**
     * Wrapper around {@code parse()} that (re-)initializes the parser and
     * clears its state afterwards.
     *
     * @param globalBlock   the place to store parsing result
     * @param sourceCode    the source code to parse
     * @param errorHandling whether error handling is enabled
     * @param parsingErrors the place to store errors occured during parsing
     */
    public void parse(CssBlockNode globalBlock,
                      SourceCode sourceCode,
                      boolean errorHandling,
                      ImmutableList.Builder&lt;GssParserException&gt; parsingErrors)
            throws GssParserException {
        try {
<span class="fc" id="L204">            initialize(globalBlock, sourceCode, errorHandling);</span>
<span class="fc" id="L205">            parse();</span>
        } finally {
<span class="fc" id="L207">            parsingErrors.addAll(handledErrors);</span>
<span class="fc" id="L208">            clearState();</span>
        }
<span class="fc" id="L210">    }</span>

    /**
     * This helper class takes care of the creation of nodes of the AST, and
     * attaching comments to them.
     */
<span class="fc" id="L216">    private class CssNodeBuilder {</span>

        protected CssNode attachComments(List&lt;Token&gt; tokens, CssNode node) {
<span class="fc bfc" id="L219" title="All 2 branches covered.">            for (Token t : tokens) {</span>
<span class="fc" id="L220">                node = attachComment(t, node);</span>
<span class="fc" id="L221">            }</span>
<span class="fc" id="L222">            return node;</span>
        }

        public CssNode attachComment(Token t, CssNode node) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (t.specialToken == null) {</span>
<span class="fc" id="L227">                return node;</span>
            }
<span class="fc" id="L229">            Token special = t.specialToken;</span>
            // Walking back the special token chain until we reach the first special token
            // which is after the previous regular (non-comment) token.
<span class="fc bfc" id="L232" title="All 2 branches covered.">            while (special.specialToken != null) {</span>
<span class="fc" id="L233">                special = special.specialToken;</span>
            }
            // Visiting comments in their normal appearing order.
<span class="fc bfc" id="L236" title="All 2 branches covered.">            while (special != null) {</span>
<span class="fc" id="L237">                node.appendComment(new CssCommentNode(trim(special.image), getLocation(special)));</span>
<span class="fc" id="L238">                special = special.next;</span>
            }
<span class="fc" id="L240">            return node;</span>
        }

        public CssStringNode buildStringNode(CssStringNode.Type type,
                                             String image, SourceCodeLocation location, Token token) {
<span class="fc" id="L245">            Preconditions.checkNotNull(image, &quot;image should be non-null&quot;);</span>
<span class="fc" id="L246">            Preconditions.checkArgument(</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                    image.length() &gt; 1, &quot;the image argument must be quoted&quot;, image);</span>
<span class="fc" id="L248">            CssStringNode node = new CssStringNode(type, location);</span>
<span class="fc" id="L249">            attachComments(Lists.newArrayList(token), node);</span>
<span class="fc" id="L250">            return node;</span>
        }

        public CssHexColorNode buildHexColorNode(String image,
                                                 SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L255">            CssHexColorNode node = new CssHexColorNode(image, location);</span>
<span class="fc" id="L256">            attachComments(tokens, node);</span>
<span class="fc" id="L257">            return node;</span>
        }

        public CssRulesetNode buildRulesetNode(CssDeclarationBlockNode declarations,
                                               CssSelectorListNode selectors, SourceCodeLocation location,
                                               List&lt;Token&gt; tokens) {
<span class="fc" id="L263">            CssRulesetNode node = new CssRulesetNode(declarations);</span>
<span class="fc" id="L264">            node.setSelectors(selectors);</span>
<span class="fc" id="L265">            node.setSourceCodeLocation(location);</span>
<span class="fc" id="L266">            attachComments(tokens, node);</span>
<span class="fc" id="L267">            return node;</span>
        }

        public CssKeyframeRulesetNode buildKeyframeRulesetNode(CssDeclarationBlockNode declarations,
                                                               CssKeyListNode keys, List&lt;Token&gt; tokens) {
<span class="fc" id="L272">            CssKeyframeRulesetNode node = new CssKeyframeRulesetNode(declarations);</span>
<span class="fc" id="L273">            node.setKeys(keys);</span>
<span class="fc" id="L274">            attachComments(tokens, node);</span>
<span class="fc" id="L275">            return node;</span>
        }

        public CssKeyNode buildKeyNode(Token token, String value, SourceCodeLocation location) {
<span class="fc" id="L279">            CssKeyNode node = new CssKeyNode(value, location);</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            if (token != null) {</span>
<span class="fc" id="L281">                attachComment(token, node);</span>
            }
<span class="fc" id="L283">            return node;</span>
        }

        public CssClassSelectorNode buildClassSelectorNode(String name,
                                                           SourceCodeLocation location, CssClassSelectorNode.ComponentScoping scoping,
                                                           List&lt;Token&gt; tokens) {
<span class="fc" id="L289">            CssClassSelectorNode node = new CssClassSelectorNode(name, scoping, location);</span>
<span class="fc" id="L290">            attachComments(tokens, node);</span>
<span class="fc" id="L291">            return node;</span>
        }

        public CssIdSelectorNode buildIdSelectorNode(String id,
                                                     SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L296">            CssIdSelectorNode node = new CssIdSelectorNode(id, location);</span>
<span class="fc" id="L297">            attachComments(tokens, node);</span>
<span class="fc" id="L298">            return node;</span>
        }

        public CssPseudoClassNode buildPseudoClassNode(String name,
                                                       SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L303">            CssPseudoClassNode node = new CssPseudoClassNode(name, location);</span>
<span class="fc" id="L304">            attachComments(tokens, node);</span>
<span class="fc" id="L305">            return node;</span>
        }

        public CssPseudoClassNode buildPseudoClassNode(
                CssPseudoClassNode.FunctionType functionType, String name,
                String argument, SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L311">            CssPseudoClassNode node = new CssPseudoClassNode(functionType, name,</span>
                    argument, location);
<span class="fc" id="L313">            attachComments(tokens, node);</span>
<span class="fc" id="L314">            return node;</span>
        }

        public CssPseudoClassNode buildPseudoClassNode(String name,
                                                       CssSelectorNode notSelector, SourceCodeLocation location,
                                                       List&lt;Token&gt; tokens) {
<span class="fc" id="L320">            CssPseudoClassNode node = new CssPseudoClassNode(name, notSelector,</span>
                    location);
<span class="fc" id="L322">            attachComments(tokens, node);</span>
<span class="fc" id="L323">            return node;</span>
        }

        public CssPseudoElementNode buildPseudoElementNode(String name,
                                                           SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L328">            CssPseudoElementNode node = new CssPseudoElementNode(name, location);</span>
<span class="fc" id="L329">            attachComments(tokens, node);</span>
<span class="fc" id="L330">            return node;</span>
        }

        public CssAttributeSelectorNode buildAttributeSelectorNode(
                CssAttributeSelectorNode.MatchType matchType, String attribute,
                CssValueNode value, SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L336">            CssAttributeSelectorNode node = new CssAttributeSelectorNode(matchType,</span>
                    attribute, value, location);
<span class="fc" id="L338">            attachComments(tokens, node);</span>
<span class="fc" id="L339">            return node;</span>
        }

        public CssSelectorNode buildSelectorNode(Token token, SourceCodeLocation location,
                                                 CssRefinerListNode refiners) {
<span class="fc" id="L344">            String name = &quot;&quot;;</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            if (token != null) {</span>
<span class="fc" id="L346">                name = token.image;</span>
            }
<span class="fc" id="L348">            CssSelectorNode node = new CssSelectorNode(name, location);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (token != null) {</span>
<span class="fc" id="L350">                attachComment(token, node);</span>
            }
<span class="fc" id="L352">            node.setRefiners(refiners);</span>
<span class="fc" id="L353">            return node;</span>
        }

        public CssCombinatorNode buildCombinatorNode(CssCombinatorNode.Combinator combinator,
                                                     SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L358">            CssCombinatorNode node = new CssCombinatorNode(combinator, location);</span>
<span class="fc" id="L359">            attachComments(tokens, node);</span>
<span class="fc" id="L360">            return node;</span>
        }

        public CssDeclarationNode buildDeclarationNode(CssPropertyNode property,
                                                       CssPropertyValueNode value, List&lt;Token&gt; tokens) {
            try {
<span class="fc" id="L366">                CssDeclarationNode node =</span>
                        new CssDeclarationNode(
                                property,
                                value,
<span class="fc" id="L370">                                mergeLocations(property.getSourceCodeLocation(), value.getSourceCodeLocation()));</span>
<span class="fc" id="L371">                attachComments(tokens, node);</span>
<span class="fc" id="L372">                return node;</span>
<span class="nc" id="L373">            } catch (NullPointerException e) {</span>
<span class="nc" id="L374">                StringBuilder valueValue = new StringBuilder();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                for (CssValueNode n : value.getChildren()) {</span>
<span class="nc" id="L376">                    valueValue.append(n.getValue());</span>
<span class="nc" id="L377">                    valueValue.append(&quot;&lt;&quot;);</span>
<span class="nc" id="L378">                    valueValue.append(n.getSourceCodeLocation());</span>
<span class="nc" id="L379">                    valueValue.append(&quot;&gt; &quot;);</span>
<span class="nc" id="L380">                }</span>
<span class="nc" id="L381">                throw new RuntimeException(&quot;property: &quot; + property.toString() + &quot;, &quot; + valueValue, e);</span>
            }
        }

        public CssCompositeValueNode buildCompositeValueNode(List&lt;CssValueNode&gt; list,
                                                             CssCompositeValueNode.Operator op, SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L387">            CssCompositeValueNode node = new CssCompositeValueNode(list, op, location);</span>
<span class="fc" id="L388">            attachComments(tokens, node);</span>
<span class="fc" id="L389">            return node;</span>
        }


        public CssBooleanExpressionNode buildBoolExpressionNode(CssBooleanExpressionNode.Type type,
                                                                String value, CssBooleanExpressionNode left, CssBooleanExpressionNode right,
                                                                SourceCodeLocation loc, List&lt;Token&gt; tokens) {
<span class="fc" id="L396">            CssBooleanExpressionNode node = new CssBooleanExpressionNode(type, value, left, right, loc);</span>
<span class="fc" id="L397">            attachComments(tokens, node);</span>
<span class="fc" id="L398">            return node;</span>
        }

        public CssLiteralNode buildLiteralNode(String value, SourceCodeLocation location,
                                               List&lt;Token&gt; tokens) {
<span class="fc" id="L403">            CssLiteralNode node = new CssLiteralNode(value, location);</span>
<span class="fc" id="L404">            attachComments(tokens, node);</span>
<span class="fc" id="L405">            return node;</span>
        }

        public CssUnicodeRangeNode buildUnicodeRangeNode(String value, SourceCodeLocation location,
                                                         List&lt;Token&gt; tokens) {
<span class="fc" id="L410">            CssUnicodeRangeNode node = new CssUnicodeRangeNode(value, location);</span>
<span class="fc" id="L411">            attachComments(tokens, node);</span>
<span class="fc" id="L412">            return node;</span>
        }

        public CssNumericNode buildNumericNode(String num, String unit, SourceCodeLocation location,
                                               List&lt;Token&gt; tokens) {
<span class="fc" id="L417">            CssNumericNode node = new CssNumericNode(num, unit, location);</span>
<span class="fc" id="L418">            attachComments(tokens, node);</span>
<span class="fc" id="L419">            return node;</span>
        }

        public CssLiteralNode buildLoopVariableNode(String value, SourceCodeLocation location,
                                                    List&lt;Token&gt; tokens) {
<span class="fc" id="L424">            CssLoopVariableNode node = new CssLoopVariableNode(value, location);</span>
<span class="fc" id="L425">            attachComments(tokens, node);</span>
<span class="fc" id="L426">            return node;</span>
        }

        public CssFunctionNode buildFunctionNode(String name, SourceCodeLocation location,
                                                 CssFunctionArgumentsNode args, List&lt;Token&gt; tokens) {
<span class="fc" id="L431">            CssFunctionNode.Function functionType = CssFunctionNode.Function.byName(name);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">            if (functionType == null) {</span>
<span class="fc" id="L433">                functionType = CssFunctionNode.Function.CUSTOM;</span>
            }
<span class="fc bfc" id="L435" title="All 2 branches covered.">            CssFunctionNode functionNode = (functionType != CssFunctionNode.Function.CUSTOM) ?</span>
<span class="fc" id="L436">                    new CssFunctionNode(functionType, location) :</span>
<span class="fc" id="L437">                    new CssCustomFunctionNode(name, location);</span>
<span class="fc" id="L438">            functionNode.setArguments(args);</span>
<span class="fc" id="L439">            attachComments(tokens, functionNode);</span>
<span class="fc" id="L440">            return functionNode;</span>
        }

        public CssPriorityNode buildPriorityNode(SourceCodeLocation location, List&lt;Token&gt; tokens) {
<span class="fc" id="L444">            CssPriorityNode node = new CssPriorityNode(CssPriorityNode.PriorityType.IMPORTANT, location);</span>
<span class="fc" id="L445">            attachComments(tokens, node);</span>
<span class="fc" id="L446">            return node;</span>
        }

        public CssUnknownAtRuleNode buildUnknownAtRuleNode(CssLiteralNode name,
                                                           CssAbstractBlockNode block, SourceCodeLocation location,
                                                           List&lt;CssValueNode&gt; parameters, List&lt;Token&gt; tokens) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">            boolean hasBlock = (block != null);</span>
<span class="fc" id="L453">            CssUnknownAtRuleNode at = new CssUnknownAtRuleNode(name, hasBlock);</span>
<span class="fc" id="L454">            at.setSourceCodeLocation(location);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            if (hasBlock) {</span>
<span class="fc" id="L456">                at.setBlock(block);</span>
            }
<span class="fc" id="L458">            at.setParameters(parameters);</span>
<span class="fc" id="L459">            attachComments(tokens, at);</span>
<span class="fc" id="L460">            return at;</span>
        }

        public CssKeyframesNode buildWebkitKeyframesNode(CssLiteralNode name,
                                                         CssBlockNode block, SourceCodeLocation location,
                                                         List&lt;CssValueNode&gt; parameters, List&lt;Token&gt; tokens) {
<span class="fc" id="L466">            CssKeyframesNode at = new CssKeyframesNode(name);</span>
<span class="fc" id="L467">            at.setSourceCodeLocation(location);</span>
<span class="fc" id="L468">            at.setBlock(block);</span>
<span class="fc" id="L469">            at.setParameters(parameters);</span>
<span class="fc" id="L470">            attachComments(tokens, at);</span>
<span class="fc" id="L471">            return at;</span>
        }
    }

    private void initialize(CssBlockNode globalBlock, SourceCode sourceCode,
                            boolean errorHandling) {
<span class="fc" id="L477">        this.enableErrorRecovery = errorHandling;</span>
<span class="fc" id="L478">        this.sourceCode = sourceCode;</span>
<span class="fc" id="L479">        this.globalBlock = globalBlock;</span>
<span class="fc" id="L480">        this.handledErrors.clear();</span>
<span class="fc" id="L481">        StringCharStream charStream =</span>
<span class="fc" id="L482">                new StringCharStream(sourceCode.getFileContents());</span>
<span class="fc" id="L483">        this.charStream = charStream;</span>
<span class="fc" id="L484">        this.ReInit(charStream);</span>
<span class="fc" id="L485">    }</span>

    private void clearState() {
<span class="fc" id="L488">        this.sourceCode = null;</span>
<span class="fc" id="L489">        this.globalBlock = null;</span>
<span class="fc" id="L490">        this.handledErrors.clear();</span>
<span class="fc" id="L491">        this.charStream = null;</span>
<span class="fc" id="L492">    }</span>

// The rest of the file contains the production rules of the grammar and to
// increase readability every rule also has a comment with the rule it
// implements in Extended Backusâ€“Naur Form (EBNF) that follows this syntax:
// nameOfRule
//   : X
//   ;
// where X is the actual production consisting of non terminals and terminals.
// Terminals that exactly represent some characters are not written with their
// name but the characters are written instead, e.g. '(' instead of LEFTROUND,
// but IDENTIFIER stays the same.

    // string
//   : DOUBLEQUOTEDSTRING | SINGLEQUOTEDSTRING
//   ;
    public final CssStringNode string() throws ParseException {
        Token t;
        CssStringNode.Type type;
        SourceCodeLocation beginLocation;
<span class="fc" id="L512">        beginLocation = this.getLocation(token.next);</span>
<span class="pc bpc" id="L513" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case DOUBLE_QUOTED_STRING: {
<span class="fc" id="L515">                t = jjConsumeToken(DOUBLE_QUOTED_STRING);</span>
<span class="fc" id="L516">                type = CssStringNode.Type.DOUBLE_QUOTED_STRING;</span>
<span class="fc" id="L517">                break;</span>
            }
            case SINGLE_QUOTED_STRING: {
<span class="fc" id="L520">                t = jjConsumeToken(SINGLE_QUOTED_STRING);</span>
<span class="fc" id="L521">                type = CssStringNode.Type.SINGLE_QUOTED_STRING;</span>
<span class="fc" id="L522">                break;</span>
            }
            default:
<span class="nc" id="L525">                jjLa1[0] = jjGen;</span>
<span class="nc" id="L526">                jjConsumeToken(-1);</span>
<span class="nc" id="L527">                throw new ParseException();</span>
        }
<span class="fc" id="L529">        SourceCodeLocation endLocation = this.getLocation();</span>
        {
<span class="fc" id="L531">            return nodeBuilder.buildStringNode(</span>
<span class="fc" id="L532">                    type, t.image, this.mergeLocations(beginLocation, endLocation), t);</span>
        }
    }

    // ruleset
//   : selectorList '{' styleDeclarations '}'
//   ;
    public final CssRulesetNode ruleSet() throws ParseException {
        CssSelectorListNode selectors;
        CssDeclarationBlockNode declarations;
        Token t;
<span class="fc" id="L543">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        try {
            try {
<span class="fc" id="L546">                selectors = selectorList();</span>
<span class="fc" id="L547">                t = jjConsumeToken(LEFTBRACE);</span>
<span class="fc" id="L548">                tokens.add(t);</span>
<span class="fc" id="L549">            } catch (ParseException e) {</span>
<span class="pc bpc" id="L550" title="1 of 4 branches missed.">                if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L551">                    throw e;</span>
                }
<span class="fc" id="L553">                skipComponentValuesToAfter(LEFTBRACE);</span>
                {
<span class="fc" id="L555">                    throw e;</span>
                }
<span class="fc" id="L557">            }</span>
<span class="fc" id="L558">            declarations = styleDeclaration();</span>
<span class="fc" id="L559">            t = jjConsumeToken(RIGHTBRACE);</span>
<span class="fc" id="L560">            tokens.add(t);</span>
<span class="fc" id="L561">            CssRulesetNode ruleSet = nodeBuilder.buildRulesetNode(declarations,</span>
<span class="fc" id="L562">                    selectors, mergeLocations(selectors.getSourceCodeLocation(), getLocation()), tokens);</span>
            {
<span class="fc" id="L564">                return ruleSet;</span>
            }
<span class="fc" id="L566">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L567" title="1 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L568">                throw e;</span>
            }
<span class="fc" id="L570">            skipComponentValuesToAfter(RIGHTBRACE);</span>
            {
<span class="fc" id="L572">                throw e;</span>
            }
        }
    }

    // selectorList
//   : selector [ ',' S* selector ]*
//   ;
    public final CssSelectorListNode selectorList() throws ParseException {
<span class="fc" id="L581">        CssSelectorListNode list = new CssSelectorListNode();</span>
        CssSelectorNode selector;
        Token t;
<span class="fc" id="L584">        selector = selector();</span>
<span class="fc" id="L585">        list.addChildToBack(selector);</span>
        while (true) {
<span class="pc bpc" id="L587" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != COMMA) {</span>
<span class="fc" id="L588">                jjLa1[1] = jjGen;</span>
<span class="fc" id="L589">                break;</span>
            }
<span class="fc" id="L591">            t = jjConsumeToken(COMMA);</span>
<span class="fc" id="L592">            nodeBuilder.attachComment(t, selector);</span>
            while (true) {
<span class="pc bpc" id="L594" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L595">                    jjLa1[2] = jjGen;</span>
<span class="fc" id="L596">                    break;</span>
                }
<span class="fc" id="L598">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L600">            selector = selector();</span>
<span class="fc" id="L601">            list.addChildToBack(selector);</span>
        }
        {
<span class="fc" id="L604">            return list;</span>
        }
    }

    // selector
//   : simpleSelector [ combinator simpleSelector ]* S*
//   ;
    public final CssSelectorNode selector() throws ParseException {
        CssSelectorNode first;
        CssCombinatorNode c;
        CssSelectorNode next;
        CssSelectorNode prev;
        Token t;
<span class="fc" id="L617">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L618">        first = simpleSelector();</span>
<span class="fc" id="L619">        prev = first;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">        while (jj21(2)) {</span>
<span class="fc" id="L621">            c = combinator();</span>
<span class="fc" id="L622">            next = simpleSelector();</span>
<span class="fc" id="L623">            c.setSelector(next);</span>
<span class="fc" id="L624">            prev.setCombinator(c);</span>
<span class="fc" id="L625">            prev = next;</span>
        }
        while (true) {
<span class="fc bfc" id="L628" title="All 4 branches covered.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L629">                jjLa1[3] = jjGen;</span>
<span class="fc" id="L630">                break;</span>
            }
<span class="fc" id="L632">            t = jjConsumeToken(S);</span>
<span class="fc" id="L633">            tokens.add(t);</span>
        }
<span class="fc" id="L635">        nodeBuilder.attachComments(tokens, first);</span>
        {
<span class="fc" id="L637">            return first;</span>
        }
    }

    // class
//   : '.' IDENTIFIER
//   ;
    public final CssClassSelectorNode className() throws ParseException {
        Token t;
<span class="fc" id="L646">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L647">        CssClassSelectorNode.ComponentScoping scoping = CssClassSelectorNode.ComponentScoping.DEFAULT;</span>
<span class="fc" id="L648">        t = jjConsumeToken(DOT);</span>
<span class="fc" id="L649">        tokens.add(t);</span>
<span class="pc bpc" id="L650" title="1 of 4 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case PERCENT:
            case CARET: {
<span class="pc bpc" id="L653" title="2 of 5 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case PERCENT: {
<span class="fc" id="L655">                        jjConsumeToken(PERCENT);</span>
<span class="fc" id="L656">                        scoping = CssClassSelectorNode.ComponentScoping.FORCE_SCOPED;</span>
<span class="fc" id="L657">                        break;</span>
                    }
                    case CARET: {
<span class="fc" id="L660">                        jjConsumeToken(CARET);</span>
<span class="fc" id="L661">                        scoping = CssClassSelectorNode.ComponentScoping.FORCE_UNSCOPED;</span>
<span class="fc" id="L662">                        break;</span>
                    }
                    default:
<span class="nc" id="L665">                        jjLa1[4] = jjGen;</span>
<span class="nc" id="L666">                        jjConsumeToken(-1);</span>
<span class="nc" id="L667">                        throw new ParseException();</span>
                }
                break;
            }
            default:
<span class="fc" id="L672">                jjLa1[5] = jjGen;</span>
        }
<span class="fc" id="L674">        t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L675">        tokens.add(t);</span>
        {
<span class="fc" id="L677">            return nodeBuilder.buildClassSelectorNode(t.image, this.getLocation(), scoping, tokens);</span>
        }
    }

    // id
//   : HASHNAME
//   ;
    public final CssRefinerNode id() throws ParseException {
        Token t;
<span class="fc" id="L686">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L687">        t = jjConsumeToken(HASH_NAME);</span>
<span class="fc" id="L688">        tokens.add(t);</span>
<span class="fc" id="L689">        String name = t.image.substring(1);</span>
        {
<span class="fc" id="L691">            return nodeBuilder.buildIdSelectorNode(name, this.getLocation(), tokens);</span>
        }
    }

    // pseudo
//   : ':' [ IDENT | [ ':' IDENT ] | [ 'not(' S* simpleSelector S* ')' ]
//         | [ 'lang(' S* IDENT S* ')' ] | [ FUNCTION S* nth S* ')' ] ]?
//   ;
    public final CssRefinerNode pseudo() throws ParseException {
        Token t;
        SourceCodeLocation beginLocation;
        SourceCodeLocation endLocation;
<span class="fc" id="L703">        String pseudo = null;</span>
        String argument;
<span class="fc" id="L705">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        CssSelectorNode notSelector;
<span class="fc" id="L707">        t = jjConsumeToken(COLON);</span>
<span class="fc" id="L708">        beginLocation = this.getLocation();</span>
<span class="fc" id="L709">        tokens.add(t);</span>
<span class="pc bpc" id="L710" title="2 of 4 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case COLON:
            case IDENTIFIER:
            case NOTFUNCTION:
            case LANGFUNCTION:
            case FUNCTION: {
<span class="pc bpc" id="L716" title="2 of 8 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case IDENTIFIER: {
<span class="fc" id="L718">                        t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L719">                        pseudo = t.image;</span>
<span class="fc" id="L720">                        tokens.add(t);</span>
<span class="fc" id="L721">                        break;</span>
                    }
                    case COLON: {
                        // ::identifier (pseudo-element)
<span class="fc" id="L725">                        t = jjConsumeToken(COLON);</span>
<span class="fc" id="L726">                        tokens.add(t);</span>
<span class="fc" id="L727">                        t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L728">                        pseudo = t.image;</span>
<span class="fc" id="L729">                        tokens.add(t);</span>
<span class="fc" id="L730">                        endLocation = this.getLocation();</span>
                        {
<span class="fc" id="L732">                            return nodeBuilder.buildPseudoElementNode(pseudo,</span>
<span class="fc" id="L733">                                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
                        }
                    }
                    case NOTFUNCTION: {
                        // :not( simpleSelector )
<span class="fc" id="L738">                        t = jjConsumeToken(NOTFUNCTION);</span>
                        while (true) {
<span class="pc bpc" id="L740" title="1 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L741">                                jjLa1[6] = jjGen;</span>
<span class="fc" id="L742">                                break;</span>
                            }
<span class="fc" id="L744">                            jjConsumeToken(S);</span>
                        }
<span class="fc" id="L746">                        beginLocation = this.getLocation();</span>
<span class="fc" id="L747">                        pseudo = t.image;</span>
<span class="fc" id="L748">                        tokens.add(t);</span>
<span class="fc" id="L749">                        notSelector = simpleSelector();</span>
                        while (true) {
<span class="fc bfc" id="L751" title="All 4 branches covered.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L752">                                jjLa1[7] = jjGen;</span>
<span class="fc" id="L753">                                break;</span>
                            }
<span class="fc" id="L755">                            jjConsumeToken(S);</span>
                        }
<span class="fc" id="L757">                        t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L758">                        tokens.add(t);</span>
<span class="fc" id="L759">                        endLocation = this.getLocation();</span>
                        {
<span class="fc" id="L761">                            return nodeBuilder.buildPseudoClassNode(pseudo, notSelector,</span>
<span class="fc" id="L762">                                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
                        }
                    }
                    case LANGFUNCTION: {
                        // :lang( &lt;IDENTIFIER&gt; )
<span class="fc" id="L767">                        t = jjConsumeToken(LANGFUNCTION);</span>
                        while (true) {
<span class="pc bpc" id="L769" title="2 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L770">                                jjLa1[8] = jjGen;</span>
<span class="fc" id="L771">                                break;</span>
                            }
<span class="nc" id="L773">                            jjConsumeToken(S);</span>
                        }
<span class="fc" id="L775">                        beginLocation = this.getLocation();</span>
<span class="fc" id="L776">                        pseudo = t.image;</span>
<span class="fc" id="L777">                        tokens.add(t);</span>
<span class="fc" id="L778">                        t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L779">                        argument = t.image;</span>
<span class="fc" id="L780">                        tokens.add(t);</span>
                        while (true) {
<span class="pc bpc" id="L782" title="2 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L783">                                jjLa1[9] = jjGen;</span>
<span class="fc" id="L784">                                break;</span>
                            }
<span class="nc" id="L786">                            jjConsumeToken(S);</span>
                        }
<span class="fc" id="L788">                        t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L789">                        tokens.add(t);</span>
<span class="fc" id="L790">                        endLocation = this.getLocation();</span>
                        {
<span class="fc" id="L792">                            return nodeBuilder.buildPseudoClassNode(</span>
                                    CssPseudoClassNode.FunctionType.LANG, pseudo, argument,
<span class="fc" id="L794">                                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
                        }
                    }
                    case FUNCTION: {
                        // :nth-function( nth )
<span class="fc" id="L799">                        t = jjConsumeToken(FUNCTION);</span>
                        while (true) {
<span class="pc bpc" id="L801" title="1 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L802">                                jjLa1[10] = jjGen;</span>
<span class="fc" id="L803">                                break;</span>
                            }
<span class="fc" id="L805">                            jjConsumeToken(S);</span>
                        }
<span class="fc" id="L807">                        beginLocation = this.getLocation();</span>
<span class="fc" id="L808">                        pseudo = t.image;</span>
<span class="fc" id="L809">                        tokens.add(t);</span>
<span class="fc" id="L810">                        argument = nth();</span>
                        while (true) {
<span class="pc bpc" id="L812" title="2 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L813">                                jjLa1[11] = jjGen;</span>
<span class="fc" id="L814">                                break;</span>
                            }
<span class="nc" id="L816">                            jjConsumeToken(S);</span>
                        }
<span class="fc" id="L818">                        t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L819">                        tokens.add(t);</span>
<span class="fc" id="L820">                        endLocation = this.getLocation();</span>
                        {
<span class="fc" id="L822">                            return nodeBuilder.buildPseudoClassNode(</span>
                                    CssPseudoClassNode.FunctionType.NTH, pseudo, argument,
<span class="fc" id="L824">                                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
                        }
                    }
                    default:
<span class="nc" id="L828">                        jjLa1[12] = jjGen;</span>
<span class="nc" id="L829">                        jjConsumeToken(-1);</span>
<span class="nc" id="L830">                        throw new ParseException();</span>
                }
                break;
            }
            default:
<span class="nc" id="L835">                jjLa1[13] = jjGen;</span>
        }
// non-function pseudo-class
<span class="fc" id="L838">        endLocation = this.getLocation();</span>
        {
<span class="fc" id="L840">            return nodeBuilder.buildPseudoClassNode(pseudo,</span>
<span class="fc" id="L841">                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
        }
    }

    // nth
//   : [ [ [ S* '+' ] | '-' | NUMBER | IDENTIFIER | FORVARIABLE ] S* ]+
//   ;
    public final String nth() throws ParseException {
        Token t;
<span class="fc" id="L850">        StringBuilder argument = new StringBuilder();</span>
        while (true) {
<span class="pc bpc" id="L852" title="1 of 9 branches missed.">            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                case WPLUS: {
<span class="fc" id="L854">                    t = jjConsumeToken(WPLUS);</span>
<span class="fc" id="L855">                    argument.append(t.image);</span>
<span class="fc" id="L856">                    break;</span>
                }
                case MINUS: {
<span class="fc" id="L859">                    t = jjConsumeToken(MINUS);</span>
<span class="fc" id="L860">                    argument.append(t.image);</span>
<span class="fc" id="L861">                    break;</span>
                }
                case WMINUSW: {
<span class="fc" id="L864">                    t = jjConsumeToken(WMINUSW);</span>
<span class="fc" id="L865">                    argument.append(trim(t.image));</span>
<span class="fc" id="L866">                    break;</span>
                }
                case NUMBER: {
<span class="fc" id="L869">                    t = jjConsumeToken(NUMBER);</span>
<span class="fc" id="L870">                    argument.append(t.image);</span>
<span class="fc" id="L871">                    break;</span>
                }
                case IDENTIFIER: {
<span class="fc" id="L874">                    t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L875">                    argument.append(t.image);</span>
<span class="fc" id="L876">                    break;</span>
                }
                case FOR_VARIABLE: {
<span class="fc" id="L879">                    t = jjConsumeToken(FOR_VARIABLE);</span>
<span class="fc" id="L880">                    argument.append(t.image);</span>
<span class="fc" id="L881">                    break;</span>
                }
                default:
<span class="fc" id="L884">                    jjLa1[14] = jjGen;</span>
<span class="nc" id="L885">                    jjConsumeToken(-1);</span>
<span class="nc" id="L886">                    throw new ParseException();</span>
            }
            while (true) {
<span class="pc bpc" id="L889" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L890">                    jjLa1[15] = jjGen;</span>
<span class="fc" id="L891">                    break;</span>
                }
<span class="fc" id="L893">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">            int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="pc bpc" id="L896" title="1 of 12 branches missed.">            if (i != MINUS &amp;&amp; i != WMINUSW &amp;&amp; i != WPLUS &amp;&amp; i != NUMBER &amp;&amp; i != FOR_VARIABLE &amp;&amp; i != IDENTIFIER) {</span>
<span class="fc" id="L897">                jjLa1[16] = jjGen;</span>
<span class="fc" id="L898">                break;</span>
            }
<span class="fc" id="L900">        }</span>
        {
<span class="fc" id="L902">            return argument.toString();</span>
        }
    }

    // attribute
//   : '[' S* IDENT S* [
//        [ '=' | '~=' | '^=' | '$=' | '*=' | '|=' ] S* [ IDENTIFIER | STRING ]
//        S*
//      ]? ']'
//   ;
    public final CssAttributeSelectorNode attribute() throws ParseException {
        Token t;
<span class="fc" id="L914">        CssStringNode stringNode = null;</span>
<span class="fc" id="L915">        CssLiteralNode idNode = null;</span>
        String attribute;
<span class="fc" id="L917">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        SourceCodeLocation beginLocation;
<span class="fc" id="L919">        CssAttributeSelectorNode.MatchType matchType =</span>
                CssAttributeSelectorNode.MatchType.ANY;
<span class="fc" id="L921">        t = jjConsumeToken(LEFTSQUARE);</span>
<span class="fc" id="L922">        beginLocation = this.getLocation();</span>
<span class="fc" id="L923">        tokens.add(t);</span>
        try {
            while (true) {
<span class="pc bpc" id="L926" title="2 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L927">                    jjLa1[17] = jjGen;</span>
<span class="fc" id="L928">                    break;</span>
                }
<span class="nc" id="L930">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L932">            t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L933">            attribute = t.image;</span>
<span class="fc" id="L934">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L936" title="2 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L937">                    jjLa1[18] = jjGen;</span>
<span class="fc" id="L938">                    break;</span>
                }
<span class="nc" id="L940">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L942" title="1 of 4 branches missed.">            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                case EQUALS:
                case TILDE_EQUALS:
                case CARET_EQUALS:
                case DOLLAR_EQUALS:
                case ASTERISK_EQUALS:
                case PIPE_EQUALS: {
<span class="pc bpc" id="L949" title="2 of 9 branches missed.">                    switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                        case EQUALS: {
<span class="fc" id="L951">                            t = jjConsumeToken(EQUALS);</span>
<span class="fc" id="L952">                            tokens.add(t);</span>
<span class="fc" id="L953">                            matchType = CssAttributeSelectorNode.MatchType.EXACT;</span>
<span class="fc" id="L954">                            break;</span>
                        }
                        case TILDE_EQUALS: {
<span class="fc" id="L957">                            t = jjConsumeToken(TILDE_EQUALS);</span>
<span class="fc" id="L958">                            tokens.add(t);</span>
<span class="fc" id="L959">                            matchType = CssAttributeSelectorNode.MatchType.ONE_WORD;</span>
<span class="fc" id="L960">                            break;</span>
                        }
                        case CARET_EQUALS: {
<span class="fc" id="L963">                            t = jjConsumeToken(CARET_EQUALS);</span>
<span class="fc" id="L964">                            tokens.add(t);</span>
<span class="fc" id="L965">                            matchType = CssAttributeSelectorNode.MatchType.PREFIX;</span>
<span class="fc" id="L966">                            break;</span>
                        }
                        case DOLLAR_EQUALS: {
<span class="fc" id="L969">                            t = jjConsumeToken(DOLLAR_EQUALS);</span>
<span class="fc" id="L970">                            tokens.add(t);</span>
<span class="fc" id="L971">                            matchType = CssAttributeSelectorNode.MatchType.SUFFIX;</span>
<span class="fc" id="L972">                            break;</span>
                        }
                        case ASTERISK_EQUALS: {
<span class="fc" id="L975">                            t = jjConsumeToken(ASTERISK_EQUALS);</span>
<span class="fc" id="L976">                            tokens.add(t);</span>
<span class="fc" id="L977">                            matchType = CssAttributeSelectorNode.MatchType.CONTAINS;</span>
<span class="fc" id="L978">                            break;</span>
                        }
                        case PIPE_EQUALS: {
<span class="fc" id="L981">                            t = jjConsumeToken(PIPE_EQUALS);</span>
<span class="fc" id="L982">                            tokens.add(t);</span>
<span class="fc" id="L983">                            matchType = CssAttributeSelectorNode.MatchType.EXACT_OR_DASH;</span>
<span class="fc" id="L984">                            break;</span>
                        }
                        default:
<span class="nc" id="L987">                            jjLa1[19] = jjGen;</span>
<span class="nc" id="L988">                            jjConsumeToken(-1);</span>
<span class="nc" id="L989">                            throw new ParseException();</span>
                    }
                    while (true) {
<span class="pc bpc" id="L992" title="2 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L993">                            jjLa1[20] = jjGen;</span>
<span class="fc" id="L994">                            break;</span>
                        }
<span class="nc" id="L996">                        jjConsumeToken(S);</span>
                    }
<span class="pc bpc" id="L998" title="1 of 5 branches missed.">                    switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                        case IDENTIFIER: {
<span class="fc" id="L1000">                            t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1001">                            idNode = new CssLiteralNode(t.image, this.getLocation());</span>
<span class="fc" id="L1002">                            tokens.add(t);</span>
<span class="fc" id="L1003">                            break;</span>
                        }
                        case DOUBLE_QUOTED_STRING:
                        case SINGLE_QUOTED_STRING: {
<span class="fc" id="L1007">                            stringNode = string();</span>
<span class="fc" id="L1008">                            break;</span>
                        }
                        default:
<span class="fc" id="L1011">                            jjLa1[21] = jjGen;</span>
<span class="nc" id="L1012">                            jjConsumeToken(-1);</span>
<span class="nc" id="L1013">                            throw new ParseException();</span>
                    }
                    while (true) {
<span class="pc bpc" id="L1016" title="2 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1017">                            jjLa1[22] = jjGen;</span>
<span class="fc" id="L1018">                            break;</span>
                        }
<span class="nc" id="L1020">                        jjConsumeToken(S);</span>
                    }
                    break;
                }
                default:
<span class="fc" id="L1025">                    jjLa1[23] = jjGen;</span>
            }
<span class="fc" id="L1027">            t = jjConsumeToken(RIGHTSQUARE);</span>
<span class="fc" id="L1028">            tokens.add(t);</span>
<span class="fc" id="L1029">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L1030" title="2 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L1031">                throw e;</span>
            }
<span class="fc" id="L1033">            skipComponentValuesToAfter(RIGHTSQUARE);</span>
            {
<span class="fc" id="L1035">                throw e;</span>
            }
<span class="fc" id="L1037">        }</span>
<span class="fc" id="L1038">        SourceCodeLocation endLocation = this.getLocation();</span>
        CssValueNode v;
<span class="fc bfc" id="L1040" title="All 2 branches covered.">        if (stringNode != null) {</span>
<span class="fc" id="L1041">            v = stringNode;</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">        } else if (idNode != null) {</span>
<span class="fc" id="L1043">            v = idNode;</span>
        } else {
<span class="fc" id="L1045">            v = new CssLiteralNode(&quot;&quot;);</span>
        }
        {
<span class="fc" id="L1048">            return nodeBuilder.buildAttributeSelectorNode(</span>
                    matchType, attribute, v,
<span class="fc" id="L1050">                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
        }
    }

    // simpleSelector
//   : [ elementName [ id | class | attribute | pseudo ]* ]
//     | [ id | class | attribute | pseudo ]+
//   ;
    public final CssSelectorNode simpleSelector() throws ParseException {
        CssRefinerNode n;
<span class="fc" id="L1060">        Token selectorName = null;</span>
<span class="fc" id="L1061">        CssRefinerListNode refiners = new CssRefinerListNode();</span>
        SourceCodeLocation beginLocation;
<span class="fc" id="L1063">        beginLocation = this.getLocation(token.next);</span>
<span class="pc bpc" id="L1064" title="1 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case ASTERISK:
            case IDENTIFIER: {
<span class="fc" id="L1067">                selectorName = elementName();</span>
                while (true) {
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">                    int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="fc bfc" id="L1070" title="All 8 branches covered.">                    if (i != COLON &amp;&amp; i != DOT &amp;&amp; i != LEFTSQUARE &amp;&amp; i != HASH_NAME) {</span>
<span class="fc" id="L1071">                        jjLa1[24] = jjGen;</span>
<span class="fc" id="L1072">                        break;</span>
                    }
<span class="pc bpc" id="L1074" title="2 of 7 branches missed.">                    switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                        case HASH_NAME: {
<span class="fc" id="L1076">                            n = id();</span>
<span class="fc" id="L1077">                            break;</span>
                        }
                        case DOT: {
<span class="fc" id="L1080">                            n = className();</span>
<span class="fc" id="L1081">                            break;</span>
                        }
                        case LEFTSQUARE: {
<span class="fc" id="L1084">                            n = attribute();</span>
<span class="fc" id="L1085">                            break;</span>
                        }
                        case COLON: {
<span class="fc" id="L1088">                            n = pseudo();</span>
<span class="fc" id="L1089">                            break;</span>
                        }
                        default:
<span class="nc" id="L1092">                            jjLa1[25] = jjGen;</span>
<span class="nc" id="L1093">                            jjConsumeToken(-1);</span>
<span class="nc" id="L1094">                            throw new ParseException();</span>
                    }
<span class="fc" id="L1096">                    refiners.addChildToBack(n);</span>
<span class="fc" id="L1097">                }</span>
                break;
            }
            case COLON:
            case DOT:
            case LEFTSQUARE:
            case HASH_NAME: {
                while (true) {
<span class="pc bpc" id="L1105" title="2 of 7 branches missed.">                    switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                        case HASH_NAME: {
<span class="fc" id="L1107">                            n = id();</span>
<span class="fc" id="L1108">                            break;</span>
                        }
                        case DOT: {
<span class="fc" id="L1111">                            n = className();</span>
<span class="fc" id="L1112">                            break;</span>
                        }
                        case LEFTSQUARE: {
<span class="fc" id="L1115">                            n = attribute();</span>
<span class="fc" id="L1116">                            break;</span>
                        }
                        case COLON: {
<span class="fc" id="L1119">                            n = pseudo();</span>
<span class="fc" id="L1120">                            break;</span>
                        }
                        default:
<span class="nc" id="L1123">                            jjLa1[26] = jjGen;</span>
<span class="nc" id="L1124">                            jjConsumeToken(-1);</span>
<span class="nc" id="L1125">                            throw new ParseException();</span>
                    }
<span class="fc" id="L1127">                    refiners.addChildToBack(n);</span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">                    int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="fc bfc" id="L1129" title="All 8 branches covered.">                    if (i != COLON &amp;&amp; i != DOT &amp;&amp; i != LEFTSQUARE &amp;&amp; i != HASH_NAME) {</span>
<span class="fc" id="L1130">                        jjLa1[27] = jjGen;</span>
<span class="fc" id="L1131">                        break;</span>
                    }
<span class="fc" id="L1133">                }</span>
                break;
            }
            default:
<span class="fc" id="L1137">                jjLa1[28] = jjGen;</span>
<span class="nc" id="L1138">                jjConsumeToken(-1);</span>
<span class="nc" id="L1139">                throw new ParseException();</span>
        }
<span class="fc" id="L1141">        SourceCodeLocation endLocation = this.getLocation();</span>
<span class="fc" id="L1142">        CssSelectorNode selectorNode = nodeBuilder.buildSelectorNode(selectorName,</span>
<span class="fc" id="L1143">                this.mergeLocations(beginLocation, endLocation), refiners);</span>
        {
<span class="fc" id="L1145">            return selectorNode;</span>
        }
    }

    // elementName
//   : IDENTIFIER | '*'
//   ;
    public final Token elementName() throws ParseException {
        Token t;
<span class="pc bpc" id="L1154" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case IDENTIFIER: {
<span class="fc" id="L1156">                t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1157">                break;</span>
            }
            case ASTERISK: {
<span class="fc" id="L1160">                t = jjConsumeToken(ASTERISK);</span>
<span class="fc" id="L1161">                break;</span>
            }
            default:
<span class="nc" id="L1164">                jjLa1[29] = jjGen;</span>
<span class="nc" id="L1165">                jjConsumeToken(-1);</span>
<span class="nc" id="L1166">                throw new ParseException();</span>
        }
        {
<span class="fc" id="L1169">            return t;</span>
        }
    }

    // combinator
//   : [ '+' S* ] | [ '&gt;' S* ] | [ '~' S* ] | [ WDEEP S*] | S+
//   ;
    public final CssCombinatorNode combinator() throws ParseException {
        Token t;
<span class="fc" id="L1178">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="pc bpc" id="L1179" title="2 of 8 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case WPLUS: {
<span class="fc" id="L1181">                t = jjConsumeToken(WPLUS);</span>
                while (true) {
<span class="pc bpc" id="L1183" title="1 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1184">                        jjLa1[30] = jjGen;</span>
<span class="fc" id="L1185">                        break;</span>
                    }
<span class="fc" id="L1187">                    jjConsumeToken(S);</span>
                }
<span class="fc" id="L1189">                tokens.add(t);</span>
                {
<span class="fc" id="L1191">                    return nodeBuilder.buildCombinatorNode(</span>
<span class="fc" id="L1192">                            CssCombinatorNode.Combinator.ADJACENT_SIBLING, this.getLocation(),</span>
                            tokens);
                }
            }
            case WGREATER: {
<span class="fc" id="L1197">                t = jjConsumeToken(WGREATER);</span>
                while (true) {
<span class="pc bpc" id="L1199" title="1 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1200">                        jjLa1[31] = jjGen;</span>
<span class="fc" id="L1201">                        break;</span>
                    }
<span class="fc" id="L1203">                    jjConsumeToken(S);</span>
                }
<span class="fc" id="L1205">                tokens.add(t);</span>
                {
<span class="fc" id="L1207">                    return nodeBuilder.buildCombinatorNode(</span>
<span class="fc" id="L1208">                            CssCombinatorNode.Combinator.CHILD, this.getLocation(), tokens);</span>
                }
            }
            case WTILDE: {
<span class="fc" id="L1212">                t = jjConsumeToken(WTILDE);</span>
                while (true) {
<span class="pc bpc" id="L1214" title="1 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1215">                        jjLa1[32] = jjGen;</span>
<span class="fc" id="L1216">                        break;</span>
                    }
<span class="fc" id="L1218">                    jjConsumeToken(S);</span>
                }
<span class="fc" id="L1220">                tokens.add(t);</span>
                {
<span class="fc" id="L1222">                    return nodeBuilder.buildCombinatorNode(</span>
<span class="fc" id="L1223">                            CssCombinatorNode.Combinator.GENERAL_SIBLING, this.getLocation(),</span>
                            tokens);
                }
            }
            case WDEEP: {
<span class="fc" id="L1228">                t = jjConsumeToken(WDEEP);</span>
                while (true) {
<span class="pc bpc" id="L1230" title="1 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1231">                        jjLa1[33] = jjGen;</span>
<span class="fc" id="L1232">                        break;</span>
                    }
<span class="fc" id="L1234">                    jjConsumeToken(S);</span>
                }
<span class="fc" id="L1236">                tokens.add(t);</span>
                {
<span class="fc" id="L1238">                    return nodeBuilder.buildCombinatorNode(</span>
<span class="fc" id="L1239">                            CssCombinatorNode.Combinator.DEEP, this.getLocation(), tokens);</span>
                }
            }
            case S: {
                while (true) {
<span class="fc" id="L1244">                    t = jjConsumeToken(S);</span>
<span class="fc" id="L1245">                    tokens.add(t);</span>
<span class="pc bpc" id="L1246" title="2 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1247">                        jjLa1[34] = jjGen;</span>
<span class="fc" id="L1248">                        break;</span>
                    }
                }
                {
<span class="fc" id="L1252">                    return nodeBuilder.buildCombinatorNode(</span>
<span class="fc" id="L1253">                            CssCombinatorNode.Combinator.DESCENDANT, this.getLocation(), tokens);</span>
                }
            }
            default:
<span class="nc" id="L1257">                jjLa1[35] = jjGen;</span>
<span class="nc" id="L1258">                jjConsumeToken(-1);</span>
<span class="nc" id="L1259">                throw new ParseException();</span>
        }
    }

    // styleDeclaration
//   : S* standardDeclaration? S*
//     [
//        [ innerAtRule S* standardDeclaration ]
//      | ';' S* standardDeclaration
//     ]*
//   ;
// This production rule returns a block that contains a list of declarations and
// @-rules. The declarations and rules must be separated by semicolons. If the
// last thing in the block is a declaration, the trailing semicolon is optional.
// Note that the trailing semicolon is NOT optional if the last thing is an
// @-rule. This is a limitation of the current grammar.
    public final CssDeclarationBlockNode styleDeclaration() throws ParseException {
<span class="fc" id="L1276">        CssDeclarationBlockNode block = new CssDeclarationBlockNode();</span>
        CssNode decl;
        try {
            while (true) {
<span class="fc bfc" id="L1280" title="All 4 branches covered.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1281">                    jjLa1[36] = jjGen;</span>
<span class="fc" id="L1282">                    break;</span>
                }
<span class="fc" id="L1284">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L1286" title="1 of 4 branches missed.">            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                case ASTERISK:
                case IDENTIFIER:
                case CUSTOM_PROPERTY_NAME: {
<span class="fc" id="L1290">                    decl = declaration();</span>
<span class="fc" id="L1291">                    block.addChildToBack(decl);</span>
<span class="fc" id="L1292">                    break;</span>
                }
                default:
<span class="fc" id="L1295">                    jjLa1[37] = jjGen;</span>
            }
            while (true) {
<span class="pc bpc" id="L1298" title="2 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1299">                    jjLa1[38] = jjGen;</span>
<span class="fc" id="L1300">                    break;</span>
                }
<span class="nc" id="L1302">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1304">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L1305" title="1 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L1306">                throw e;</span>
            }
<span class="fc" id="L1308">            handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));</span>
<span class="fc" id="L1309">        }</span>
        while (true) {
<span class="fc bfc" id="L1311" title="All 2 branches covered.">            int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="fc bfc" id="L1312" title="All 4 branches covered.">            if (i != SEMICOLON &amp;&amp; i != ATKEYWORD) {</span>
<span class="fc" id="L1313">                jjLa1[39] = jjGen;</span>
<span class="fc" id="L1314">                break;</span>
            }
            try {
<span class="pc bpc" id="L1317" title="2 of 5 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case ATKEYWORD: {
                        try {
<span class="fc" id="L1320">                            decl = innerAtRule();</span>
<span class="fc" id="L1321">                            block.addChildToBack(decl);</span>
<span class="fc" id="L1322">                        } catch (ParseException e) {</span>
<span class="pc bpc" id="L1323" title="2 of 4 branches missed.">                            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L1324">                                throw e;</span>
                            }
<span class="fc" id="L1326">                            handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));</span>
<span class="fc" id="L1327">                        }</span>
                        while (true) {
<span class="pc bpc" id="L1329" title="1 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1330">                                jjLa1[40] = jjGen;</span>
<span class="fc" id="L1331">                                break;</span>
                            }
<span class="fc" id="L1333">                            jjConsumeToken(S);</span>
                        }
<span class="pc bpc" id="L1335" title="1 of 4 branches missed.">                        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                            case ASTERISK:
                            case IDENTIFIER:
                            case CUSTOM_PROPERTY_NAME: {
<span class="fc" id="L1339">                                decl = declaration();</span>
<span class="fc" id="L1340">                                block.addChildToBack(decl);</span>
<span class="fc" id="L1341">                                break;</span>
                            }
                            default:
<span class="fc" id="L1344">                                jjLa1[41] = jjGen;</span>
                        }
<span class="fc" id="L1346">                        break;</span>
                    }
                    case SEMICOLON: {
<span class="fc" id="L1349">                        jjConsumeToken(SEMICOLON);</span>
                        while (true) {
<span class="pc bpc" id="L1351" title="1 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1352">                                jjLa1[42] = jjGen;</span>
<span class="fc" id="L1353">                                break;</span>
                            }
<span class="fc" id="L1355">                            jjConsumeToken(S);</span>
                        }
<span class="pc bpc" id="L1357" title="1 of 4 branches missed.">                        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                            case ASTERISK:
                            case IDENTIFIER:
                            case CUSTOM_PROPERTY_NAME: {
<span class="fc" id="L1361">                                decl = declaration();</span>
<span class="fc" id="L1362">                                block.addChildToBack(decl);</span>
<span class="fc" id="L1363">                                break;</span>
                            }
                            default:
<span class="fc" id="L1366">                                jjLa1[43] = jjGen;</span>
                        }
<span class="fc" id="L1368">                        break;</span>
                    }
                    default:
<span class="nc" id="L1371">                        jjLa1[44] = jjGen;</span>
<span class="nc" id="L1372">                        jjConsumeToken(-1);</span>
<span class="nc" id="L1373">                        throw new ParseException();</span>
                }
<span class="nc" id="L1375">            } catch (ParseException e) {</span>
<span class="nc bnc" id="L1376" title="All 4 branches missed.">                if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L1377">                    throw e;</span>
                }
<span class="nc" id="L1379">                handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));</span>
<span class="fc" id="L1380">            }</span>
<span class="fc" id="L1381">        }</span>
        {
<span class="fc" id="L1383">            return block;</span>
        }
    }

    public final CssNode declaration() throws ParseException {
        CssNode decl;
<span class="pc bpc" id="L1389" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case ASTERISK:
            case IDENTIFIER: {
<span class="fc" id="L1392">                decl = standardDeclaration();</span>
<span class="fc" id="L1393">                break;</span>
            }
            case CUSTOM_PROPERTY_NAME: {
<span class="fc" id="L1396">                decl = customDeclaration();</span>
<span class="fc" id="L1397">                break;</span>
            }
            default:
<span class="nc" id="L1400">                jjLa1[45] = jjGen;</span>
<span class="nc" id="L1401">                jjConsumeToken(-1);</span>
<span class="nc" id="L1402">                throw new ParseException();</span>
        }
        {
<span class="fc" id="L1405">            return decl;</span>
        }
    }

    // customDeclaration
//   : CUSTOMPROPERTYNAME S* ':' customDeclarationValue
//   ;
    public final CssDeclarationNode customDeclaration() throws ParseException {
        Token t;
        CssPropertyNode property;
        CssPropertyValueNode valueNode;
<span class="fc" id="L1416">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        try {
<span class="fc" id="L1418">            t = jjConsumeToken(CUSTOM_PROPERTY_NAME);</span>
<span class="fc" id="L1419">            property = new CssPropertyNode(t.image, this.getLocation());</span>
<span class="fc" id="L1420">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1422" title="2 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1423">                    jjLa1[46] = jjGen;</span>
<span class="fc" id="L1424">                    break;</span>
                }
<span class="nc" id="L1426">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1428">            t = jjConsumeToken(COLON);</span>
<span class="fc" id="L1429">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1431" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1432">                    jjLa1[47] = jjGen;</span>
<span class="fc" id="L1433">                    break;</span>
                }
<span class="fc" id="L1435">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1437">            valueNode = customDeclarationValue();</span>
            {
<span class="fc" id="L1439">                return nodeBuilder.buildDeclarationNode(property, valueNode, tokens);</span>
            }
<span class="fc" id="L1441">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L1442" title="3 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L1443">                throw e;</span>
            }
<span class="nc" id="L1445">            skipComponentValuesToBefore(RIGHTBRACE, SEMICOLON);</span>
            {
<span class="nc" id="L1447">                throw e;</span>
            }
        }
    }

    // For the time being, we have decided to be more restrictive in what we accept here. Instead of
// following spec, we have decided to parse CSS expressions only. At some point, this may be
// revisited.
//
// customDeclarationValue
//   : expr()
//   ;
    public final CssPropertyValueNode customDeclarationValue() throws ParseException {
        CssPropertyValueNode value;
<span class="fc" id="L1461">        value = expr();</span>
        {
<span class="fc" id="L1463">            return value;</span>
        }
    }

    // standardDeclaration
//   : '*'? IDENTIFIER S* ':' S* expr S* important?
//   ;
    public final CssDeclarationNode standardDeclaration() throws ParseException {
        Token t;
        CssPropertyNode property;
        CssPropertyValueNode valueNode;
<span class="fc" id="L1474">        CssPriorityNode priority = null;</span>
<span class="fc" id="L1475">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L1476">        String propertyName = &quot;&quot;;</span>
        try {
<span class="pc bpc" id="L1478" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) == ASTERISK) {</span>
<span class="fc" id="L1479">                t = jjConsumeToken(ASTERISK);</span>
<span class="fc" id="L1480">                tokens.add(t);</span>
<span class="fc" id="L1481">                propertyName = &quot;*&quot;;</span>
            } else {
<span class="fc" id="L1483">                jjLa1[48] = jjGen;</span>
            }
            // allows &quot;star hack&quot;
<span class="fc" id="L1486">            t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1487">            propertyName = propertyName + t.image;</span>
<span class="fc" id="L1488">            property = new CssPropertyNode(propertyName, this.getLocation());</span>
<span class="fc" id="L1489">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1491" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1492">                    jjLa1[49] = jjGen;</span>
<span class="fc" id="L1493">                    break;</span>
                }
<span class="fc" id="L1495">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1497">            t = jjConsumeToken(COLON);</span>
<span class="fc" id="L1498">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1500" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1501">                    jjLa1[50] = jjGen;</span>
<span class="fc" id="L1502">                    break;</span>
                }
<span class="fc" id="L1504">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1506">            valueNode = expr();</span>
            while (true) {
<span class="pc bpc" id="L1508" title="2 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1509">                    jjLa1[51] = jjGen;</span>
<span class="fc" id="L1510">                    break;</span>
                }
<span class="nc" id="L1512">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L1514" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) == IMPORTANT_SYM) {</span>
<span class="fc" id="L1515">                priority = important();</span>
            } else {
<span class="fc" id="L1517">                jjLa1[52] = jjGen;</span>
            }
<span class="fc bfc" id="L1519" title="All 2 branches covered.">            if (priority != null) {</span>
<span class="fc" id="L1520">                valueNode.addChildToBack(priority);</span>
            }
<span class="fc" id="L1522">            CssDeclarationNode node = nodeBuilder.buildDeclarationNode(property, valueNode, tokens);</span>
            {
<span class="fc" id="L1524">                return node;</span>
            }
<span class="fc" id="L1526">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L1527" title="1 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L1528">                throw e;</span>
            }
<span class="fc" id="L1530">            skipComponentValuesToBefore(RIGHTBRACE, SEMICOLON);</span>
            {
<span class="fc" id="L1532">                throw e;</span>
            }
        }
    }

    // expr
//   : compositeTerm [ compositeTerm ]*
//   ;
    public final CssPropertyValueNode expr() throws ParseException {
<span class="fc" id="L1541">        List&lt;CssValueNode&gt; lst = Lists.newArrayList();</span>
        CssValueNode value;
<span class="fc" id="L1543">        value = compositeTerm();</span>
<span class="fc" id="L1544">        lst.add(value);</span>
<span class="fc bfc" id="L1545" title="All 2 branches covered.">        while (jj22(1)) {</span>
<span class="fc" id="L1546">            value = compositeTerm();</span>
<span class="fc" id="L1547">            lst.add(value);</span>
        }
<span class="fc" id="L1549">        CssPropertyValueNode result = new CssPropertyValueNode(lst);</span>
<span class="fc" id="L1550">        result.setSourceCodeLocation(mergeLocations(lst));</span>
        {
<span class="fc" id="L1552">            return result;</span>
        }
    }

    // (non-standard GSS extension)
// compositeTerm
//   : assignTerm [ ',' assignTerm ]*
//   ;
    public final CssValueNode compositeTerm() throws ParseException {
        CssValueNode value;
<span class="fc" id="L1562">        List&lt;CssValueNode&gt; lst = Lists.newArrayList();</span>
        SourceCodeLocation beginLocation;
        Token t;
<span class="fc" id="L1565">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L1566">        beginLocation = this.getLocation(token.next);</span>
<span class="fc" id="L1567">        value = assignTerm();</span>
<span class="fc" id="L1568">        lst.add(value);</span>
        while (true) {
<span class="pc bpc" id="L1570" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != COMMA) {</span>
<span class="fc" id="L1571">                jjLa1[53] = jjGen;</span>
<span class="fc" id="L1572">                break;</span>
            }
<span class="fc" id="L1574">            t = jjConsumeToken(COMMA);</span>
<span class="fc" id="L1575">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1577" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1578">                    jjLa1[54] = jjGen;</span>
<span class="fc" id="L1579">                    break;</span>
                }
<span class="fc" id="L1581">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1583">            value = assignTerm();</span>
<span class="fc" id="L1584">            lst.add(value);</span>
        }
<span class="fc bfc" id="L1586" title="All 2 branches covered.">        if (lst.size() == 1) {</span>
            {
<span class="fc" id="L1588">                return lst.get(0);</span>
            }
        } else {
            {
<span class="fc" id="L1592">                return nodeBuilder.buildCompositeValueNode(lst, CssCompositeValueNode.Operator.COMMA,</span>
<span class="fc" id="L1593">                        this.mergeLocations(beginLocation, this.getLocation()), tokens);</span>
            }
        }
    }

    // (non-standard GSS extension)
// assignTerm
//   : slashTerm [ '=' slashTerm ]*
//   ;
    public final CssValueNode assignTerm() throws ParseException {
        CssValueNode value;
<span class="fc" id="L1604">        List&lt;CssValueNode&gt; lst = Lists.newArrayList();</span>
        SourceCodeLocation beginLocation;
        Token t;
<span class="fc" id="L1607">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L1608">        beginLocation = this.getLocation(token.next);</span>
<span class="fc" id="L1609">        value = slashTerm();</span>
<span class="fc" id="L1610">        lst.add(value);</span>
        while (true) {
<span class="pc bpc" id="L1612" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != EQUALS) {</span>
<span class="fc" id="L1613">                jjLa1[55] = jjGen;</span>
<span class="fc" id="L1614">                break;</span>
            }
<span class="fc" id="L1616">            t = jjConsumeToken(EQUALS);</span>
<span class="fc" id="L1617">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1619" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1620">                    jjLa1[56] = jjGen;</span>
<span class="fc" id="L1621">                    break;</span>
                }
<span class="fc" id="L1623">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1625">            value = slashTerm();</span>
<span class="fc" id="L1626">            lst.add(value);</span>
        }
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        if (lst.size() == 1) {</span>
            {
<span class="fc" id="L1630">                return lst.get(0);</span>
            }
        }
        {
<span class="fc" id="L1634">            return nodeBuilder.buildCompositeValueNode(lst, CssCompositeValueNode.Operator.EQUALS,</span>
<span class="fc" id="L1635">                    this.mergeLocations(beginLocation, this.getLocation()), tokens);</span>
        }
    }

    // (non-standard GSS extension)
// slashTerm
//   : term [ '/' term ]*
//   ;
    public final CssValueNode slashTerm() throws ParseException {
        CssValueNode value;
<span class="fc" id="L1645">        List&lt;CssValueNode&gt; lst = Lists.newArrayList();</span>
        SourceCodeLocation beginLocation;
        Token t;
<span class="fc" id="L1648">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L1649">        beginLocation = this.getLocation(token.next);</span>
<span class="fc" id="L1650">        value = term();</span>
<span class="fc" id="L1651">        lst.add(value);</span>
        while (true) {
<span class="pc bpc" id="L1653" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != SLASH) {</span>
<span class="fc" id="L1654">                jjLa1[57] = jjGen;</span>
<span class="fc" id="L1655">                break;</span>
            }
<span class="fc" id="L1657">            t = jjConsumeToken(SLASH);</span>
<span class="fc" id="L1658">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1660" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1661">                    jjLa1[58] = jjGen;</span>
<span class="fc" id="L1662">                    break;</span>
                }
<span class="fc" id="L1664">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1666">            value = term();</span>
<span class="fc" id="L1667">            lst.add(value);</span>
        }
<span class="fc bfc" id="L1669" title="All 2 branches covered.">        if (lst.size() == 1) {</span>
            {
<span class="fc" id="L1671">                return lst.get(0);</span>
            }
        } else {
            {
<span class="fc" id="L1675">                return nodeBuilder.buildCompositeValueNode(lst, CssCompositeValueNode.Operator.SLASH,</span>
<span class="fc" id="L1676">                        this.mergeLocations(beginLocation, this.getLocation()), tokens);</span>
            }
        }
    }

    // term
//   : unaryOperator?
//     [ [ NUMBER [ PERCENT | IDENTIFIER ] ] | STRING | IDENT | FORVARIABLE
//       | '(' S? IDENT ':' S* NUMBER [ S* '/' S* NUMBER | IDENT ]? ')'
//       | URI | hexcolor | function | math
//     ] S*
//   ;
    public final CssValueNode term() throws ParseException {
<span class="fc" id="L1689">        Token t = null;</span>
<span class="fc" id="L1690">        Token dim = null;</span>
<span class="fc" id="L1691">        String unit = null;</span>
<span class="fc" id="L1692">        String unop = &quot;&quot;;</span>
<span class="fc" id="L1693">        CssFunctionNode function = null;</span>
<span class="fc" id="L1694">        CssStringNode stringNode = null;</span>
<span class="fc" id="L1695">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L1696">        boolean hexcolor = false;</span>
<span class="fc" id="L1697">        boolean loopVariable = false;</span>
<span class="fc" id="L1698">        boolean unicodeRange = false;</span>
<span class="pc bpc" id="L1699" title="1 of 6 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case MINUS:
            case WPLUS:
            case NUMBER: {
<span class="pc bpc" id="L1703" title="1 of 4 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case MINUS:
                    case WPLUS: {
<span class="fc" id="L1706">                        t = unaryOperator();</span>
<span class="fc" id="L1707">                        unop = trim(t.image);</span>
<span class="fc" id="L1708">                        tokens.add(t);</span>
<span class="fc" id="L1709">                        break;</span>
                    }
                    default:
<span class="fc" id="L1712">                        jjLa1[59] = jjGen;</span>
                }
                // Number with optional arbitrary dimension or percent.
<span class="fc" id="L1715">                t = jjConsumeToken(NUMBER);</span>
<span class="fc" id="L1716">                unit = CssNumericNode.NO_UNITS;</span>
<span class="fc" id="L1717">                tokens.add(t);</span>
<span class="pc bpc" id="L1718" title="1 of 4 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case PERCENT:
                    case IDENTIFIER: {
<span class="pc bpc" id="L1721" title="2 of 5 branches missed.">                        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                            case PERCENT: {
<span class="fc" id="L1723">                                dim = jjConsumeToken(PERCENT);</span>
<span class="fc" id="L1724">                                break;</span>
                            }
                            case IDENTIFIER: {
<span class="fc" id="L1727">                                dim = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1728">                                break;</span>
                            }
                            default:
<span class="nc" id="L1731">                                jjLa1[60] = jjGen;</span>
<span class="nc" id="L1732">                                jjConsumeToken(-1);</span>
<span class="nc" id="L1733">                                throw new ParseException();</span>
                        }
<span class="fc" id="L1735">                        unit = dim.image.toLowerCase();</span>
<span class="fc" id="L1736">                        tokens.add(dim);</span>
<span class="fc" id="L1737">                        break;</span>
                    }
                    default:
<span class="fc" id="L1740">                        jjLa1[61] = jjGen;</span>
                }
<span class="fc" id="L1742">                break;</span>
            }
            case UNICODE_RANGE: {
<span class="fc" id="L1745">                t = jjConsumeToken(UNICODE_RANGE);</span>
<span class="fc" id="L1746">                unicodeRange = true;</span>
<span class="fc" id="L1747">                tokens.add(t);</span>
<span class="fc" id="L1748">                break;</span>
            }
            case DOUBLE_QUOTED_STRING:
            case SINGLE_QUOTED_STRING: {
<span class="fc" id="L1752">                stringNode = string();</span>
<span class="fc" id="L1753">                break;</span>
            }
            default:
<span class="fc" id="L1756">                jjLa1[70] = jjGen;</span>
<span class="fc bfc" id="L1757" title="All 2 branches covered.">                if (jj23(1)) {</span>
<span class="pc bpc" id="L1758" title="2 of 4 branches missed.">                    if (getToken(2).kind == DOT || getToken(2).kind == COLON) {</span>
<span class="nc" id="L1759">                        jjConsumeToken(-1);</span>
<span class="nc" id="L1760">                        throw new ParseException();</span>
                    }
<span class="fc" id="L1762">                    t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1763">                    tokens.add(t);</span>
                } else {
<span class="pc bpc" id="L1765" title="1 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) == FOR_VARIABLE) {// For variables will be evaluated to a number eventually.</span>
<span class="fc" id="L1766">                        t = jjConsumeToken(FOR_VARIABLE);</span>
<span class="fc" id="L1767">                        loopVariable = true;</span>
<span class="fc" id="L1768">                        tokens.add(t);</span>
                    } else {
<span class="fc" id="L1770">                        jjLa1[71] = jjGen;</span>
<span class="fc bfc" id="L1771" title="All 2 branches covered.">                        if (jj24(1)) {</span>
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">                            if (getToken(1).kind == LEFTROUND</span>
<span class="pc bpc" id="L1773" title="1 of 4 branches missed.">                                    &amp;&amp; (getToken(3).kind == COLON || getToken(4).kind == COLON)) {</span>

                            } else {
<span class="nc" id="L1776">                                jjConsumeToken(-1);</span>
<span class="nc" id="L1777">                                throw new ParseException();</span>
                            }
<span class="fc" id="L1779">                            t = jjConsumeToken(LEFTROUND);</span>
<span class="fc" id="L1780">                            tokens.add(t);</span>
                            try {
<span class="pc bpc" id="L1782" title="1 of 4 branches missed.">                                if (((jjNtk == -1) ? jjNtkF() : jjNtk) == S) {</span>
<span class="fc" id="L1783">                                    jjConsumeToken(S);</span>
                                } else {
<span class="fc" id="L1785">                                    jjLa1[62] = jjGen;</span>
                                }
<span class="fc" id="L1787">                                t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1788">                                tokens.add(t);</span>
<span class="fc" id="L1789">                                t = jjConsumeToken(COLON);</span>
<span class="fc" id="L1790">                                tokens.add(t);</span>
                                while (true) {
<span class="pc bpc" id="L1792" title="1 of 4 branches missed.">                                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1793">                                        jjLa1[63] = jjGen;</span>
<span class="fc" id="L1794">                                        break;</span>
                                    }
<span class="fc" id="L1796">                                    jjConsumeToken(S);</span>
                                }
<span class="pc bpc" id="L1798" title="2 of 5 branches missed.">                                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                                    case NUMBER: {
<span class="fc" id="L1800">                                        t = jjConsumeToken(NUMBER);</span>
<span class="fc" id="L1801">                                        tokens.add(t);</span>
<span class="pc bpc" id="L1802" title="1 of 4 branches missed.">                                        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                                            case SLASH:
                                            case S: {
                                                while (true) {
<span class="fc bfc" id="L1806" title="All 4 branches covered.">                                                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1807">                                                        jjLa1[64] = jjGen;</span>
<span class="fc" id="L1808">                                                        break;</span>
                                                    }
<span class="fc" id="L1810">                                                    jjConsumeToken(S);</span>
                                                }
<span class="fc" id="L1812">                                                t = jjConsumeToken(SLASH);</span>
<span class="fc" id="L1813">                                                tokens.add(t);</span>
                                                while (true) {
<span class="pc bpc" id="L1815" title="1 of 4 branches missed.">                                                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1816">                                                        jjLa1[65] = jjGen;</span>
<span class="fc" id="L1817">                                                        break;</span>
                                                    }
<span class="fc" id="L1819">                                                    jjConsumeToken(S);</span>
                                                }
<span class="fc" id="L1821">                                                t = jjConsumeToken(NUMBER);</span>
<span class="fc" id="L1822">                                                tokens.add(t);</span>
<span class="fc" id="L1823">                                                break;</span>
                                            }
                                            default:
<span class="fc" id="L1826">                                                jjLa1[66] = jjGen;</span>
                                        }
<span class="fc bfc" id="L1828" title="All 4 branches covered.">                                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) == IDENTIFIER) {</span>
<span class="fc" id="L1829">                                            dim = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1830">                                            tokens.add(dim);</span>
                                        } else {
<span class="fc" id="L1832">                                            jjLa1[67] = jjGen;</span>
                                        }
<span class="fc" id="L1834">                                        break;</span>
                                    }
                                    case IDENTIFIER: {
<span class="fc" id="L1837">                                        t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L1838">                                        tokens.add(t);</span>
<span class="fc" id="L1839">                                        break;</span>
                                    }
                                    default:
<span class="nc" id="L1842">                                        jjLa1[68] = jjGen;</span>
<span class="nc" id="L1843">                                        jjConsumeToken(-1);</span>
<span class="nc" id="L1844">                                        throw new ParseException();</span>
                                }
                                while (true) {
<span class="fc bfc" id="L1847" title="All 4 branches covered.">                                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1848">                                        jjLa1[69] = jjGen;</span>
<span class="fc" id="L1849">                                        break;</span>
                                    }
<span class="fc" id="L1851">                                    jjConsumeToken(S);</span>
                                }
<span class="fc" id="L1853">                                t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L1854">                                tokens.add(t);</span>
<span class="fc" id="L1855">                            } catch (ParseException e) {</span>
<span class="pc bpc" id="L1856" title="2 of 4 branches missed.">                                if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L1857">                                    throw e;</span>
                                }
<span class="fc" id="L1859">                                skipComponentValuesToAfter(RIGHTROUND);</span>
                                {
<span class="fc" id="L1861">                                    throw e;</span>
                                }
<span class="fc" id="L1863">                            }</span>
<span class="fc bfc" id="L1864" title="All 2 branches covered.">                        } else if (getToken(1).kind == URI) {</span>
<span class="fc" id="L1865">                            function = uri();</span>
                        } else {
<span class="pc bpc" id="L1867" title="1 of 7 branches missed.">                            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                                case HASH_NAME: {
<span class="fc" id="L1869">                                    t = hexcolor();</span>
<span class="fc" id="L1870">                                    tokens.add(t);</span>
<span class="fc" id="L1871">                                    hexcolor = true;</span>
<span class="fc" id="L1872">                                    break;</span>
                                }
                                case CALC: {
<span class="fc" id="L1875">                                    function = calc();</span>
<span class="fc" id="L1876">                                    break;</span>
                                }
                                case VARFUNCTION: {
<span class="fc" id="L1879">                                    function = varNode();</span>
<span class="fc" id="L1880">                                    break;</span>
                                }
                                case IDENTIFIER:
                                case FUNCTION: {
<span class="fc" id="L1884">                                    function = function();</span>
<span class="fc" id="L1885">                                    break;</span>
                                }
                                default:
<span class="fc" id="L1888">                                    jjLa1[72] = jjGen;</span>
<span class="nc" id="L1889">                                    jjConsumeToken(-1);</span>
<span class="nc" id="L1890">                                    throw new ParseException();</span>
                            }
                        }
                    }
                }
        }
        while (true) {
<span class="fc bfc" id="L1897" title="All 4 branches covered.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1898">                jjLa1[73] = jjGen;</span>
<span class="fc" id="L1899">                break;</span>
            }
<span class="fc" id="L1901">            jjConsumeToken(S);</span>
        }
<span class="fc bfc" id="L1903" title="All 2 branches covered.">        if (unit != null) {</span>
            SourceCodeLocation location;
<span class="fc bfc" id="L1905" title="All 2 branches covered.">            if (dim != null) {</span>
<span class="fc" id="L1906">                location = this.mergeLocations(this.getLocation(t), this.getLocation(dim));</span>
            } else {
<span class="fc" id="L1908">                location = this.getLocation(t);</span>
            }
            {
<span class="fc" id="L1911">                return nodeBuilder.buildNumericNode(unop + t.image, unit, location, tokens);</span>
            }
<span class="fc bfc" id="L1913" title="All 2 branches covered.">        } else if (function != null) {</span>
            {
<span class="fc" id="L1915">                return function;</span>
            }
<span class="fc bfc" id="L1917" title="All 2 branches covered.">        } else if (hexcolor) {</span>
            {
<span class="fc" id="L1919">                return nodeBuilder.buildHexColorNode(t.image, this.getLocation(t), tokens);</span>
            }
<span class="fc bfc" id="L1921" title="All 2 branches covered.">        } else if (stringNode != null) {</span>
            {
<span class="fc" id="L1923">                return stringNode;</span>
            }
        } else {
<span class="fc" id="L1926">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L1927" title="All 2 branches covered.">            for (Token token : tokens) {</span>
<span class="fc" id="L1928">                sb.append(token.image);</span>
<span class="fc" id="L1929">            }</span>
<span class="fc bfc" id="L1930" title="All 2 branches covered.">            if (loopVariable) {</span>
                {

<span class="fc" id="L1933">                    return nodeBuilder.buildLoopVariableNode(sb.toString(), this.getLocation(t), tokens);</span>
                }
<span class="fc bfc" id="L1935" title="All 2 branches covered.">            } else if (unicodeRange) {</span>
                {

<span class="fc" id="L1938">                    return nodeBuilder.buildUnicodeRangeNode(sb.toString(), this.getLocation(t), tokens);</span>
                }
            } else {
                {
<span class="fc" id="L1942">                    return nodeBuilder.buildLiteralNode(sb.toString(), this.getLocation(t), tokens);</span>
                }
            }
        }
    }

    // (non-standard GSS extension)
// extendedTerm
//   : booleanAndTerm [ '||' S* booleanAndTerm ]*
//   ;
    public final CssBooleanExpressionNode extendedTerm() throws ParseException {
        SourceCodeLocation beginLocation;
        SourceCodeLocation endLocation;
        CssBooleanExpressionNode newNode;
        CssBooleanExpressionNode left;
        CssBooleanExpressionNode right;
<span class="fc" id="L1958">        String value = &quot;&quot;;</span>
        Token t;
<span class="fc" id="L1960">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L1961">        beginLocation = this.getLocation(token.next);</span>
<span class="fc" id="L1962">        left = booleanAndTerm();</span>
<span class="fc" id="L1963">        value += left.toString();</span>
        while (true) {
<span class="pc bpc" id="L1965" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != OR) {</span>
<span class="fc" id="L1966">                jjLa1[74] = jjGen;</span>
<span class="fc" id="L1967">                break;</span>
            }
<span class="fc" id="L1969">            t = jjConsumeToken(OR);</span>
<span class="fc" id="L1970">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L1972" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L1973">                    jjLa1[75] = jjGen;</span>
<span class="fc" id="L1974">                    break;</span>
                }
<span class="fc" id="L1976">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L1978">            right = booleanAndTerm();</span>
<span class="fc" id="L1979">            value += right.toString();</span>
<span class="fc" id="L1980">            endLocation = this.getLocation();</span>
<span class="fc" id="L1981">            newNode = nodeBuilder.buildBoolExpressionNode(</span>
                    CssBooleanExpressionNode.Type.OR, value, left, right,
<span class="fc" id="L1983">                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
<span class="fc" id="L1984">            left = newNode;</span>
        }
        {
<span class="fc" id="L1987">            return left;</span>
        }
    }

    // (non-standard GSS extension)
// booleanAndTerm
//   :  [ booleanNegatedTerm | basicTerm]
//      [ '&amp;&amp;' S* [ booleanNegatedTerm | basicTerm ] ]*
//   ;
    public final CssBooleanExpressionNode booleanAndTerm() throws ParseException {
        SourceCodeLocation beginLocation;
        SourceCodeLocation endLocation;
        CssBooleanExpressionNode newNode;
        CssBooleanExpressionNode left;
        CssBooleanExpressionNode right;
<span class="fc" id="L2002">        String value = &quot;&quot;;</span>
        Token t;
<span class="fc" id="L2004">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2005">        beginLocation = this.getLocation(token.next);</span>
<span class="pc bpc" id="L2006" title="1 of 4 branches missed.">        if (((jjNtk == -1) ? jjNtkF() : jjNtk) == EXCL_MARK) {</span>
<span class="fc" id="L2007">            left = booleanNegatedTerm();</span>
        } else {
<span class="fc" id="L2009">            jjLa1[76] = jjGen;</span>
<span class="pc bpc" id="L2010" title="1 of 2 branches missed.">            if (jj25(1)) {</span>
<span class="fc" id="L2011">                left = basicTerm();</span>
            } else {
<span class="nc" id="L2013">                jjConsumeToken(-1);</span>
<span class="nc" id="L2014">                throw new ParseException();</span>
            }
        }
<span class="fc" id="L2017">        value += left.toString();</span>
        while (true) {
<span class="pc bpc" id="L2019" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != AND) {</span>
<span class="fc" id="L2020">                jjLa1[77] = jjGen;</span>
<span class="fc" id="L2021">                break;</span>
            }
<span class="fc" id="L2023">            t = jjConsumeToken(AND);</span>
<span class="fc" id="L2024">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L2026" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2027">                    jjLa1[78] = jjGen;</span>
<span class="fc" id="L2028">                    break;</span>
                }
<span class="fc" id="L2030">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L2032" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) == EXCL_MARK) {</span>
<span class="fc" id="L2033">                right = booleanNegatedTerm();</span>
            } else {
<span class="fc" id="L2035">                jjLa1[79] = jjGen;</span>
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">                if (jj26(1)) {</span>
<span class="fc" id="L2037">                    right = basicTerm();</span>
                } else {
<span class="nc" id="L2039">                    jjConsumeToken(-1);</span>
<span class="nc" id="L2040">                    throw new ParseException();</span>
                }
            }
<span class="fc" id="L2043">            value += right.toString();</span>
<span class="fc" id="L2044">            endLocation = this.getLocation();</span>
<span class="fc" id="L2045">            newNode = nodeBuilder.buildBoolExpressionNode(</span>
                    CssBooleanExpressionNode.Type.AND, value, left, right,
<span class="fc" id="L2047">                    this.mergeLocations(beginLocation, endLocation), tokens);</span>
<span class="fc" id="L2048">            left = newNode;</span>
        }
        {
<span class="fc" id="L2051">            return left;</span>
        }
    }

    // (non-standard GSS extension)
// booleanNegatedTerm
//   : '!' S* basicTerm
//   ;
    public final CssBooleanExpressionNode booleanNegatedTerm() throws ParseException {
        SourceCodeLocation beginLocation;
        String value;
        CssBooleanExpressionNode boolNode;
        Token t;
<span class="fc" id="L2064">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2065">        t = jjConsumeToken(EXCL_MARK);</span>
<span class="fc" id="L2066">        value = &quot;!&quot;;</span>
<span class="fc" id="L2067">        beginLocation = this.getLocation();</span>
<span class="fc" id="L2068">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L2070" title="2 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2071">                jjLa1[80] = jjGen;</span>
<span class="fc" id="L2072">                break;</span>
            }
<span class="nc" id="L2074">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L2076">        boolNode = basicTerm();</span>
<span class="fc" id="L2077">        SourceCodeLocation endLocation = this.getLocation();</span>
        {
<span class="fc" id="L2079">            return nodeBuilder.buildBoolExpressionNode(CssBooleanExpressionNode.Type.NOT,</span>
<span class="fc" id="L2080">                    value, boolNode, null, this.mergeLocations(beginLocation, endLocation), tokens);</span>
        }
    }

    // (non-standard GSS extension)
// basicTerm
//   :  term | parenthesizedTerm
//   ;
    public final CssBooleanExpressionNode basicTerm() throws ParseException {
        SourceCodeLocation beginLocation;
        String value;
<span class="fc" id="L2091">        CssBooleanExpressionNode node = null;</span>
        CssValueNode termNode;
<span class="fc" id="L2093">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2094">        beginLocation = this.getLocation(token.next);</span>
<span class="fc bfc" id="L2095" title="All 2 branches covered.">        if (jj27(1)) {</span>
<span class="fc" id="L2096">            termNode = term();</span>
<span class="fc" id="L2097">            value = termNode.toString();</span>
        } else {
<span class="pc bpc" id="L2099" title="2 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) == LEFTROUND) {</span>
<span class="fc" id="L2100">                node = parenthesizedTerm();</span>
<span class="fc" id="L2101">                value = node.toString();</span>
            } else {
<span class="nc" id="L2103">                jjLa1[81] = jjGen;</span>
<span class="nc" id="L2104">                jjConsumeToken(-1);</span>
<span class="nc" id="L2105">                throw new ParseException();</span>
            }
        }
<span class="fc" id="L2108">        SourceCodeLocation endLocation = this.getLocation();</span>
<span class="fc bfc" id="L2109" title="All 2 branches covered.">        if (node == null) {</span>
            {
<span class="fc" id="L2111">                return nodeBuilder.buildBoolExpressionNode(CssBooleanExpressionNode.Type.CONSTANT,</span>
<span class="fc" id="L2112">                        value, null, null, this.mergeLocations(beginLocation, endLocation), tokens);</span>
            }
        } else {
            {
<span class="fc" id="L2116">                return node;</span>
            }
        }
    }

    // (non-standard GSS extension)
// parenthesizedTerm
//   : '(' S* extendedTerm ')' S*
//   ;
    public final CssBooleanExpressionNode parenthesizedTerm() throws ParseException {
        Token t;
<span class="fc" id="L2127">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        CssBooleanExpressionNode node;
<span class="fc" id="L2129">        t = jjConsumeToken(LEFTROUND);</span>
<span class="fc" id="L2130">        tokens.add(t);</span>
        try {
            while (true) {
<span class="pc bpc" id="L2133" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2134">                    jjLa1[82] = jjGen;</span>
<span class="fc" id="L2135">                    break;</span>
                }
<span class="fc" id="L2137">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L2139">            node = extendedTerm();</span>
<span class="fc" id="L2140">            t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L2141">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L2143" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2144">                    jjLa1[83] = jjGen;</span>
<span class="fc" id="L2145">                    break;</span>
                }
<span class="fc" id="L2147">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L2149">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L2150" title="2 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L2151">                throw e;</span>
            }
<span class="fc" id="L2153">            skipComponentValuesToAfter(RIGHTROUND);</span>
            {
<span class="fc" id="L2155">                throw e;</span>
            }
<span class="fc" id="L2157">        }</span>
<span class="fc" id="L2158">        nodeBuilder.attachComments(tokens, node);</span>
        {
<span class="fc" id="L2160">            return node;</span>
        }
    }

    // unaryOperator
//   : '-' | '+'
//   ;
    public final Token unaryOperator() throws ParseException {
        Token t;
<span class="pc bpc" id="L2169" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case MINUS: {
<span class="fc" id="L2171">                t = jjConsumeToken(MINUS);</span>
<span class="fc" id="L2172">                break;</span>
            }
            case WPLUS: {
<span class="fc" id="L2175">                t = jjConsumeToken(WPLUS);</span>
<span class="fc" id="L2176">                break;</span>
            }
            default:
<span class="nc" id="L2179">                jjLa1[84] = jjGen;</span>
<span class="nc" id="L2180">                jjConsumeToken(-1);</span>
<span class="nc" id="L2181">                throw new ParseException();</span>
        }
        {
<span class="fc" id="L2184">            return t;</span>
        }
    }

    /*
     * There is a constraint on the color that it must
     * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
     * after the &quot;#&quot;; e.g., &quot;#000&quot; is OK, but &quot;#abcd&quot; is not.
     */
// hexcolor
//   : HASH_NAME S*
//   ;
    public final Token hexcolor() throws ParseException {
        Token t;
<span class="fc" id="L2198">        t = jjConsumeToken(HASH_NAME);</span>
        {
<span class="fc" id="L2200">            return t;</span>
        }
    }

    public final CssFunctionNode varNode() throws ParseException {
        Token t;
        SourceCodeLocation beginLocation;
<span class="fc" id="L2207">        StringBuilder functionName = new StringBuilder();</span>
        CssPropertyValueNode defaultValueNode;
<span class="fc" id="L2209">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2210">        List&lt;CssValueNode&gt; arguments = Lists.newArrayList();</span>
<span class="fc" id="L2211">        beginLocation = this.getLocation(token.next);</span>
<span class="fc" id="L2212">        t = jjConsumeToken(VARFUNCTION);</span>
<span class="fc" id="L2213">        functionName.append(t.image);</span>
<span class="fc" id="L2214">        functionName.setLength(functionName.length() - 1);</span>
<span class="fc" id="L2215">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L2217" title="2 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2218">                jjLa1[85] = jjGen;</span>
<span class="fc" id="L2219">                break;</span>
            }
<span class="nc" id="L2221">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L2223">        t = jjConsumeToken(CUSTOM_PROPERTY_NAME);</span>
<span class="fc" id="L2224">        arguments.add(new CssPropertyNode(t.image, this.getLocation()));</span>
<span class="fc" id="L2225">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L2227" title="2 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2228">                jjLa1[86] = jjGen;</span>
<span class="fc" id="L2229">                break;</span>
            }
<span class="nc" id="L2231">            jjConsumeToken(S);</span>
        }
<span class="pc bpc" id="L2233" title="1 of 4 branches missed.">        if (((jjNtk == -1) ? jjNtkF() : jjNtk) == COMMA) {</span>
<span class="fc" id="L2234">            t = jjConsumeToken(COMMA);</span>
<span class="fc" id="L2235">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L2237" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2238">                    jjLa1[87] = jjGen;</span>
<span class="fc" id="L2239">                    break;</span>
                }
<span class="fc" id="L2241">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L2243">            defaultValueNode = customDeclarationValue();</span>
<span class="fc" id="L2244">            arguments.add(defaultValueNode.getChildAt(0));</span>
        } else {
<span class="fc" id="L2246">            jjLa1[88] = jjGen;</span>
        }
<span class="fc" id="L2248">        t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L2249">        tokens.add(t);</span>
<span class="fc" id="L2250">        SourceCodeLocation endLocation = this.getLocation(t);</span>
<span class="fc" id="L2251">        CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();</span>
<span class="fc" id="L2252">        addArgumentsWithSeparator(args, arguments, arguments.size(), &quot;,&quot;);</span>
        {
<span class="fc" id="L2254">            return nodeBuilder.buildFunctionNode(</span>
<span class="fc" id="L2255">                    functionName.toString(),</span>
<span class="fc" id="L2256">                    this.mergeLocations(beginLocation, endLocation), args, tokens);</span>
        }
    }

    public final CssFunctionNode uri() throws ParseException {
        Token t;
<span class="fc" id="L2262">        this.getLocation(token.next);</span>
<span class="fc" id="L2263">        t = jjConsumeToken(URI);</span>
        {
<span class="fc" id="L2265">            return createUrlFunction(t);</span>
        }
    }

    // function
//   : [ FUNCTION
//     | [ IDENTIFIER [ '.' | ':' ] [ IDENTIFIER [ '.' | ':' ] ]* FUNCTION ]
//     S* expr ')' S*
//   ;
// Note: We allow the function name to have : and . to support non-standard IE
// functions.
    public final CssFunctionNode function() throws ParseException {
        Token t;
        CssPropertyValueNode expr;
        SourceCodeLocation beginLocation;
<span class="fc" id="L2280">        StringBuilder functionName = new StringBuilder();</span>
<span class="fc" id="L2281">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2282">        beginLocation = this.getLocation(token.next);</span>
<span class="pc bpc" id="L2283" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case FUNCTION: {
<span class="fc" id="L2285">                t = jjConsumeToken(FUNCTION);</span>
<span class="fc" id="L2286">                functionName.append(t.image);</span>
<span class="fc" id="L2287">                functionName.setLength(functionName.length() - 1);</span>
<span class="fc" id="L2288">                tokens.add(t);</span>
<span class="fc" id="L2289">                break;</span>
            }
            case IDENTIFIER: {
<span class="fc" id="L2292">                t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L2293">                functionName.append(t.image);</span>
<span class="fc" id="L2294">                tokens.add(t);</span>
<span class="pc bpc" id="L2295" title="2 of 5 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case DOT: {
<span class="fc" id="L2297">                        jjConsumeToken(DOT);</span>
<span class="fc" id="L2298">                        functionName.append(&quot;.&quot;);</span>
<span class="fc" id="L2299">                        break;</span>
                    }
                    case COLON: {
<span class="fc" id="L2302">                        jjConsumeToken(COLON);</span>
<span class="fc" id="L2303">                        functionName.append(&quot;:&quot;);</span>
<span class="fc" id="L2304">                        break;</span>
                    }
                    default:
<span class="nc" id="L2307">                        jjLa1[89] = jjGen;</span>
<span class="nc" id="L2308">                        jjConsumeToken(-1);</span>
<span class="nc" id="L2309">                        throw new ParseException();</span>
                }
                while (true) {
<span class="pc bpc" id="L2312" title="1 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != IDENTIFIER) {</span>
<span class="fc" id="L2313">                        jjLa1[90] = jjGen;</span>
<span class="fc" id="L2314">                        break;</span>
                    }
<span class="fc" id="L2316">                    t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L2317">                    functionName.append(t.image);</span>
<span class="pc bpc" id="L2318" title="2 of 5 branches missed.">                    switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                        case DOT: {
<span class="fc" id="L2320">                            jjConsumeToken(DOT);</span>
<span class="fc" id="L2321">                            functionName.append(&quot;.&quot;);</span>
<span class="fc" id="L2322">                            break;</span>
                        }
                        case COLON: {
<span class="fc" id="L2325">                            jjConsumeToken(COLON);</span>
<span class="fc" id="L2326">                            functionName.append(&quot;:&quot;);</span>
<span class="fc" id="L2327">                            break;</span>
                        }
                        default:
<span class="nc" id="L2330">                            jjLa1[91] = jjGen;</span>
<span class="nc" id="L2331">                            jjConsumeToken(-1);</span>
<span class="nc" id="L2332">                            throw new ParseException();</span>
                    }
                }
<span class="fc" id="L2335">                t = jjConsumeToken(FUNCTION);</span>
<span class="fc" id="L2336">                functionName.append(t.image);</span>
<span class="fc" id="L2337">                functionName.setLength(functionName.length() - 1);</span>
<span class="fc" id="L2338">                break;</span>
            }
            default:
<span class="nc" id="L2341">                jjLa1[92] = jjGen;</span>
<span class="nc" id="L2342">                jjConsumeToken(-1);</span>
<span class="nc" id="L2343">                throw new ParseException();</span>
        }
        while (true) {
<span class="pc bpc" id="L2346" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2347">                jjLa1[93] = jjGen;</span>
<span class="fc" id="L2348">                break;</span>
            }
<span class="fc" id="L2350">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L2352">        expr = expr();</span>
<span class="fc" id="L2353">        t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L2354">        tokens.add(t);</span>
<span class="fc" id="L2355">        SourceCodeLocation endLocation = this.getLocation();</span>
<span class="fc" id="L2356">        CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();</span>
<span class="fc bfc" id="L2357" title="All 2 branches covered.">        if (expr.numChildren() == 1) {</span>
<span class="fc" id="L2358">            CssValueNode child = expr.getChildAt(0);</span>
<span class="fc" id="L2359">            addArgumentsWithSeparator(args, ImmutableList.of(child), 1, &quot; &quot;);</span>
<span class="fc bfc" id="L2360" title="All 2 branches covered.">        } else if (FUNCTIONSWITHSPACESEPOK.matcher(functionName).matches()) {</span>
<span class="fc" id="L2361">            addArgumentsWithSeparator(args, expr.childIterable(), expr.numChildren(), &quot; &quot;);</span>
        } else {
            {
<span class="fc" id="L2364">                throw generateParseException();</span>
            }
        }
<span class="fc" id="L2367">        CssFunctionNode functionNode = nodeBuilder.buildFunctionNode(</span>
<span class="fc" id="L2368">                functionName.toString(),</span>
<span class="fc" id="L2369">                this.mergeLocations(beginLocation, endLocation), args, tokens);</span>
        {
<span class="fc" id="L2371">            return functionNode;</span>
        }
    }

    // calc
//  : &quot;calc(&quot; S* sum S* &quot;)&quot;
//  ;
// TODO(user): this production disallows nested calc() expressions like calc(1 + calc(2*3)).
// (This is equivalent to calc(1 + (2*3)), which is allowed by this production.)
    public final CssFunctionNode calc() throws ParseException {
        Token t;
        SourceCodeLocation beginLocation;
<span class="fc" id="L2383">        StringBuilder functionName = new StringBuilder();</span>
        CssValueNode math;
<span class="fc" id="L2385">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2386">        beginLocation = this.getLocation(token.next);</span>
<span class="fc" id="L2387">        t = jjConsumeToken(CALC);</span>
<span class="fc" id="L2388">        functionName.append(t.image);</span>
<span class="fc" id="L2389">        functionName.setLength(functionName.length() - 1);</span>
<span class="fc" id="L2390">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L2392" title="2 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2393">                jjLa1[94] = jjGen;</span>
<span class="fc" id="L2394">                break;</span>
            }
<span class="nc" id="L2396">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L2398">        math = sum(/* hasParenthesis */ false);</span>
        while (true) {
<span class="pc bpc" id="L2400" title="2 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2401">                jjLa1[95] = jjGen;</span>
<span class="fc" id="L2402">                break;</span>
            }
<span class="nc" id="L2404">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L2406">        t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L2407">        tokens.add(t);</span>
<span class="fc" id="L2408">        SourceCodeLocation endLocation = this.getLocation(t);</span>
<span class="fc" id="L2409">        CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();</span>
<span class="fc" id="L2410">        addArgumentsWithSeparator(args, ImmutableList.of(math), 1, &quot;&quot;);</span>
        {
<span class="fc" id="L2412">            return nodeBuilder.buildFunctionNode(</span>
<span class="fc" id="L2413">                    functionName.toString(),</span>
<span class="fc" id="L2414">                    this.mergeLocations(beginLocation, endLocation), args, tokens);</span>
        }
    }

    // sum
//  : product [ S+ [ &quot;+&quot; | &quot;-&quot; ] S+ product ]*
//  ;
    public final CssValueNode sum(boolean hasParenthesis) throws ParseException {
        CssValueNode operand;
<span class="fc" id="L2423">        List&lt;CssValueNode&gt; operands = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2424">        List&lt;CssCompositeValueNode.Operator&gt; operators = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2425">        operand = product(hasParenthesis);</span>
<span class="fc" id="L2426">        operands.add(operand);</span>
        while (true) {
<span class="pc bpc" id="L2428" title="1 of 2 branches missed.">            int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="fc bfc" id="L2429" title="All 4 branches covered.">            if (i != WMINUSW &amp;&amp; i != WPLUS) {</span>
<span class="fc" id="L2430">                jjLa1[96] = jjGen;</span>
<span class="fc" id="L2431">                break;</span>
            }
<span class="pc bpc" id="L2433" title="2 of 5 branches missed.">            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                case WPLUS: {
<span class="fc" id="L2435">                    jjConsumeToken(WPLUS);</span>
                    while (true) {
<span class="pc bpc" id="L2437" title="1 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2438">                            jjLa1[97] = jjGen;</span>
<span class="fc" id="L2439">                            break;</span>
                        }
<span class="fc" id="L2441">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L2443">                    operators.add(CssCompositeValueNode.Operator.ADD);</span>
<span class="fc" id="L2444">                    break;</span>
                }
                case WMINUSW: {
<span class="fc" id="L2447">                    jjConsumeToken(WMINUSW);</span>
<span class="fc" id="L2448">                    operators.add(CssCompositeValueNode.Operator.SUB);</span>
<span class="fc" id="L2449">                    break;</span>
                }
                default:
<span class="nc" id="L2452">                    jjLa1[98] = jjGen;</span>
<span class="nc" id="L2453">                    jjConsumeToken(-1);</span>
<span class="nc" id="L2454">                    throw new ParseException();</span>
            }
<span class="fc" id="L2456">            operand = product(/* hasParenthesis */ false);</span>
<span class="fc" id="L2457">            operands.add(operand);</span>
<span class="fc" id="L2458">        }</span>
        {
<span class="fc" id="L2460">            return CssMathNode.createFromOperandsAndOperators(operands, operators, hasParenthesis);</span>
        }
    }

    // product
//  : unit [ S* [ &quot;*&quot; S* unit | &quot;/&quot; S* NUMBER ] ]*
//  ;
    public final CssValueNode product(boolean hasParenthesis) throws ParseException {
        Token t;
        CssValueNode operand;
<span class="fc" id="L2470">        List&lt;CssValueNode&gt; operands = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2471">        List&lt;CssCompositeValueNode.Operator&gt; operators = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2472">        operand = unit();</span>
<span class="fc" id="L2473">        operands.add(operand);</span>
        while (true) {
<span class="fc bfc" id="L2475" title="All 2 branches covered.">            int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="fc bfc" id="L2476" title="All 6 branches covered.">            if (i != ASTERISK &amp;&amp; i != SLASH &amp;&amp; i != S) {</span>
<span class="fc" id="L2477">                jjLa1[99] = jjGen;</span>
<span class="fc" id="L2478">                break;</span>
            }
            while (true) {
<span class="fc bfc" id="L2481" title="All 4 branches covered.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2482">                    jjLa1[100] = jjGen;</span>
<span class="fc" id="L2483">                    break;</span>
                }
<span class="fc" id="L2485">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L2487" title="2 of 5 branches missed.">            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                case ASTERISK: {
<span class="fc" id="L2489">                    jjConsumeToken(ASTERISK);</span>
<span class="fc" id="L2490">                    operators.add(CssCompositeValueNode.Operator.MULT);</span>
                    while (true) {
<span class="pc bpc" id="L2492" title="1 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2493">                            jjLa1[101] = jjGen;</span>
<span class="fc" id="L2494">                            break;</span>
                        }
<span class="fc" id="L2496">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L2498">                    operand = unit();</span>
<span class="fc" id="L2499">                    operands.add(operand);</span>
<span class="fc" id="L2500">                    break;</span>
                }
                case SLASH: {
<span class="fc" id="L2503">                    jjConsumeToken(SLASH);</span>
<span class="fc" id="L2504">                    operators.add(CssCompositeValueNode.Operator.DIV);</span>
                    while (true) {
<span class="pc bpc" id="L2506" title="1 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2507">                            jjLa1[102] = jjGen;</span>
<span class="fc" id="L2508">                            break;</span>
                        }
<span class="fc" id="L2510">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L2512">                    t = jjConsumeToken(NUMBER);</span>
<span class="fc" id="L2513">                    operands.add(new CssNumericNode(t.image, &quot;&quot;));</span>
<span class="fc" id="L2514">                    break;</span>
                }
                default:
<span class="nc" id="L2517">                    jjLa1[103] = jjGen;</span>
<span class="nc" id="L2518">                    jjConsumeToken(-1);</span>
<span class="nc" id="L2519">                    throw new ParseException();</span>
            }
<span class="fc" id="L2521">        }</span>
        {
<span class="fc" id="L2523">            return CssMathNode.createFromOperandsAndOperators(operands, operators, hasParenthesis);</span>
        }
    }

    // unit
//  : [ var | IDENTIFIER | NUMBER | DIMENSION | PERCENTAGE | &quot;(&quot; S* sum S* &quot;)&quot; ];
//  ;
    public final CssValueNode unit() throws ParseException {
        Token t;
<span class="fc" id="L2532">        String sign = &quot;&quot;;</span>
<span class="fc" id="L2533">        Token dim = null;</span>
        CssValueNode node;
<span class="pc bpc" id="L2535" title="1 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case MINUS:
            case WPLUS:
            case NUMBER:
            case IDENTIFIER:
            case VARFUNCTION: {
<span class="pc bpc" id="L2541" title="2 of 6 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case VARFUNCTION: {
<span class="fc" id="L2543">                        node = varNode();</span>
                        {
<span class="fc" id="L2545">                            return node;</span>
                        }
                    }
                    case IDENTIFIER: {
<span class="fc" id="L2549">                        t = jjConsumeToken(IDENTIFIER);</span>
                        {
<span class="fc" id="L2551">                            return new CssLiteralNode(t.image, this.getLocation(t));</span>
                        }
                    }
                    case MINUS:
                    case WPLUS:
                    case NUMBER: {
<span class="pc bpc" id="L2557" title="2 of 4 branches missed.">                        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                            case MINUS:
                            case WPLUS: {
<span class="nc" id="L2560">                                t = unaryOperator();</span>
<span class="nc" id="L2561">                                sign = t.image;</span>
<span class="nc" id="L2562">                                break;</span>
                            }
                            default:
<span class="fc" id="L2565">                                jjLa1[104] = jjGen;</span>
                        }
<span class="fc" id="L2567">                        t = jjConsumeToken(NUMBER);</span>

<span class="pc bpc" id="L2569" title="1 of 4 branches missed.">                        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                            case PERCENT:
                            case IDENTIFIER: {
<span class="pc bpc" id="L2572" title="2 of 5 branches missed.">                                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                                    case PERCENT: {
<span class="fc" id="L2574">                                        dim = jjConsumeToken(PERCENT);</span>
<span class="fc" id="L2575">                                        break;</span>
                                    }
                                    case IDENTIFIER: {
<span class="fc" id="L2578">                                        dim = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L2579">                                        break;</span>
                                    }
                                    default:
<span class="nc" id="L2582">                                        jjLa1[105] = jjGen;</span>
<span class="nc" id="L2583">                                        jjConsumeToken(-1);</span>
<span class="nc" id="L2584">                                        throw new ParseException();</span>
                                }

                                break;
                            }
                            default:
<span class="fc" id="L2590">                                jjLa1[106] = jjGen;</span>
                        }
                        {
<span class="fc bfc" id="L2593" title="All 2 branches covered.">                            return new CssNumericNode(sign + t.image, dim != null ? dim.image.toLowerCase() : &quot;&quot;, this.getLocation(t));</span>
                        }
                    }
                    default:
<span class="nc" id="L2597">                        jjLa1[107] = jjGen;</span>
<span class="nc" id="L2598">                        jjConsumeToken(-1);</span>
<span class="nc" id="L2599">                        throw new ParseException();</span>
                }
            }
            case LEFTROUND: {
<span class="fc" id="L2603">                jjConsumeToken(LEFTROUND);</span>

                try {
                    while (true) {
<span class="pc bpc" id="L2607" title="2 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2608">                            jjLa1[108] = jjGen;</span>
<span class="fc" id="L2609">                            break;</span>
                        }
<span class="nc" id="L2611">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L2613">                    node = sum(/* hasParenthesis */ true);</span>

                    while (true) {
<span class="pc bpc" id="L2616" title="2 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2617">                            jjLa1[109] = jjGen;</span>
<span class="fc" id="L2618">                            break;</span>
                        }
<span class="nc" id="L2620">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L2622">                    jjConsumeToken(RIGHTROUND);</span>
                    {
<span class="fc" id="L2624">                        return node;</span>
                    }
<span class="nc" id="L2626">                } catch (ParseException e) {</span>
<span class="nc bnc" id="L2627" title="All 4 branches missed.">                    if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L2628">                        throw e;</span>
                    }
<span class="nc" id="L2630">                    skipComponentValuesToAfter(RIGHTROUND);</span>
                    {
<span class="nc" id="L2632">                        throw e;</span>
                    }
                }
            }
            default:
<span class="nc" id="L2637">                jjLa1[110] = jjGen;</span>
<span class="nc" id="L2638">                jjConsumeToken(-1);</span>
<span class="nc" id="L2639">                throw new ParseException();</span>
        }
    }

    // (non-standard GSS extension)
// atFunction
//   : FUNCTION S* expr? ')' S*
//   ;
    public final CssFunctionNode atFunction() throws ParseException {
        Token t;
<span class="fc" id="L2649">        CssPropertyValueNode expr = null;</span>
        SourceCodeLocation beginLocation;
<span class="fc" id="L2651">        StringBuilder functionName = new StringBuilder();</span>
<span class="fc" id="L2652">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2653">        beginLocation = this.getLocation(token.next);</span>
<span class="fc" id="L2654">        t = jjConsumeToken(FUNCTION);</span>
<span class="fc" id="L2655">        functionName.append(t.image);</span>
<span class="fc" id="L2656">        functionName.setLength(functionName.length() - 1);</span>
<span class="fc" id="L2657">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L2659" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2660">                jjLa1[111] = jjGen;</span>
<span class="fc" id="L2661">                break;</span>
            }
<span class="fc" id="L2663">            jjConsumeToken(S);</span>
        }
<span class="fc bfc" id="L2665" title="All 2 branches covered.">        if (jj28(1)) {</span>
<span class="fc" id="L2666">            expr = expr();</span>
        }
<span class="fc" id="L2668">        t = jjConsumeToken(RIGHTROUND);</span>
<span class="fc" id="L2669">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L2671" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2672">                jjLa1[112] = jjGen;</span>
<span class="fc" id="L2673">                break;</span>
            }
<span class="fc" id="L2675">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L2677">        SourceCodeLocation endLocation = this.getLocation();</span>
<span class="fc" id="L2678">        CssFunctionArgumentsNode args = new CssFunctionArgumentsNode();</span>
<span class="fc bfc" id="L2679" title="All 4 branches covered.">        if (expr != null &amp;&amp; expr.numChildren() == 1) {</span>
<span class="fc" id="L2680">            CssValueNode child = expr.getChildAt(0);</span>
<span class="fc" id="L2681">            addArgumentsWithSeparator(args, ImmutableList.of(child), 1, &quot; &quot;);</span>
<span class="fc bfc" id="L2682" title="All 2 branches covered.">        } else if (expr != null) {</span>
<span class="fc" id="L2683">            addArgumentsWithSeparator(args, expr.childIterable(), expr.numChildren(),</span>
                    &quot; &quot;);
        }
<span class="fc" id="L2686">        CssFunctionNode functionNode = nodeBuilder.buildFunctionNode(</span>
<span class="fc" id="L2687">                functionName.toString(),</span>
<span class="fc" id="L2688">                this.mergeLocations(beginLocation, endLocation), args, tokens);</span>
        {
<span class="fc" id="L2690">            return functionNode;</span>
        }
    }

    // important
//   : IMPORTANTSYM S*
//   ;
    public final CssPriorityNode important() throws ParseException {
        Token t;
<span class="fc" id="L2699">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        SourceCodeLocation beginLocation;
        SourceCodeLocation endLocation;
<span class="fc" id="L2702">        t = jjConsumeToken(IMPORTANT_SYM);</span>
<span class="fc" id="L2703">        beginLocation = this.getLocation();</span>
<span class="fc" id="L2704">        endLocation = this.getLocation();</span>
<span class="fc" id="L2705">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L2707" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2708">                jjLa1[113] = jjGen;</span>
<span class="fc" id="L2709">                break;</span>
            }
<span class="fc" id="L2711">            jjConsumeToken(S);</span>
        }
        {
<span class="fc" id="L2714">            return nodeBuilder.buildPriorityNode(this.mergeLocations(beginLocation, endLocation), tokens);</span>
        }
    }

    // (non-standard GSS extension)
// atRule
//   : ATKEYWORD S* [ [ compositeTerm | extendedTerm ] S* ]*
//     [ [ '{' S* block  '}'  ] | ';' ] S*
//   ;
    public final CssAtRuleNode atRule() throws ParseException {
        Token t;
        SourceCodeLocation beginLocation;
        CssLiteralNode name;
        CssValueNode v;
<span class="fc" id="L2728">        CssBlockNode block = null;</span>
<span class="fc" id="L2729">        List&lt;CssValueNode&gt; parameters = Lists.newArrayList();</span>
<span class="fc" id="L2730">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        try {
<span class="fc" id="L2732">            t = jjConsumeToken(ATKEYWORD);</span>
<span class="fc" id="L2733">            beginLocation = this.getLocation(t);</span>
<span class="fc" id="L2734">            name = new CssLiteralNode(t.image.substring(1), beginLocation);</span>
<span class="fc" id="L2735">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L2737" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2738">                    jjLa1[114] = jjGen;</span>
<span class="fc" id="L2739">                    break;</span>
                }
<span class="fc" id="L2741">                jjConsumeToken(S);</span>
            }
<span class="fc bfc" id="L2743" title="All 2 branches covered.">            while (jj29(1)) {</span>
<span class="fc bfc" id="L2744" title="All 2 branches covered.">                if (jj210(1)) {</span>
<span class="fc" id="L2745">                    v = compositeTerm();</span>
<span class="pc bpc" id="L2746" title="1 of 2 branches missed.">                } else if (jj211(1)) {</span>
<span class="fc" id="L2747">                    v = extendedTerm();</span>
                } else {
<span class="nc" id="L2749">                    jjConsumeToken(-1);</span>
<span class="nc" id="L2750">                    throw new ParseException();</span>
                }
<span class="fc" id="L2752">                parameters.add(v);</span>
                while (true) {
<span class="pc bpc" id="L2754" title="2 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2755">                        jjLa1[115] = jjGen;</span>
<span class="fc" id="L2756">                        break;</span>
                    }
<span class="nc" id="L2758">                    jjConsumeToken(S);</span>
                }
            }
<span class="fc" id="L2761">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L2762" title="2 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L2763">                throw e;</span>
            }
<span class="fc bfc" id="L2765" title="All 2 branches covered.">            if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="fc" id="L2766">                skipComponentValuesToAfter(RIGHTBRACE);</span>
            }
            {
<span class="fc" id="L2769">                throw e;</span>
            }
<span class="fc" id="L2771">        }</span>
<span class="pc bpc" id="L2772" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case LEFTBRACE: {
<span class="fc" id="L2774">                t = jjConsumeToken(LEFTBRACE);</span>
<span class="fc" id="L2775">                tokens.add(t);</span>
                try {
                    while (true) {
<span class="pc bpc" id="L2778" title="1 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2779">                            jjLa1[116] = jjGen;</span>
<span class="fc" id="L2780">                            break;</span>
                        }
<span class="fc" id="L2782">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L2784">                    block = block(true);</span>
<span class="fc" id="L2785">                    t = jjConsumeToken(RIGHTBRACE);</span>
<span class="fc" id="L2786">                    tokens.add(t);</span>
<span class="nc" id="L2787">                } catch (ParseException e) {</span>
<span class="nc bnc" id="L2788" title="All 4 branches missed.">                    if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L2789">                        throw e;</span>
                    }
<span class="nc" id="L2791">                    skipComponentValuesToAfter(RIGHTBRACE);</span>
                    {
<span class="nc" id="L2793">                        throw e;</span>
                    }
<span class="fc" id="L2795">                }</span>
                break;
            }
            case SEMICOLON: {
<span class="fc" id="L2799">                t = jjConsumeToken(SEMICOLON);</span>
<span class="fc" id="L2800">                tokens.add(t);</span>
<span class="fc" id="L2801">                break;</span>
            }
            default:
<span class="nc" id="L2804">                jjLa1[117] = jjGen;</span>
<span class="nc" id="L2805">                ParseException e = generateParseException();</span>
<span class="nc bnc" id="L2806" title="All 4 branches missed.">                if (enableErrorRecovery &amp;&amp; e.currentToken != null) {</span>
<span class="nc bnc" id="L2807" title="All 2 branches missed.">                    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="nc" id="L2808">                        skipComponentValuesToAfter(RIGHTBRACE);</span>
                    }
                }
            {
<span class="nc" id="L2812">                throw e;</span>
            }
        }
<span class="fc" id="L2815">        SourceCodeLocation endLocation = getLocation(t);</span>
<span class="fc" id="L2816">        CssAtRuleNode at = nodeBuilder.buildUnknownAtRuleNode(name, block,</span>
<span class="fc" id="L2817">                this.mergeLocations(beginLocation, endLocation), parameters, tokens);</span>
        {
<span class="fc" id="L2819">            return at;</span>
        }
    }

    // (non-standard GSS extension)
// atRuleWithDeclBlock
//   : ATRULESWITHDECLBLOCK S*
//     [  atFunction
//      | [ IDENT? ':' IDENT S* ]
//      | [ [ compositeTerm | extendedTerm ] S* ]*
//     ]
//     [ [ '{' S* styleDeclaration '}  ] | ';' ] S*
//   ;
// TODO(fbenz): Try to reuse selctor parsing instead of [ IDENT? ':' IDENT S* ].
// The problem is that @-rules take a list of value nodes and selectors are not
// value nodes.
    public final CssAtRuleNode atRuleWithDeclBlock() throws ParseException {
        Token t;
        SourceCodeLocation beginLocation;
        CssLiteralNode name;
        CssValueNode v;
<span class="fc" id="L2840">        CssAbstractBlockNode block = null;</span>
<span class="fc" id="L2841">        List&lt;CssValueNode&gt; parameters = Lists.newArrayList();</span>
<span class="fc" id="L2842">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2843">        List&lt;Token&gt; pseudoPageTokens = Lists.newArrayList();</span>
        try {
<span class="fc" id="L2845">            t = jjConsumeToken(ATRULESWITHDECLBLOCK);</span>
<span class="fc" id="L2846">            beginLocation = this.getLocation(t);</span>
<span class="fc" id="L2847">            name = new CssLiteralNode(t.image.substring(1), beginLocation);</span>
<span class="fc" id="L2848">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L2850" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2851">                    jjLa1[118] = jjGen;</span>
<span class="fc" id="L2852">                    break;</span>
                }
<span class="fc" id="L2854">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L2856" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) == FUNCTION) {</span>
<span class="fc" id="L2857">                v = atFunction();</span>
<span class="fc" id="L2858">                parameters.add(v);</span>
            } else {
<span class="fc" id="L2860">                jjLa1[122] = jjGen;</span>
<span class="fc bfc" id="L2861" title="All 2 branches covered.">                if (jj215(1)) {</span>
<span class="pc bpc" id="L2862" title="1 of 4 branches missed.">                    if (getToken(1).kind != COLON &amp;&amp; getToken(2).kind != COLON) {</span>
<span class="nc" id="L2863">                        jjConsumeToken(-1);</span>
<span class="nc" id="L2864">                        throw new ParseException();</span>
                    }
<span class="pc bpc" id="L2866" title="1 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) == IDENTIFIER) {</span>
<span class="fc" id="L2867">                        t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L2868">                        pseudoPageTokens.add(t);</span>
<span class="fc" id="L2869">                        v = nodeBuilder.buildLiteralNode(t.image, getLocation(t), pseudoPageTokens);</span>
<span class="fc" id="L2870">                        parameters.add(v);</span>
<span class="fc" id="L2871">                        pseudoPageTokens.clear();</span>
                    } else {
<span class="fc" id="L2873">                        jjLa1[119] = jjGen;</span>
                    }
<span class="fc" id="L2875">                    t = jjConsumeToken(COLON);</span>
<span class="fc" id="L2876">                    pseudoPageTokens.add(t);</span>
<span class="fc" id="L2877">                    t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L2878">                    pseudoPageTokens.add(t);</span>
<span class="fc" id="L2879">                    v = nodeBuilder.buildLiteralNode(&quot;:&quot; + t.image, getLocation(t), pseudoPageTokens);</span>
<span class="fc" id="L2880">                    parameters.add(v);</span>
                    while (true) {
<span class="pc bpc" id="L2882" title="1 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2883">                            jjLa1[120] = jjGen;</span>
<span class="fc" id="L2884">                            break;</span>
                        }
<span class="fc" id="L2886">                        jjConsumeToken(S);</span>
                    }
                } else {
<span class="fc bfc" id="L2889" title="All 2 branches covered.">                    while (jj212(1)) {</span>
<span class="pc bpc" id="L2890" title="1 of 2 branches missed.">                        if (jj213(1)) {</span>
<span class="fc" id="L2891">                            v = compositeTerm();</span>
<span class="nc bnc" id="L2892" title="All 2 branches missed.">                        } else if (jj214(1)) {</span>
<span class="nc" id="L2893">                            v = extendedTerm();</span>
                        } else {
<span class="nc" id="L2895">                            jjConsumeToken(-1);</span>
<span class="nc" id="L2896">                            throw new ParseException();</span>
                        }
<span class="fc" id="L2898">                        parameters.add(v);</span>
                        while (true) {
<span class="pc bpc" id="L2900" title="2 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2901">                                jjLa1[121] = jjGen;</span>
<span class="fc" id="L2902">                                break;</span>
                            }
<span class="nc" id="L2904">                            jjConsumeToken(S);</span>
                        }
                    }
                }
            }
<span class="fc" id="L2909">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L2910" title="3 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L2911">                throw e;</span>
            }
<span class="nc bnc" id="L2913" title="All 2 branches missed.">            if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="nc" id="L2914">                skipComponentValuesToAfter(RIGHTBRACE);</span>
            }
            {
<span class="nc" id="L2917">                throw e;</span>
            }
<span class="fc" id="L2919">        }</span>
<span class="pc bpc" id="L2920" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case LEFTBRACE: {
<span class="fc" id="L2922">                t = jjConsumeToken(LEFTBRACE);</span>
<span class="fc" id="L2923">                tokens.add(t);</span>
                try {
                    while (true) {
<span class="pc bpc" id="L2926" title="1 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2927">                            jjLa1[123] = jjGen;</span>
<span class="fc" id="L2928">                            break;</span>
                        }
<span class="fc" id="L2930">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L2932">                    block = styleDeclaration();</span>
<span class="fc" id="L2933">                    t = jjConsumeToken(RIGHTBRACE);</span>
<span class="fc" id="L2934">                    tokens.add(t);</span>
<span class="nc" id="L2935">                } catch (ParseException e) {</span>
<span class="nc bnc" id="L2936" title="All 4 branches missed.">                    if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L2937">                        throw e;</span>
                    }
<span class="nc" id="L2939">                    skipComponentValuesToAfter(RIGHTBRACE);</span>
                    {
<span class="nc" id="L2941">                        throw e;</span>
                    }
<span class="fc" id="L2943">                }</span>
                break;
            }
            case SEMICOLON: {
<span class="fc" id="L2947">                t = jjConsumeToken(SEMICOLON);</span>
<span class="fc" id="L2948">                tokens.add(t);</span>
<span class="fc" id="L2949">                break;</span>
            }
            default:
<span class="nc" id="L2952">                jjLa1[124] = jjGen;</span>
<span class="nc" id="L2953">                ParseException e = generateParseException();</span>
<span class="nc bnc" id="L2954" title="All 4 branches missed.">                if (enableErrorRecovery &amp;&amp; e.currentToken != null) {</span>
<span class="nc bnc" id="L2955" title="All 2 branches missed.">                    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="nc" id="L2956">                        skipComponentValuesToAfter(RIGHTBRACE);</span>
                    }
                }
            {
<span class="nc" id="L2960">                throw e;</span>
            }
        }
<span class="fc" id="L2963">        SourceCodeLocation endLocation = getLocation(t);</span>
<span class="fc" id="L2964">        CssAtRuleNode at = nodeBuilder.buildUnknownAtRuleNode(name, block,</span>
<span class="fc" id="L2965">                this.mergeLocations(beginLocation, endLocation), parameters, tokens);</span>
        {
<span class="fc" id="L2967">            return at;</span>
        }
    }

    // (non-standard GSS extension)
// innerAtRule
//   : ATKEYWORD S*
//    [  atFunction
//     | [ IDENT? ':' IDENT S* ]
//     | [[ compositeTerm | extendedTerm ] S* ]*
//    ]
//    [ [ '{' S* styleDeclaration '} ] | ';' ] S*
//   ;
    public final CssAtRuleNode innerAtRule() throws ParseException {
        Token t;
        SourceCodeLocation beginLocation;
        CssLiteralNode name;
        CssValueNode v;
<span class="fc" id="L2985">        CssAbstractBlockNode block = null;</span>
<span class="fc" id="L2986">        List&lt;CssValueNode&gt; parameters = Lists.newArrayList();</span>
<span class="fc" id="L2987">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
<span class="fc" id="L2988">        List&lt;Token&gt; pseudoPageTokens = Lists.newArrayList();</span>
        try {
<span class="fc" id="L2990">            t = jjConsumeToken(ATKEYWORD);</span>
<span class="fc" id="L2991">            beginLocation = this.getLocation(t);</span>
<span class="fc" id="L2992">            name = new CssLiteralNode(t.image.substring(1), beginLocation);</span>
<span class="fc" id="L2993">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L2995" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L2996">                    jjLa1[125] = jjGen;</span>
<span class="fc" id="L2997">                    break;</span>
                }
<span class="fc" id="L2999">                jjConsumeToken(S);</span>
            }
<span class="pc bpc" id="L3001" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) == FUNCTION) {</span>
<span class="fc" id="L3002">                v = atFunction();</span>
<span class="fc" id="L3003">                parameters.add(v);</span>
            } else {
<span class="fc" id="L3005">                jjLa1[129] = jjGen;</span>
<span class="fc bfc" id="L3006" title="All 2 branches covered.">                if (jj219(1)) {</span>
<span class="pc bpc" id="L3007" title="2 of 4 branches missed.">                    if (getToken(1).kind != COLON &amp;&amp; getToken(2).kind != COLON) {</span>
<span class="nc" id="L3008">                        jjConsumeToken(-1);</span>
<span class="nc" id="L3009">                        throw new ParseException();</span>
                    }
<span class="pc bpc" id="L3011" title="2 of 4 branches missed.">                    if (((jjNtk == -1) ? jjNtkF() : jjNtk) == IDENTIFIER) {</span>
<span class="fc" id="L3012">                        t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L3013">                        pseudoPageTokens.add(t);</span>
<span class="fc" id="L3014">                        v = nodeBuilder.buildLiteralNode(t.image, getLocation(t), pseudoPageTokens);</span>
<span class="fc" id="L3015">                        parameters.add(v);</span>
<span class="fc" id="L3016">                        pseudoPageTokens.clear();</span>
                    } else {
<span class="nc" id="L3018">                        jjLa1[126] = jjGen;</span>
                    }
<span class="fc" id="L3020">                    t = jjConsumeToken(COLON);</span>
<span class="fc" id="L3021">                    pseudoPageTokens.add(t);</span>
<span class="nc" id="L3022">                    t = jjConsumeToken(IDENTIFIER);</span>
<span class="nc" id="L3023">                    pseudoPageTokens.add(t);</span>
<span class="nc" id="L3024">                    v = nodeBuilder.buildLiteralNode(&quot;:&quot; + t.image, getLocation(t), pseudoPageTokens);</span>
<span class="nc" id="L3025">                    parameters.add(v);</span>
                    while (true) {
<span class="nc bnc" id="L3027" title="All 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="nc" id="L3028">                            jjLa1[127] = jjGen;</span>
<span class="nc" id="L3029">                            break;</span>
                        }
<span class="nc" id="L3031">                        jjConsumeToken(S);</span>
                    }
                } else {
<span class="fc bfc" id="L3034" title="All 2 branches covered.">                    while (jj216(1)) {</span>
<span class="pc bpc" id="L3035" title="1 of 2 branches missed.">                        if (jj217(1)) {</span>
<span class="fc" id="L3036">                            v = compositeTerm();</span>
<span class="nc bnc" id="L3037" title="All 2 branches missed.">                        } else if (jj218(1)) {</span>
<span class="nc" id="L3038">                            v = extendedTerm();</span>
                        } else {
<span class="nc" id="L3040">                            jjConsumeToken(-1);</span>
<span class="nc" id="L3041">                            throw new ParseException();</span>
                        }
<span class="fc" id="L3043">                        parameters.add(v);</span>
                        while (true) {
<span class="pc bpc" id="L3045" title="2 of 4 branches missed.">                            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3046">                                jjLa1[128] = jjGen;</span>
<span class="fc" id="L3047">                                break;</span>
                            }
<span class="nc" id="L3049">                            jjConsumeToken(S);</span>
                        }
                    }
                }
            }
<span class="fc" id="L3054">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L3055" title="2 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L3056">                throw e;</span>
            }
<span class="pc bpc" id="L3058" title="1 of 2 branches missed.">            if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="nc" id="L3059">                skipComponentValuesToAfter(RIGHTBRACE);</span>
            }
            {
<span class="fc" id="L3062">                throw e;</span>
            }
<span class="fc" id="L3064">        }</span>
<span class="pc bpc" id="L3065" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case LEFTBRACE: {
<span class="fc" id="L3067">                t = jjConsumeToken(LEFTBRACE);</span>
<span class="fc" id="L3068">                tokens.add(t);</span>
                try {
                    while (true) {
<span class="pc bpc" id="L3071" title="1 of 4 branches missed.">                        if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3072">                            jjLa1[130] = jjGen;</span>
<span class="fc" id="L3073">                            break;</span>
                        }
<span class="fc" id="L3075">                        jjConsumeToken(S);</span>
                    }
<span class="fc" id="L3077">                    block = styleDeclaration();</span>
<span class="fc" id="L3078">                    t = jjConsumeToken(RIGHTBRACE);</span>
<span class="fc" id="L3079">                    tokens.add(t);</span>
<span class="nc" id="L3080">                } catch (ParseException e) {</span>
<span class="nc bnc" id="L3081" title="All 4 branches missed.">                    if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L3082">                        throw e;</span>
                    }
<span class="nc" id="L3084">                    skipComponentValuesToAfter(RIGHTBRACE);</span>
                    {
<span class="nc" id="L3086">                        throw e;</span>
                    }
<span class="fc" id="L3088">                }</span>
                break;
            }
            case SEMICOLON: {
<span class="fc" id="L3092">                t = jjConsumeToken(SEMICOLON);</span>
<span class="fc" id="L3093">                tokens.add(t);</span>
<span class="fc" id="L3094">                break;</span>
            }
            default:
<span class="nc" id="L3097">                jjLa1[131] = jjGen;</span>
<span class="nc" id="L3098">                ParseException e = generateParseException();</span>
<span class="nc bnc" id="L3099" title="All 4 branches missed.">                if (enableErrorRecovery &amp;&amp; e.currentToken != null) {</span>
<span class="nc bnc" id="L3100" title="All 2 branches missed.">                    if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="nc" id="L3101">                        skipComponentValuesToAfter(RIGHTBRACE);</span>
                    }
                }
            {
<span class="nc" id="L3105">                throw e;</span>
            }
        }
<span class="fc" id="L3108">        SourceCodeLocation endLocation = getLocation(t);</span>
<span class="fc" id="L3109">        CssAtRuleNode at = nodeBuilder.buildUnknownAtRuleNode(name, block,</span>
<span class="fc" id="L3110">                this.mergeLocations(beginLocation, endLocation), parameters, tokens);</span>
        {
<span class="fc" id="L3112">            return at;</span>
        }
    }

    // (WebKit specific extension. We need a separate rule for the
//  WebKit keyframes, because they don't follow the standard grammar exactly.)
// webkitKeyframesRule
//   : '@-webkit-keyframes' S* IDENTIFIER S*
//     '{' S* webkitKeyframesBlock  '}'*
//   ;
    public final CssAtRuleNode webkitKeyframesRule() throws ParseException {
        Token t;
        SourceCodeLocation beginLocation;
        CssLiteralNode name;
        CssBlockNode block;
<span class="fc" id="L3127">        List&lt;CssValueNode&gt; parameters = Lists.newArrayList();</span>
<span class="fc" id="L3128">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        try {
<span class="fc" id="L3130">            t = jjConsumeToken(WEBKITKEYFRAMES);</span>
<span class="fc" id="L3131">            beginLocation = this.getLocation(t);</span>
<span class="fc" id="L3132">            name = new CssLiteralNode(t.image.substring(1), beginLocation);</span>
<span class="fc" id="L3133">            tokens.add(t);</span>
            while (true) {
<span class="pc bpc" id="L3135" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3136">                    jjLa1[132] = jjGen;</span>
<span class="fc" id="L3137">                    break;</span>
                }
<span class="fc" id="L3139">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L3141">            t = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L3142">            List&lt;Token&gt; identifierTokens = Lists.newArrayList();</span>
<span class="fc" id="L3143">            identifierTokens.add(t);</span>
<span class="fc" id="L3144">            CssLiteralNode l =</span>
<span class="fc" id="L3145">                    nodeBuilder.buildLiteralNode(t.image, getLocation(t), identifierTokens);</span>
<span class="fc" id="L3146">            parameters.add(l);</span>
            while (true) {
<span class="pc bpc" id="L3148" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3149">                    jjLa1[133] = jjGen;</span>
<span class="fc" id="L3150">                    break;</span>
                }
<span class="fc" id="L3152">                jjConsumeToken(S);</span>
            }
<span class="nc" id="L3154">        } catch (ParseException e) {</span>
<span class="nc bnc" id="L3155" title="All 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L3156">                throw e;</span>
            }
<span class="nc bnc" id="L3158" title="All 2 branches missed.">            if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="nc" id="L3159">                skipComponentValuesToAfter(RIGHTBRACE);</span>
            }
            {
<span class="nc" id="L3162">                throw e;</span>
            }
<span class="fc" id="L3164">        }</span>
<span class="fc" id="L3165">        t = jjConsumeToken(LEFTBRACE);</span>
<span class="fc" id="L3166">        tokens.add(t);</span>
        try {
            while (true) {
<span class="pc bpc" id="L3169" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3170">                    jjLa1[134] = jjGen;</span>
<span class="fc" id="L3171">                    break;</span>
                }
<span class="fc" id="L3173">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L3175">            block = webkitKeyframesBlock();</span>
<span class="fc" id="L3176">            t = jjConsumeToken(RIGHTBRACE);</span>
<span class="fc" id="L3177">            tokens.add(t);</span>
<span class="fc" id="L3178">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L3179" title="3 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L3180">                throw e;</span>
            }
<span class="nc" id="L3182">            skipComponentValuesToAfter(RIGHTBRACE);</span>
            {
<span class="nc" id="L3184">                throw e;</span>
            }
<span class="fc" id="L3186">        }</span>
<span class="fc" id="L3187">        SourceCodeLocation endLocation = getLocation(t);</span>
<span class="fc" id="L3188">        CssAtRuleNode at = nodeBuilder.buildWebkitKeyframesNode(name, block,</span>
<span class="fc" id="L3189">                this.mergeLocations(beginLocation, endLocation), parameters, tokens);</span>
        {
<span class="fc" id="L3191">            return at;</span>
        }
    }

    // (WebKit specific extension)
// webkitKeyframesBlock
//   : [ webkitKeyframeRuleset S* ]*
//   ;
    public final CssBlockNode webkitKeyframesBlock() throws ParseException {
        CssBlockNode block;
        CssNode n;
<span class="fc" id="L3202">        block = new CssBlockNode(true);</span>
        while (true) {
<span class="pc bpc" id="L3204" title="1 of 2 branches missed.">            int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="fc bfc" id="L3205" title="All 4 branches covered.">            if (i != NUMBER &amp;&amp; i != IDENTIFIER) {</span>
<span class="fc" id="L3206">                jjLa1[135] = jjGen;</span>
<span class="fc" id="L3207">                break;</span>
            }
<span class="fc" id="L3209">            n = webkitKeyframeRuleSet();</span>
<span class="fc" id="L3210">            block.addChildToBack(n);</span>
            while (true) {
<span class="pc bpc" id="L3212" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3213">                    jjLa1[136] = jjGen;</span>
<span class="fc" id="L3214">                    break;</span>
                }
<span class="fc" id="L3216">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L3218">        }</span>
        {
<span class="fc" id="L3220">            return block;</span>
        }
    }

    // (WebKit specific extension)
// webkitKeyframeRuleset
//   : keyList '{' styleDeclarations '}'
//   ;
    public final CssKeyframeRulesetNode webkitKeyframeRuleSet() throws ParseException {
        CssKeyListNode keys;
        CssDeclarationBlockNode declarations;
        Token t;
<span class="fc" id="L3232">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        try {
<span class="fc" id="L3234">            keys = keyList();</span>
<span class="fc" id="L3235">            t = jjConsumeToken(LEFTBRACE);</span>
<span class="fc" id="L3236">            tokens.add(t);</span>
<span class="fc" id="L3237">        } catch (ParseException e) {</span>
<span class="pc bpc" id="L3238" title="3 of 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L3239">                throw e;</span>
            }
<span class="nc bnc" id="L3241" title="All 2 branches missed.">            if (skipComponentValuesToAfter(SEMICOLON, LEFTBRACE) == LEFTBRACE) {</span>
<span class="nc" id="L3242">                skipComponentValuesToAfter(RIGHTBRACE);</span>
            }
            {
<span class="nc" id="L3245">                throw e;</span>
            }
<span class="fc" id="L3247">        }</span>
        try {
<span class="fc" id="L3249">            declarations = styleDeclaration();</span>
<span class="fc" id="L3250">            t = jjConsumeToken(RIGHTBRACE);</span>
<span class="fc" id="L3251">            tokens.add(t);</span>
<span class="nc" id="L3252">        } catch (ParseException e) {</span>
<span class="nc bnc" id="L3253" title="All 4 branches missed.">            if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="nc" id="L3254">                throw e;</span>
            }
<span class="nc" id="L3256">            skipComponentValuesToAfter(RIGHTBRACE);</span>
            {
<span class="nc" id="L3258">                throw e;</span>
            }
<span class="fc" id="L3260">        }</span>
<span class="fc" id="L3261">        CssKeyframeRulesetNode ruleSet =</span>
<span class="fc" id="L3262">                nodeBuilder.buildKeyframeRulesetNode(declarations, keys, tokens);</span>
        {
<span class="fc" id="L3264">            return ruleSet;</span>
        }
    }

    // (WebKit specific extension)
// keyList
//   : key [ ',' S* key ]*
//   ;
    public final CssKeyListNode keyList() throws ParseException {
<span class="fc" id="L3273">        CssKeyListNode list = new CssKeyListNode();</span>
        CssKeyNode key;
        Token t;
<span class="fc" id="L3276">        key = key();</span>
<span class="fc" id="L3277">        list.addChildToBack(key);</span>
        while (true) {
<span class="pc bpc" id="L3279" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != COMMA) {</span>
<span class="fc" id="L3280">                jjLa1[137] = jjGen;</span>
<span class="fc" id="L3281">                break;</span>
            }
<span class="fc" id="L3283">            t = jjConsumeToken(COMMA);</span>
<span class="fc" id="L3284">            nodeBuilder.attachComment(t, key);</span>
            while (true) {
<span class="pc bpc" id="L3286" title="1 of 4 branches missed.">                if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3287">                    jjLa1[138] = jjGen;</span>
<span class="fc" id="L3288">                    break;</span>
                }
<span class="fc" id="L3290">                jjConsumeToken(S);</span>
            }
<span class="fc" id="L3292">            key = key();</span>
<span class="fc" id="L3293">            list.addChildToBack(key);</span>
        }
        {
<span class="fc" id="L3296">            return list;</span>
        }
    }

    // (WebKit specific extension)
// key
//   : PERCENTAGE | IDENTIFIER
//   ;
    public final CssKeyNode key() throws ParseException {
        Token key, t, dim;
        String value;
<span class="fc" id="L3307">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        SourceCodeLocation beginLocation;
<span class="fc" id="L3309">        beginLocation = this.getLocation(token.next);</span>
<span class="pc bpc" id="L3310" title="2 of 5 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case NUMBER: {
<span class="fc" id="L3312">                key = jjConsumeToken(NUMBER);</span>
<span class="fc" id="L3313">                tokens.add(key);</span>
<span class="fc" id="L3314">                dim = jjConsumeToken(PERCENT);</span>
<span class="fc" id="L3315">                tokens.add(dim);</span>
<span class="fc" id="L3316">                value = key.image + dim.image;</span>
<span class="fc" id="L3317">                break;</span>
            }
            case IDENTIFIER: {
<span class="fc" id="L3320">                key = jjConsumeToken(IDENTIFIER);</span>
<span class="fc" id="L3321">                tokens.add(key);</span>
<span class="fc" id="L3322">                value = key.image;</span>
<span class="fc" id="L3323">                break;</span>
            }
            default:
<span class="nc" id="L3326">                jjLa1[139] = jjGen;</span>
<span class="nc" id="L3327">                jjConsumeToken(-1);</span>
<span class="nc" id="L3328">                throw new ParseException();</span>
        }
        while (true) {
<span class="pc bpc" id="L3331" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3332">                jjLa1[140] = jjGen;</span>
<span class="fc" id="L3333">                break;</span>
            }
<span class="fc" id="L3335">            t = jjConsumeToken(S);</span>
<span class="fc" id="L3336">            tokens.add(t);</span>
        }
<span class="fc" id="L3338">        SourceCodeLocation endLocation = this.getLocation();</span>
<span class="fc" id="L3339">        CssKeyNode keyNode = nodeBuilder.buildKeyNode(key, value,</span>
<span class="fc" id="L3340">                this.mergeLocations(beginLocation, endLocation));</span>
<span class="fc" id="L3341">        nodeBuilder.attachComments(tokens, keyNode);</span>
        {
<span class="fc" id="L3343">            return keyNode;</span>
        }
    }

    // (non-standard GSS extension)
// block
//   : [ [  ruleset | atRule | webkitKeyframesRule
//        | atRuleWithDeclBlock
//       ] S*
//     ]*
//   ;
    public final CssBlockNode block(boolean isEnclosedWithBraces) throws ParseException {
        CssBlockNode block;
        CssNode n;
<span class="fc bfc" id="L3357" title="All 2 branches covered.">        if (isEnclosedWithBraces) {</span>
<span class="fc" id="L3358">            block = new CssBlockNode(isEnclosedWithBraces);</span>
        } else {
<span class="fc" id="L3360">            block = globalBlock;</span>
        }
        while (true) {
<span class="pc bpc" id="L3363" title="1 of 2 branches missed.">            int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="pc bpc" id="L3364" title="1 of 20 branches missed.">            if (i != COLON &amp;&amp; i != DOT &amp;&amp; i != ASTERISK &amp;&amp; i != LEFTSQUARE &amp;&amp; i != HASH_NAME &amp;&amp; i != IDENTIFIER &amp;&amp; i != ATLIST &amp;&amp; i != WEBKITKEYFRAMES &amp;&amp; i != ATRULESWITHDECLBLOCK &amp;&amp; i != ATKEYWORD) {</span>
<span class="fc" id="L3365">                jjLa1[141] = jjGen;</span>
<span class="fc" id="L3366">                break;</span>
            }
            try {
<span class="pc bpc" id="L3369" title="1 of 4 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case COLON:
                    case DOT:
                    case ASTERISK:
                    case LEFTSQUARE:
                    case HASH_NAME:
                    case IDENTIFIER: {
<span class="fc" id="L3376">                        n = ruleSet();</span>
<span class="fc" id="L3377">                        break;</span>
                    }
                    default:
<span class="fc" id="L3380">                        jjLa1[142] = jjGen;</span>
<span class="fc bfc" id="L3381" title="All 2 branches covered.">                        if (jj220(2147483647)) {</span>
<span class="fc" id="L3382">                            n = atRuleWithCrazySyntax();</span>
                        } else {
<span class="pc bpc" id="L3384" title="2 of 6 branches missed.">                            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                                case ATKEYWORD: {
<span class="fc" id="L3386">                                    n = atRule();</span>
<span class="fc" id="L3387">                                    break;</span>
                                }
                                case WEBKITKEYFRAMES: {
<span class="fc" id="L3390">                                    n = webkitKeyframesRule();</span>
<span class="fc" id="L3391">                                    break;</span>
                                }
                                case ATRULESWITHDECLBLOCK: {
<span class="fc" id="L3394">                                    n = atRuleWithDeclBlock();</span>
<span class="fc" id="L3395">                                    break;</span>
                                }
                                default:
<span class="nc" id="L3398">                                    jjLa1[143] = jjGen;</span>
<span class="nc" id="L3399">                                    jjConsumeToken(-1);</span>
<span class="nc" id="L3400">                                    throw new ParseException();</span>
                            }
                        }
                }
<span class="fc" id="L3404">                block.addChildToBack(n);</span>
<span class="fc" id="L3405">            } catch (ParseException e) {</span>
<span class="pc bpc" id="L3406" title="1 of 4 branches missed.">                if (!enableErrorRecovery || e.currentToken == null) {</span>
<span class="fc" id="L3407">                    throw e;</span>
                }
<span class="fc" id="L3409">                handledErrors.add(new GssParserException(getLocation(e.currentToken.next), e));</span>
<span class="fc" id="L3410">            }</span>
            while (true) {
<span class="fc bfc" id="L3412" title="All 2 branches covered.">                int j = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="pc bpc" id="L3413" title="1 of 6 branches missed.">                if (j != CDO &amp;&amp; j != CDC &amp;&amp; j != S) {</span>
<span class="fc" id="L3414">                    jjLa1[144] = jjGen;</span>
<span class="fc" id="L3415">                    break;</span>
                }
<span class="pc bpc" id="L3417" title="3 of 6 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case S: {
<span class="fc" id="L3419">                        jjConsumeToken(S);</span>
<span class="fc" id="L3420">                        break;</span>
                    }
                    case CDO: {
<span class="nc" id="L3423">                        jjConsumeToken(CDO);</span>
<span class="nc" id="L3424">                        break;</span>
                    }
                    case CDC: {
<span class="fc" id="L3427">                        jjConsumeToken(CDC);</span>
<span class="fc" id="L3428">                        break;</span>
                    }
                    default:
<span class="nc" id="L3431">                        jjLa1[145] = jjGen;</span>
<span class="nc" id="L3432">                        jjConsumeToken(-1);</span>
<span class="nc" id="L3433">                        throw new ParseException();</span>
                }
<span class="fc" id="L3435">            }</span>
<span class="fc" id="L3436">        }</span>
        {
<span class="fc" id="L3438">            return block;</span>
        }
    }

    public final void start() throws ParseException {
        while (true) {
<span class="pc bpc" id="L3444" title="1 of 2 branches missed.">            int i = (jjNtk == -1) ? jjNtkF() : jjNtk;</span>
<span class="pc bpc" id="L3445" title="1 of 6 branches missed.">            if (i != CDO &amp;&amp; i != CDC &amp;&amp; i != S) {</span>
<span class="fc" id="L3446">                jjLa1[146] = jjGen;</span>
<span class="fc" id="L3447">                break;</span>
            }
<span class="pc bpc" id="L3449" title="3 of 6 branches missed.">            switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                case S: {
<span class="fc" id="L3451">                    jjConsumeToken(S);</span>
<span class="fc" id="L3452">                    break;</span>
                }
                case CDO: {
<span class="fc" id="L3455">                    jjConsumeToken(CDO);</span>
<span class="fc" id="L3456">                    break;</span>
                }
                case CDC: {
<span class="nc" id="L3459">                    jjConsumeToken(CDC);</span>
<span class="nc" id="L3460">                    break;</span>
                }
                default:
<span class="nc" id="L3463">                    jjLa1[147] = jjGen;</span>
<span class="nc" id="L3464">                    jjConsumeToken(-1);</span>
<span class="nc" id="L3465">                    throw new ParseException();</span>
            }
<span class="fc" id="L3467">        }</span>
<span class="fc" id="L3468">        block(false);</span>
<span class="fc" id="L3469">        jjConsumeToken(0);</span>
        try {
<span class="fc" id="L3471">            validateFinalBlockCommentIfPresent();</span>
<span class="fc" id="L3472">        } catch (ParseException e) {</span>
<span class="fc bfc" id="L3473" title="All 2 branches covered.">            if (!enableErrorRecovery) {</span>
<span class="fc" id="L3474">                throw e;</span>
            }
<span class="fc" id="L3476">            handledErrors.add(new GssParserException(getLocation(), e));</span>
<span class="fc" id="L3477">        }</span>
<span class="fc" id="L3478">    }</span>

    // CSS3 has very few syntactic constraints on at-rules. We shouldn't let
// our inability to understand the details of future or non-standard at-rules
// prevent us from parsing the rest of the stylesheet.
// atRuleWithCrazySyntax
//   : ATKEYWORD S* [^;{] LOOKAHEAD( ( ';' | &lt;?LEFTBRACE&gt; ) ) ';'?
    public final CssAtRuleNode atRuleWithCrazySyntax() throws ParseException {
        Token t;
        String s;
        SourceCodeLocation beginLocation;
        CssLiteralNode name;
        CssLiteralNode nonBlockContent;
<span class="fc" id="L3491">        CssLiteralNode blockishContent = null;</span>
<span class="fc" id="L3492">        List&lt;Token&gt; tokens = Lists.newArrayList();</span>
        SourceCodeLocation endLocation;
        // Don't add more special cases like this one and the webkit keyframes
        // one. If you want to support a new block type that follows the CSS 2.1
        // and 3 grammars and doesn't quite fit into the traditional GssParser
        // expectations, just change ATLIST below to ATKEYWORD, move the
        // use site in the block() to the bottom of its disjunction, and use
        // syntactic LOOKAHEAD(foo()) as needed for each foo() in the other choices
        // at that disjunction to ensure that the parser eventually falls back to
        // this rule. It will cost about 1.5% cpu time, but it will keep us from
        // adding any more code complexity here.
<span class="fc" id="L3503">        t = jjConsumeToken(ATLIST);</span>
<span class="fc" id="L3504">        beginLocation = this.getLocation(t);</span>
<span class="fc" id="L3505">        name = new CssLiteralNode(t.image.substring(1), beginLocation);</span>
<span class="fc" id="L3506">        tokens.add(t);</span>
        while (true) {
<span class="pc bpc" id="L3508" title="1 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3509">                jjLa1[148] = jjGen;</span>
<span class="fc" id="L3510">                break;</span>
            }
<span class="fc" id="L3512">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L3514">        s = scanCrazyContent(&quot;;{&quot;);</span>
<span class="fc" id="L3515">        nonBlockContent = new CssLiteralNode(s);</span>
<span class="fc" id="L3516">        tokens.add(t);</span>
<span class="pc bpc" id="L3517" title="2 of 4 branches missed.">        if (((jjNtk == -1) ? jjNtkF() : jjNtk) == LEFTBRACE) {</span>
<span class="fc" id="L3518">            blockishContent = crazyBlockBrace();</span>
        } else {
<span class="nc" id="L3520">            jjLa1[149] = jjGen;</span>
        }
<span class="pc bpc" id="L3522" title="1 of 4 branches missed.">        if (((jjNtk == -1) ? jjNtkF() : jjNtk) == SEMICOLON) {</span>
<span class="fc" id="L3523">            t = jjConsumeToken(SEMICOLON);</span>
<span class="fc" id="L3524">            tokens.add(t);</span>
        } else {
<span class="fc" id="L3526">            jjLa1[150] = jjGen;</span>
        }
<span class="fc" id="L3528">        endLocation = this.getLocation(tokens.get(tokens.size() - 1));</span>
<span class="fc" id="L3529">        List&lt;CssValueNode&gt; parameters = Lists.newArrayList();</span>
<span class="fc" id="L3530">        parameters.add(nonBlockContent);</span>
<span class="pc bpc" id="L3531" title="1 of 2 branches missed.">        if (blockishContent != null) {</span>
<span class="fc" id="L3532">            parameters.add(blockishContent);</span>
        }
        {
<span class="fc" id="L3535">            return nodeBuilder.buildUnknownAtRuleNode(</span>
<span class="fc" id="L3536">                    name, null, this.mergeLocations(beginLocation, endLocation),</span>
                    parameters,
                    tokens);
        }
    }

    // A last-resort, minimally-restrictive brace-delimited production.
    public final CssLiteralNode crazyBlockBrace() throws ParseException {
        Token t;
        String s;
        CssLiteralNode childContent;
<span class="fc" id="L3547">        CssLiteralNode childCrazy = null;</span>
<span class="fc" id="L3548">        StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L3549">        jjConsumeToken(LEFTBRACE);</span>
        while (true) {
<span class="pc bpc" id="L3551" title="2 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="fc" id="L3552">                jjLa1[151] = jjGen;</span>
<span class="fc" id="L3553">                break;</span>
            }
<span class="nc" id="L3555">            jjConsumeToken(S);</span>
        }
<span class="fc" id="L3557">        s = scanCrazyContent(&quot;{[()]}&quot;);</span>
<span class="fc" id="L3558">        childContent = new CssLiteralNode(s);</span>
<span class="pc bpc" id="L3559" title="1 of 4 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case LEFTSQUARE:
            case LEFTROUND:
            case LEFTBRACE: {
<span class="pc bpc" id="L3563" title="5 of 6 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case LEFTBRACE: {
<span class="nc" id="L3565">                        childCrazy = crazyBlockBrace();</span>
<span class="nc" id="L3566">                        break;</span>
                    }
                    case LEFTSQUARE: {
<span class="nc" id="L3569">                        childCrazy = crazyBlockBracket();</span>
<span class="nc" id="L3570">                        break;</span>
                    }
                    case LEFTROUND: {
<span class="nc" id="L3573">                        childCrazy = crazyBlockParen();</span>
<span class="nc" id="L3574">                        break;</span>
                    }
                    default:
<span class="nc" id="L3577">                        jjLa1[152] = jjGen;</span>
<span class="nc" id="L3578">                        jjConsumeToken(-1);</span>
<span class="nc" id="L3579">                        throw new ParseException();</span>
                }
                break;
            }
            default:
<span class="fc" id="L3584">                jjLa1[153] = jjGen;</span>
        }
<span class="fc" id="L3586">        t = jjConsumeToken(RIGHTBRACE);</span>
<span class="fc" id="L3587">        this.getLocation(t);</span>
<span class="fc" id="L3588">        result.append(&quot;{&quot;);</span>
<span class="fc" id="L3589">        result.append(childContent.getValue());</span>
<span class="pc bpc" id="L3590" title="1 of 2 branches missed.">        if (childCrazy != null) result.append(&quot; &quot;);</span>
<span class="pc bpc" id="L3591" title="1 of 2 branches missed.">        if (childCrazy != null) result.append(childCrazy.getValue());</span>
<span class="fc" id="L3592">        result.append(&quot;}&quot;);</span>
        {
<span class="fc" id="L3594">            return new CssLiteralNode(result.toString());</span>
        }
    }

    // Inside blocks, brackets, parens, and braces must be balanced.
    public final CssLiteralNode crazyBlockBracket() throws ParseException {
        Token t;
        String s;
        CssLiteralNode childContent;
<span class="fc" id="L3603">        CssLiteralNode childCrazy = null;</span>
<span class="fc" id="L3604">        StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L3605">        jjConsumeToken(LEFTSQUARE);</span>
        while (true) {
<span class="pc bpc" id="L3607" title="3 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="nc" id="L3608">                jjLa1[154] = jjGen;</span>
<span class="nc" id="L3609">                break;</span>
            }
<span class="nc" id="L3611">            jjConsumeToken(S);</span>
        }
<span class="nc" id="L3613">        s = scanCrazyContent(&quot;{[()]}&quot;);</span>
<span class="nc" id="L3614">        childContent = new CssLiteralNode(s);</span>
<span class="nc bnc" id="L3615" title="All 4 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case LEFTSQUARE:
            case LEFTROUND:
            case LEFTBRACE: {
<span class="nc bnc" id="L3619" title="All 6 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case LEFTBRACE: {
<span class="nc" id="L3621">                        childCrazy = crazyBlockBrace();</span>
<span class="nc" id="L3622">                        break;</span>
                    }
                    case LEFTSQUARE: {
<span class="nc" id="L3625">                        childCrazy = crazyBlockBracket();</span>
<span class="nc" id="L3626">                        break;</span>
                    }
                    case LEFTROUND: {
<span class="nc" id="L3629">                        childCrazy = crazyBlockParen();</span>
<span class="nc" id="L3630">                        break;</span>
                    }
                    default:
<span class="nc" id="L3633">                        jjLa1[155] = jjGen;</span>
<span class="nc" id="L3634">                        jjConsumeToken(-1);</span>
<span class="nc" id="L3635">                        throw new ParseException();</span>
                }
                break;
            }
            default:
<span class="nc" id="L3640">                jjLa1[156] = jjGen;</span>
        }
<span class="nc" id="L3642">        t = jjConsumeToken(RIGHTSQUARE);</span>
<span class="nc" id="L3643">        this.getLocation(t);</span>
<span class="nc" id="L3644">        result.append(&quot;[&quot;);</span>
<span class="nc" id="L3645">        result.append(childContent.getValue());</span>
<span class="nc bnc" id="L3646" title="All 2 branches missed.">        if (childCrazy != null) result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L3647" title="All 2 branches missed.">        if (childCrazy != null) result.append(childCrazy.getValue());</span>
<span class="nc" id="L3648">        result.append(&quot;]&quot;);</span>
        {
<span class="nc" id="L3650">            return new CssLiteralNode(result.toString());</span>
        }
    }

    // Inside blocks, brackets, parens, and braces must be balanced.
    public final CssLiteralNode crazyBlockParen() throws ParseException {
        Token t;
        String s;
        CssLiteralNode childContent;
<span class="fc" id="L3659">        CssLiteralNode childCrazy = null;</span>
<span class="fc" id="L3660">        StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L3661">        jjConsumeToken(LEFTROUND);</span>
        while (true) {
<span class="pc bpc" id="L3663" title="3 of 4 branches missed.">            if (((jjNtk == -1) ? jjNtkF() : jjNtk) != S) {</span>
<span class="nc" id="L3664">                jjLa1[157] = jjGen;</span>
<span class="nc" id="L3665">                break;</span>
            }
<span class="nc" id="L3667">            jjConsumeToken(S);</span>
        }
<span class="nc" id="L3669">        s = scanCrazyContent(&quot;{[()]}&quot;);</span>
<span class="nc" id="L3670">        childContent = new CssLiteralNode(s);</span>
<span class="nc bnc" id="L3671" title="All 4 branches missed.">        switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
            case LEFTSQUARE:
            case LEFTROUND:
            case LEFTBRACE: {
<span class="nc bnc" id="L3675" title="All 6 branches missed.">                switch ((jjNtk == -1) ? jjNtkF() : jjNtk) {</span>
                    case LEFTBRACE: {
<span class="nc" id="L3677">                        childCrazy = crazyBlockBrace();</span>
<span class="nc" id="L3678">                        break;</span>
                    }
                    case LEFTSQUARE: {
<span class="nc" id="L3681">                        childCrazy = crazyBlockBracket();</span>
<span class="nc" id="L3682">                        break;</span>
                    }
                    case LEFTROUND: {
<span class="nc" id="L3685">                        childCrazy = crazyBlockParen();</span>
<span class="nc" id="L3686">                        break;</span>
                    }
                    default:
<span class="nc" id="L3689">                        jjLa1[158] = jjGen;</span>
<span class="nc" id="L3690">                        jjConsumeToken(-1);</span>
<span class="nc" id="L3691">                        throw new ParseException();</span>
                }
                break;
            }
            default:
<span class="nc" id="L3696">                jjLa1[159] = jjGen;</span>
        }
<span class="nc" id="L3698">        t = jjConsumeToken(RIGHTROUND);</span>
<span class="nc" id="L3699">        this.getLocation(t);</span>
<span class="nc" id="L3700">        result.append(&quot;(&quot;);</span>
<span class="nc" id="L3701">        result.append(childContent.getValue());</span>
<span class="nc bnc" id="L3702" title="All 2 branches missed.">        if (childCrazy != null) result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L3703" title="All 2 branches missed.">        if (childCrazy != null) result.append(childCrazy.getValue());</span>
<span class="nc" id="L3704">        result.append(&quot;)&quot;);</span>
        {
<span class="nc" id="L3706">            return new CssLiteralNode(result.toString());</span>
        }
    }

    String scanCrazyContent(String endChars) throws ParseException {
<span class="fc" id="L3711">        StringBuilder sb = new StringBuilder();</span>
        Token t;
        while (true) {
<span class="fc" id="L3714">            t = getToken(1);</span>
<span class="fc bfc" id="L3715" title="All 2 branches covered.">            if (t.kind == EOF) {</span>
<span class="fc" id="L3716">                break;</span>
            }
<span class="fc bfc" id="L3718" title="All 2 branches covered.">            if (t.image.length() == 1</span>
<span class="fc bfc" id="L3719" title="All 2 branches covered.">                    &amp;&amp; endChars.contains(t.image)) {</span>
<span class="fc" id="L3720">                break;</span>
            }
<span class="fc" id="L3722">            sb.append(t.image);</span>
<span class="fc" id="L3723">            getNextToken();</span>
        }
<span class="fc bfc" id="L3725" title="All 2 branches covered.">        if (sb.length() &lt; 1) {</span>
<span class="fc" id="L3726">            throw generateParseException();</span>
        }
<span class="fc" id="L3728">        return sb.toString();</span>
    }

    int skipComponentValuesToBefore(Integer... kinds) throws ParseException {
<span class="fc" id="L3732">        Set&lt;Integer&gt; kindset = ImmutableSet.&lt;Integer&gt;builder().add(EOF).add(kinds).build();</span>
        Token t;
        do {
<span class="fc" id="L3735">            t = getToken(1);</span>
<span class="fc bfc" id="L3736" title="All 2 branches covered.">            if (kindset.contains(t.kind)) {</span>
<span class="fc" id="L3737">                return t.kind;</span>
            }
<span class="fc" id="L3739">            getNextToken();</span>
<span class="pc bpc" id="L3740" title="1 of 6 branches missed.">        } while ((t.kind != LEFTBRACE || skipComponentValuesToAfter(RIGHTBRACE) != EOF)</span>
<span class="fc bfc" id="L3741" title="All 4 branches covered.">                &amp;&amp; (t.kind != LEFTROUND || skipComponentValuesToAfter(RIGHTROUND) != EOF)</span>
<span class="pc bpc" id="L3742" title="1 of 2 branches missed.">                &amp;&amp; (t.kind != LEFTSQUARE || skipComponentValuesToAfter(RIGHTSQUARE) != EOF));</span>
<span class="fc" id="L3743">        return EOF;</span>
    }

    int skipComponentValuesToAfter(Integer... kinds) throws ParseException {
<span class="fc" id="L3747">        int kind = skipComponentValuesToBefore(kinds);</span>
<span class="fc bfc" id="L3748" title="All 2 branches covered.">        if (kind != EOF) {</span>
<span class="fc" id="L3749">            getNextToken();</span>
        }
<span class="fc" id="L3751">        return kind;</span>
    }

    void validateFinalBlockCommentIfPresent() throws ParseException {
<span class="fc bfc" id="L3755" title="All 2 branches covered.">        if (token.specialToken != null</span>
<span class="fc bfc" id="L3756" title="All 2 branches covered.">                &amp;&amp; !VALIDBLOCKCOMMENTPATTERN.matcher(token.specialToken.image).matches()) {</span>
            // Manually construct a ParseException since this syntax error occurs after the last token,
            // and we don't want the ParseException to reference a non-existent token.
<span class="fc" id="L3759">            throw new ParseException(&quot;unterminated block comment at EOF&quot;);</span>
        }
<span class="fc" id="L3761">    }</span>

    private boolean jj21(int xla) {
<span class="fc" id="L3764">        jjLa = xla;</span>
<span class="fc" id="L3765">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3767" title="1 of 2 branches missed.">            return !jj31();</span>
<span class="fc" id="L3768">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3769">            return true;</span>
        } finally {
<span class="fc" id="L3771">            jjSave(0, xla);</span>
        }
    }

    private boolean jj22(int xla) {
<span class="fc" id="L3776">        jjLa = xla;</span>
<span class="fc" id="L3777">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3779" title="1 of 2 branches missed.">            return !jj32();</span>
<span class="fc" id="L3780">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3781">            return true;</span>
        } finally {
<span class="fc" id="L3783">            jjSave(1, xla);</span>
        }
    }

    private boolean jj23(int xla) {
<span class="fc" id="L3788">        jjLa = xla;</span>
<span class="fc" id="L3789">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3791" title="1 of 2 branches missed.">            return !jj33();</span>
<span class="fc" id="L3792">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3793">            return true;</span>
        } finally {
<span class="fc" id="L3795">            jjSave(2, xla);</span>
        }
    }

    private boolean jj24(int xla) {
<span class="fc" id="L3800">        jjLa = xla;</span>
<span class="fc" id="L3801">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3803" title="1 of 2 branches missed.">            return !jj34();</span>
<span class="fc" id="L3804">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3805">            return true;</span>
        } finally {
<span class="fc" id="L3807">            jjSave(3, xla);</span>
        }
    }

    private boolean jj25(int xla) {
<span class="fc" id="L3812">        jjLa = xla;</span>
<span class="fc" id="L3813">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3815" title="1 of 2 branches missed.">            return !jj35();</span>
<span class="fc" id="L3816">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3817">            return true;</span>
        } finally {
<span class="fc" id="L3819">            jjSave(4, xla);</span>
        }
    }

    private boolean jj26(int xla) {
<span class="fc" id="L3824">        jjLa = xla;</span>
<span class="fc" id="L3825">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="nc bnc" id="L3827" title="All 2 branches missed.">            return !jj36();</span>
<span class="fc" id="L3828">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3829">            return true;</span>
        } finally {
<span class="fc" id="L3831">            jjSave(5, xla);</span>
        }
    }

    private boolean jj27(int xla) {
<span class="fc" id="L3836">        jjLa = xla;</span>
<span class="fc" id="L3837">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3839" title="1 of 2 branches missed.">            return !jj37();</span>
<span class="fc" id="L3840">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3841">            return true;</span>
        } finally {
<span class="fc" id="L3843">            jjSave(6, xla);</span>
        }
    }

    private boolean jj28(int xla) {
<span class="fc" id="L3848">        jjLa = xla;</span>
<span class="fc" id="L3849">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3851" title="1 of 2 branches missed.">            return !jj38();</span>
<span class="fc" id="L3852">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3853">            return true;</span>
        } finally {
<span class="fc" id="L3855">            jjSave(7, xla);</span>
        }
    }

    private boolean jj29(int xla) {
<span class="fc" id="L3860">        jjLa = xla;</span>
<span class="fc" id="L3861">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3863" title="1 of 2 branches missed.">            return !jj39();</span>
<span class="fc" id="L3864">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3865">            return true;</span>
        } finally {
<span class="fc" id="L3867">            jjSave(8, xla);</span>
        }
    }

    private boolean jj210(int xla) {
<span class="fc" id="L3872">        jjLa = xla;</span>
<span class="fc" id="L3873">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3875" title="1 of 2 branches missed.">            return !jj310();</span>
<span class="fc" id="L3876">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3877">            return true;</span>
        } finally {
<span class="fc" id="L3879">            jjSave(9, xla);</span>
        }
    }

    private boolean jj211(int xla) {
<span class="fc" id="L3884">        jjLa = xla;</span>
<span class="fc" id="L3885">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="nc bnc" id="L3887" title="All 2 branches missed.">            return !jj311();</span>
<span class="fc" id="L3888">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3889">            return true;</span>
        } finally {
<span class="fc" id="L3891">            jjSave(10, xla);</span>
        }
    }

    private boolean jj212(int xla) {
<span class="fc" id="L3896">        jjLa = xla;</span>
<span class="fc" id="L3897">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3899" title="1 of 2 branches missed.">            return !jj312();</span>
<span class="fc" id="L3900">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3901">            return true;</span>
        } finally {
<span class="fc" id="L3903">            jjSave(11, xla);</span>
        }
    }

    private boolean jj213(int xla) {
<span class="fc" id="L3908">        jjLa = xla;</span>
<span class="fc" id="L3909">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="nc bnc" id="L3911" title="All 2 branches missed.">            return !jj313();</span>
<span class="fc" id="L3912">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3913">            return true;</span>
        } finally {
<span class="fc" id="L3915">            jjSave(12, xla);</span>
        }
    }

    private boolean jj214(int xla) {
<span class="nc" id="L3920">        jjLa = xla;</span>
<span class="nc" id="L3921">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="nc bnc" id="L3923" title="All 2 branches missed.">            return !jj314();</span>
<span class="nc" id="L3924">        } catch (LookaheadSuccess ls) {</span>
<span class="nc" id="L3925">            return true;</span>
        } finally {
<span class="nc" id="L3927">            jjSave(13, xla);</span>
        }
    }

    private boolean jj215(int xla) {
<span class="fc" id="L3932">        jjLa = xla;</span>
<span class="fc" id="L3933">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3935" title="1 of 2 branches missed.">            return !jj315();</span>
<span class="fc" id="L3936">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3937">            return true;</span>
        } finally {
<span class="fc" id="L3939">            jjSave(14, xla);</span>
        }
    }

    private boolean jj216(int xla) {
<span class="fc" id="L3944">        jjLa = xla;</span>
<span class="fc" id="L3945">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3947" title="1 of 2 branches missed.">            return !jj316();</span>
<span class="fc" id="L3948">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3949">            return true;</span>
        } finally {
<span class="fc" id="L3951">            jjSave(15, xla);</span>
        }
    }

    private boolean jj217(int xla) {
<span class="fc" id="L3956">        jjLa = xla;</span>
<span class="fc" id="L3957">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="nc bnc" id="L3959" title="All 2 branches missed.">            return !jj317();</span>
<span class="fc" id="L3960">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3961">            return true;</span>
        } finally {
<span class="fc" id="L3963">            jjSave(16, xla);</span>
        }
    }

    private boolean jj218(int xla) {
<span class="nc" id="L3968">        jjLa = xla;</span>
<span class="nc" id="L3969">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="nc bnc" id="L3971" title="All 2 branches missed.">            return !jj318();</span>
<span class="nc" id="L3972">        } catch (LookaheadSuccess ls) {</span>
<span class="nc" id="L3973">            return true;</span>
        } finally {
<span class="nc" id="L3975">            jjSave(17, xla);</span>
        }
    }

    private boolean jj219(int xla) {
<span class="fc" id="L3980">        jjLa = xla;</span>
<span class="fc" id="L3981">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="pc bpc" id="L3983" title="1 of 2 branches missed.">            return !jj319();</span>
<span class="fc" id="L3984">        } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L3985">            return true;</span>
        } finally {
<span class="fc" id="L3987">            jjSave(18, xla);</span>
        }
    }

    private boolean jj220(int xla) {
<span class="fc" id="L3992">        jjLa = xla;</span>
<span class="fc" id="L3993">        jjLastpos = jjScanpos = token;</span>
        try {
<span class="fc bfc" id="L3995" title="All 2 branches covered.">            return !jj320();</span>
<span class="nc" id="L3996">        } catch (LookaheadSuccess ls) {</span>
<span class="nc" id="L3997">            return true;</span>
        } finally {
<span class="fc" id="L3999">            jjSave(19, xla);</span>
        }
    }

    private boolean jj3R130() {
<span class="fc" id="L4004">        return jj3R143();</span>
    }

    private boolean jj3R129() {
<span class="fc" id="L4008">        return jj3R142();</span>
    }

    private boolean jj3R128() {
<span class="fc" id="L4012">        return jj3R141();</span>
    }

    private boolean jj3R127() {
<span class="fc" id="L4016">        return jj3R140();</span>
    }

    private boolean jj311() {
<span class="fc" id="L4020">        return jj3R108();</span>
    }

    private boolean jj3R126() {
<span class="nc" id="L4024">        return jj3R139();</span>
    }

    private boolean jj318() {
<span class="fc" id="L4028">        return jj3R108();</span>
    }

    private boolean jj3R113() {
<span class="fc bfc" id="L4032" title="All 2 branches covered.">        if (jjScanToken(WPLUS)) return true;</span>
        Token xsp;
        while (true) {
<span class="fc" id="L4035">            xsp = jjScanpos;</span>
<span class="pc bpc" id="L4036" title="1 of 2 branches missed.">            if (jjScanToken(45)) {</span>
<span class="fc" id="L4037">                jjScanpos = xsp;</span>
<span class="fc" id="L4038">                break;</span>
            }
        }
<span class="fc" id="L4041">        return false;</span>
    }

    private boolean jj3R100() {
        Token xsp;
<span class="fc" id="L4046">        xsp = jjScanpos;</span>
<span class="fc bfc" id="L4047" title="All 2 branches covered.">        if (jj3R113()) {</span>
<span class="fc" id="L4048">            jjScanpos = xsp;</span>
<span class="fc bfc" id="L4049" title="All 2 branches covered.">            if (jj3R114()) {</span>
<span class="fc" id="L4050">                jjScanpos = xsp;</span>
<span class="fc bfc" id="L4051" title="All 2 branches covered.">                if (jj3R115()) {</span>
<span class="fc" id="L4052">                    jjScanpos = xsp;</span>
<span class="fc bfc" id="L4053" title="All 2 branches covered.">                    if (jj3R116()) {</span>
<span class="fc" id="L4054">                        jjScanpos = xsp;</span>
<span class="fc" id="L4055">                        return jj3R117();</span>
                    }
                }
            }
        }
<span class="fc" id="L4060">        return false;</span>
    }

    private boolean jj3R136() {
<span class="fc" id="L4064">        return jjScanToken(LEFTROUND);</span>
    }

    private boolean jj3R133() {
        Token xsp;
<span class="fc" id="L4069">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4070" title="1 of 2 branches missed.">        if (jjScanToken(66)) {</span>
<span class="fc" id="L4071">            jjScanpos = xsp;</span>
<span class="fc" id="L4072">            return jjScanToken(5);</span>
        }
<span class="nc" id="L4074">        return false;</span>
    }

    private boolean jj310() {
<span class="fc" id="L4078">        return jj3R102();</span>
    }

    private boolean jj39() {
        Token xsp;
<span class="fc" id="L4083">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4084" title="1 of 2 branches missed.">        if (jj310()) {</span>
<span class="fc" id="L4085">            jjScanpos = xsp;</span>
<span class="fc" id="L4086">            return jj311();</span>
        }
<span class="nc" id="L4088">        return false;</span>
    }

    private boolean jj317() {
<span class="fc" id="L4092">        return jj3R102();</span>
    }

    private boolean jj3R158() {
<span class="fc" id="L4096">        return jjScanToken(COLON);</span>
    }


    private boolean jj316() {
        Token xsp;
<span class="fc" id="L4102">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4103" title="1 of 2 branches missed.">        if (jj317()) {</span>
<span class="fc" id="L4104">            jjScanpos = xsp;</span>
<span class="fc" id="L4105">            return jj318();</span>
        }
<span class="nc" id="L4107">        return false;</span>
    }

    private boolean jj34() {
<span class="fc" id="L4111">        jjLookingAhead = true;</span>
<span class="fc bfc" id="L4112" title="All 2 branches covered.">        jjSemLA = getToken(1).kind == LEFTROUND</span>
<span class="fc bfc" id="L4113" title="All 4 branches covered.">                &amp;&amp; (getToken(3).kind == COLON || getToken(4).kind == COLON);</span>
<span class="fc" id="L4114">        jjLookingAhead = false;</span>
<span class="pc bpc" id="L4115" title="1 of 2 branches missed.">        if (!jjSemLA) return true;</span>
<span class="nc" id="L4116">        return jjScanToken(LEFTROUND);</span>
    }

    private boolean jj3R148() {
<span class="fc" id="L4120">        return jj3R158();</span>
    }

    private boolean jj3R147() {
<span class="fc" id="L4124">        return jj3R157();</span>
    }

    private boolean jj3R121() {
<span class="fc" id="L4128">        return jj3R136();</span>
    }

    private boolean jj3R146() {
<span class="fc" id="L4132">        return jj3R156();</span>
    }

    private boolean jj37() {
<span class="fc" id="L4136">        return jj3R106();</span>
    }


    private boolean jj3R145() {
<span class="fc" id="L4141">        return jj3R155();</span>
    }

    private boolean jj3R125() {
<span class="fc" id="L4145">        return jjScanToken(FOR_VARIABLE);</span>
    }

    private boolean jj3R134() {
        Token xsp;
<span class="fc" id="L4150">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4151" title="1 of 2 branches missed.">        if (jj3R145()) {</span>
<span class="fc" id="L4152">            jjScanpos = xsp;</span>
<span class="pc bpc" id="L4153" title="1 of 2 branches missed.">            if (jj3R146()) {</span>
<span class="fc" id="L4154">                jjScanpos = xsp;</span>
<span class="pc bpc" id="L4155" title="1 of 2 branches missed.">                if (jj3R147()) {</span>
<span class="fc" id="L4156">                    jjScanpos = xsp;</span>
<span class="fc" id="L4157">                    return jj3R148();</span>
                }
            }
        }
<span class="nc" id="L4161">        return false;</span>
    }

    private boolean jj3R141() {
<span class="fc" id="L4165">        return jjScanToken(CALC);</span>
    }

    private boolean jj3R119() {
        Token xsp;
<span class="pc bpc" id="L4170" title="1 of 2 branches missed.">        if (jj3R134()) return true;</span>
        while (true) {
<span class="nc" id="L4172">            xsp = jjScanpos;</span>
<span class="nc bnc" id="L4173" title="All 2 branches missed.">            if (jj3R134()) {</span>
<span class="nc" id="L4174">                jjScanpos = xsp;</span>
<span class="nc" id="L4175">                break;</span>
            }
        }
<span class="nc" id="L4178">        return false;</span>
    }

    private boolean jj33() {
<span class="fc" id="L4182">        jjLookingAhead = true;</span>
<span class="fc bfc" id="L4183" title="All 4 branches covered.">        jjSemLA = getToken(2).kind != DOT &amp;&amp; getToken(2).kind != COLON;</span>
<span class="fc" id="L4184">        jjLookingAhead = false;</span>
<span class="fc bfc" id="L4185" title="All 2 branches covered.">        if (!jjSemLA) return true;</span>
<span class="fc" id="L4186">        return jjScanToken(IDENTIFIER);</span>
    }

    private boolean jj3R105() {
        Token xsp;
<span class="fc" id="L4191">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4192" title="1 of 2 branches missed.">        if (jj37()) {</span>
<span class="fc" id="L4193">            jjScanpos = xsp;</span>
<span class="fc" id="L4194">            return jj3R121();</span>
        }
<span class="nc" id="L4196">        return false;</span>
    }

    private boolean jj3R124() {
<span class="fc" id="L4200">        return jj3R138();</span>
    }

    private boolean jj3R112() {
<span class="nc" id="L4204">        return jjScanToken(IDENTIFIER);</span>
    }

    private boolean jj3R123() {
<span class="fc" id="L4208">        return jjScanToken(UNICODE_RANGE);</span>
    }

    private boolean jj3R118() {
<span class="fc" id="L4212">        return jj3R133();</span>
    }

    private boolean jj3R137() {
<span class="fc" id="L4216">        return jj3R149();</span>
    }

    private boolean jj319() {
<span class="fc" id="L4220">        jjLookingAhead = true;</span>
<span class="pc bpc" id="L4221" title="1 of 4 branches missed.">        jjSemLA = getToken(1).kind == COLON || getToken(2).kind == COLON;</span>
<span class="fc" id="L4222">        jjLookingAhead = false;</span>
<span class="fc bfc" id="L4223" title="All 2 branches covered.">        if (!jjSemLA) return true;</span>
        Token xsp;
<span class="fc" id="L4225">        xsp = jjScanpos;</span>
<span class="nc bnc" id="L4226" title="All 2 branches missed.">        if (jj3R112()) jjScanpos = xsp;</span>
<span class="nc" id="L4227">        return jjScanToken(COLON);</span>
    }

    private boolean jj3R155() {
<span class="fc" id="L4231">        return jjScanToken(HASH_NAME);</span>
    }

    private boolean jj3R122() {
        Token xsp;
<span class="fc" id="L4236">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4237" title="1 of 2 branches missed.">        if (jj3R137()) jjScanpos = xsp;</span>
<span class="fc" id="L4238">        return jjScanToken(NUMBER);</span>
    }

    private boolean jj3R101() {
        Token xsp;
<span class="fc" id="L4243">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4244" title="1 of 2 branches missed.">        if (jj3R118()) {</span>
<span class="fc" id="L4245">            jjScanpos = xsp;</span>
<span class="fc" id="L4246">            return jj3R119();</span>
        }
<span class="nc" id="L4248">        return false;</span>
    }

    private boolean jj3R106() {
        Token xsp;
<span class="fc" id="L4253">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4254" title="1 of 2 branches missed.">        if (jj3R122()) {</span>
<span class="fc" id="L4255">            jjScanpos = xsp;</span>
<span class="pc bpc" id="L4256" title="1 of 2 branches missed.">            if (jj3R123()) {</span>
<span class="fc" id="L4257">                jjScanpos = xsp;</span>
<span class="pc bpc" id="L4258" title="1 of 2 branches missed.">                if (jj3R124()) {</span>
<span class="fc" id="L4259">                    jjScanpos = xsp;</span>
<span class="pc bpc" id="L4260" title="1 of 2 branches missed.">                    if (jj33()) {</span>
<span class="fc" id="L4261">                        jjScanpos = xsp;</span>
<span class="pc bpc" id="L4262" title="1 of 2 branches missed.">                        if (jj3R125()) {</span>
<span class="fc" id="L4263">                            jjScanpos = xsp;</span>
<span class="pc bpc" id="L4264" title="1 of 2 branches missed.">                            if (jj34()) {</span>
<span class="fc" id="L4265">                                jjScanpos = xsp;</span>
<span class="fc" id="L4266">                                jjLookingAhead = true;</span>
<span class="fc bfc" id="L4267" title="All 2 branches covered.">                                jjSemLA = getToken(1).kind == URI;</span>
<span class="fc" id="L4268">                                jjLookingAhead = false;</span>
<span class="pc bpc" id="L4269" title="3 of 4 branches missed.">                                if (!jjSemLA || jj3R126()) {</span>
<span class="fc" id="L4270">                                    jjScanpos = xsp;</span>
<span class="pc bpc" id="L4271" title="1 of 2 branches missed.">                                    if (jj3R127()) {</span>
<span class="fc" id="L4272">                                        jjScanpos = xsp;</span>
<span class="pc bpc" id="L4273" title="1 of 2 branches missed.">                                        if (jj3R128()) {</span>
<span class="fc" id="L4274">                                            jjScanpos = xsp;</span>
<span class="pc bpc" id="L4275" title="1 of 2 branches missed.">                                            if (jj3R129()) {</span>
<span class="fc" id="L4276">                                                jjScanpos = xsp;</span>
<span class="fc" id="L4277">                                                return jj3R130();</span>
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
<span class="nc" id="L4288">        return false;</span>
    }

    private boolean jj3R154() {
<span class="fc" id="L4292">        return jjScanToken(EXCL_MARK);</span>
    }

    private boolean jj3R156() {
<span class="fc" id="L4296">        return jjScanToken(DOT);</span>
    }

    private boolean jj3R153() {
<span class="fc" id="L4300">        return jjScanToken(IDENTIFIER);</span>
    }

    private boolean jj3R152() {
<span class="fc" id="L4304">        return jjScanToken(FUNCTION);</span>
    }

    private boolean jj3R143() {
        Token xsp;
<span class="fc" id="L4309">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4310" title="1 of 2 branches missed.">        if (jj3R152()) {</span>
<span class="fc" id="L4311">            jjScanpos = xsp;</span>
<span class="fc" id="L4312">            return jj3R153();</span>
        }
<span class="nc" id="L4314">        return false;</span>
    }

    private boolean jj3R135() {
<span class="fc" id="L4318">        return jj3R106();</span>
    }

    private boolean jj36() {
<span class="nc" id="L4322">        return jj3R105();</span>
    }

    private boolean jj38() {
<span class="fc" id="L4326">        return jj3R107();</span>
    }

    private boolean jj314() {
<span class="fc" id="L4330">        return jj3R108();</span>
    }

    private boolean jj31() {
<span class="fc bfc" id="L4334" title="All 2 branches covered.">        if (jj3R100()) return true;</span>
<span class="fc" id="L4335">        return jj3R101();</span>
    }

    private boolean jj35() {
<span class="fc" id="L4339">        return jj3R105();</span>
    }

    private boolean jj3R144() {
<span class="fc" id="L4343">        return jj3R154();</span>
    }

    private boolean jj3R139() {
<span class="nc" id="L4347">        return jjScanToken(URI);</span>
    }

    private boolean jj3R131() {
        Token xsp;
<span class="fc" id="L4352">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4353" title="1 of 2 branches missed.">        if (jj3R144()) {</span>
<span class="fc" id="L4354">            jjScanpos = xsp;</span>
<span class="fc" id="L4355">            return jj35();</span>
        }
<span class="nc" id="L4357">        return false;</span>
    }

    private boolean jj3R120() {
<span class="fc" id="L4361">        return jj3R135();</span>
    }

    private boolean jj3R157() {
<span class="fc" id="L4365">        return jjScanToken(LEFTSQUARE);</span>
    }

    private boolean jj313() {
<span class="fc" id="L4369">        return jj3R102();</span>
    }

    private boolean jj312() {
        Token xsp;
<span class="fc" id="L4374">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4375" title="1 of 2 branches missed.">        if (jj313()) {</span>
<span class="fc" id="L4376">            jjScanpos = xsp;</span>
<span class="fc" id="L4377">            return jj314();</span>
        }
<span class="nc" id="L4379">        return false;</span>
    }

    private boolean jj3R110() {
<span class="fc" id="L4383">        return jjScanToken(IDENTIFIER);</span>
    }

    private boolean jj3R102() {
<span class="fc" id="L4387">        return jj3R120();</span>
    }

    private boolean jj315() {
<span class="fc" id="L4391">        jjLookingAhead = true;</span>
<span class="fc bfc" id="L4392" title="All 4 branches covered.">        jjSemLA = getToken(1).kind == COLON || getToken(2).kind == COLON;</span>
<span class="fc" id="L4393">        jjLookingAhead = false;</span>
<span class="fc bfc" id="L4394" title="All 2 branches covered.">        if (!jjSemLA) return true;</span>
        Token xsp;
<span class="fc" id="L4396">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4397" title="1 of 2 branches missed.">        if (jj3R110()) jjScanpos = xsp;</span>
<span class="nc" id="L4398">        return jjScanToken(COLON);</span>
    }

    private boolean jj3R108() {
<span class="fc" id="L4402">        return jj3R131();</span>
    }

    private boolean jj3R142() {
<span class="fc" id="L4406">        return jjScanToken(VARFUNCTION);</span>
    }

    private boolean jj3R132() {
<span class="fc" id="L4410">        return jjScanToken(S);</span>
    }

    private boolean jj32() {
<span class="fc" id="L4414">        return jj3R102();</span>
    }

    private boolean jj3R107() {
<span class="fc" id="L4418">        return jj3R102();</span>
    }

    private boolean jj3R117() {
        Token xsp;
<span class="fc bfc" id="L4423" title="All 2 branches covered.">        if (jj3R132()) return true;</span>
        while (true) {
<span class="fc" id="L4425">            xsp = jjScanpos;</span>
<span class="pc bpc" id="L4426" title="1 of 2 branches missed.">            if (jj3R132()) {</span>
<span class="fc" id="L4427">                jjScanpos = xsp;</span>
<span class="fc" id="L4428">                break;</span>
            }
        }
<span class="fc" id="L4431">        return false;</span>
    }

    private boolean jj3R140() {
<span class="fc" id="L4435">        return jjScanToken(HASH_NAME);</span>
    }

    private boolean jj3R116() {
<span class="fc bfc" id="L4439" title="All 2 branches covered.">        if (jjScanToken(WDEEP)) return true;</span>
        Token xsp;
        while (true) {
<span class="fc" id="L4442">            xsp = jjScanpos;</span>
<span class="pc bpc" id="L4443" title="1 of 2 branches missed.">            if (jjScanToken(45)) {</span>
<span class="fc" id="L4444">                jjScanpos = xsp;</span>
<span class="fc" id="L4445">                break;</span>
            }
        }
<span class="fc" id="L4448">        return false;</span>
    }

    private boolean jj3R151() {
<span class="fc" id="L4452">        return jjScanToken(SINGLE_QUOTED_STRING);</span>
    }

    private boolean jj3R150() {
<span class="fc" id="L4456">        return jjScanToken(DOUBLE_QUOTED_STRING);</span>
    }

    private boolean jj320() {
<span class="fc" id="L4460">        return jjScanToken(ATLIST);</span>
    }

    private boolean jj3R138() {
        Token xsp;
<span class="fc" id="L4465">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4466" title="1 of 2 branches missed.">        if (jj3R150()) {</span>
<span class="fc" id="L4467">            jjScanpos = xsp;</span>
<span class="fc" id="L4468">            return jj3R151();</span>
        }
<span class="nc" id="L4470">        return false;</span>
    }

    private boolean jj3R115() {
<span class="fc bfc" id="L4474" title="All 2 branches covered.">        if (jjScanToken(WTILDE)) return true;</span>
        Token xsp;
        while (true) {
<span class="fc" id="L4477">            xsp = jjScanpos;</span>
<span class="pc bpc" id="L4478" title="1 of 2 branches missed.">            if (jjScanToken(45)) {</span>
<span class="fc" id="L4479">                jjScanpos = xsp;</span>
<span class="fc" id="L4480">                break;</span>
            }
        }
<span class="fc" id="L4483">        return false;</span>
    }

    private boolean jj3R149() {
        Token xsp;
<span class="fc" id="L4488">        xsp = jjScanpos;</span>
<span class="pc bpc" id="L4489" title="1 of 2 branches missed.">        if (jjScanToken(7)) {</span>
<span class="fc" id="L4490">            jjScanpos = xsp;</span>
<span class="fc" id="L4491">            return jjScanToken(49);</span>
        }
<span class="nc" id="L4493">        return false;</span>
    }

    private boolean jj3R114() {
<span class="fc bfc" id="L4497" title="All 2 branches covered.">        if (jjScanToken(WGREATER)) return true;</span>
        Token xsp;
        while (true) {
<span class="fc" id="L4500">            xsp = jjScanpos;</span>
<span class="pc bpc" id="L4501" title="1 of 2 branches missed.">            if (jjScanToken(45)) {</span>
<span class="fc" id="L4502">                jjScanpos = xsp;</span>
<span class="fc" id="L4503">                break;</span>
            }
        }
<span class="fc" id="L4506">        return false;</span>
    }

    /**
     * Generated Token Manager.
     */
    private GssParserCCTokenManager tokenSource;
    /**
     * Current token.
     */
    public Token token;
    private int jjNtk;
    private Token jjScanpos;
    private Token jjLastpos;
    private int jjLa;
    /**
     * Whether we are looking ahead.
     */
<span class="fc" id="L4524">    private boolean jjLookingAhead = false;</span>
    private boolean jjSemLA;
    private int jjGen;
<span class="fc" id="L4527">    private final int[] jjLa1 = new int[160];</span>
    private static int[] jjLa10;
    private static int[] jjLa11;
    private static int[] jjLa12;

    static {
<span class="fc" id="L4533">        jjLa1Init0();</span>
<span class="fc" id="L4534">        jjLa1Init1();</span>
<span class="fc" id="L4535">        jjLa1Init2();</span>
<span class="fc" id="L4536">    }</span>

    private static void jjLa1Init0() {
<span class="fc" id="L4539">        jjLa10 = new int[]{0x0, 0x8000, 0x0, 0x0, 0x8020000, 0x8020000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x80, 0x0, 0x80, 0x0, 0x0, 0x100, 0x0, 0x0, 0x0, 0x100, 0x218, 0x218, 0x218, 0x218, 0x238, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x4, 0x0, 0x20, 0x0, 0x20, 0x4, 0x20, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x8000, 0x0, 0x100, 0x0, 0x40, 0x0, 0x80, 0x20000, 0x20000, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80000000, 0x0, 0x10000, 0x40000000, 0x0, 0x10000, 0x0, 0x800, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x8000, 0x18, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x60, 0x80, 0x20000, 0x20000, 0x80, 0x0, 0x0, 0x880, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2004, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2004, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2004, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8000, 0x0, 0x0, 0x0, 0x238, 0x238, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x4, 0x0, 0x2a00, 0x2a00, 0x0, 0x2a00, 0x2a00, 0x0, 0x2a00, 0x2a00,};</span>
<span class="fc" id="L4540">    }</span>

    private static void jjLa1Init1() {
<span class="fc" id="L4543">        jjLa11 = new int[]{0x60000000, 0x0, 0x2000, 0x2000, 0x0, 0x0, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0, 0x0, 0x4030000, 0x2000, 0x4030000, 0x2000, 0x2000, 0x1f, 0x2000, 0x60000000, 0x2000, 0x1f, 0x8000000, 0x8000000, 0x8000000, 0x8000000, 0x8000000, 0x0, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x1e2000, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x0, 0x0, 0x0, 0x2000, 0x2000, 0x0, 0x2000, 0x2000, 0x2000, 0x10000000, 0x0, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x20000, 0x0, 0x0, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0, 0x4000000, 0x2000, 0x64020000, 0x0, 0x8000000, 0x2000, 0x0, 0x2000, 0x0, 0x0, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x2000, 0x20000, 0x2000, 0x2000, 0x2000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x2000, 0x2000, 0x30000, 0x2000, 0x30000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0, 0x20000, 0x0, 0x0, 0x4020000, 0x2000, 0x2000, 0x4020000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x2000, 0x0, 0x2000, 0x0, 0x2000, 0x2000, 0x2000, 0x4000000, 0x2000, 0x0, 0x2000, 0x4000000, 0x2000, 0x8000000, 0x8000000, 0x0, 0x2060, 0x2060, 0x2060, 0x2060, 0x2000, 0x0, 0x0, 0x2000, 0x0, 0x0, 0x2000, 0x0, 0x0, 0x2000, 0x0, 0x0,};</span>
<span class="fc" id="L4544">    }</span>

    private static void jjLa1Init2() {
<span class="fc" id="L4547">        jjLa12 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x434, 0x434, 0x6, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0, 0x4000, 0x0, 0xc, 0x0, 0xc, 0x4000, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x0, 0x200, 0x2, 0x4c4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x404, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x84, 0x0, 0x0, 0x84, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x400, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x400, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x4, 0x0, 0x7804, 0x4, 0x7000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};</span>
<span class="fc" id="L4548">    }</span>

<span class="fc" id="L4550">    private final JJCalls[] jj2Rtns = new JJCalls[20];</span>
<span class="fc" id="L4551">    private boolean jjRescan = false;</span>
<span class="fc" id="L4552">    private int jjGc = 0;</span>

    /**
     * Constructor with user supplied CharStream.
     */
<span class="fc" id="L4557">    public GssParserCC(CharStream stream) {</span>
<span class="fc" id="L4558">        tokenSource = new GssParserCCTokenManager(stream);</span>
<span class="fc" id="L4559">        token = new Token();</span>
<span class="fc" id="L4560">        jjNtk = -1;</span>
<span class="fc" id="L4561">        jjGen = 0;</span>
<span class="fc bfc" id="L4562" title="All 2 branches covered.">        for (int i = 0; i &lt; 160; i++) jjLa1[i] = -1;</span>
<span class="fc bfc" id="L4563" title="All 2 branches covered.">        for (int i = 0; i &lt; jj2Rtns.length; i++) jj2Rtns[i] = new JJCalls();</span>
<span class="fc" id="L4564">    }</span>

    /**
     * Reinitialise.
     */
    public void ReInit(CharStream stream) {
<span class="fc" id="L4570">        tokenSource.reInit(stream);</span>
<span class="fc" id="L4571">        token = new Token();</span>
<span class="fc" id="L4572">        jjNtk = -1;</span>
<span class="fc" id="L4573">        jjLookingAhead = false;</span>
<span class="fc" id="L4574">        jjGen = 0;</span>
<span class="fc bfc" id="L4575" title="All 2 branches covered.">        for (int i = 0; i &lt; 160; i++) jjLa1[i] = -1;</span>
<span class="fc bfc" id="L4576" title="All 2 branches covered.">        for (int i = 0; i &lt; jj2Rtns.length; i++) jj2Rtns[i] = new JJCalls();</span>
<span class="fc" id="L4577">    }</span>

    private Token jjConsumeToken(int kind) throws ParseException {
        Token oldToken;
<span class="fc bfc" id="L4581" title="All 2 branches covered.">        if ((oldToken = token).next != null) token = token.next;</span>
<span class="fc" id="L4582">        else token = token.next = tokenSource.getNextToken();</span>
<span class="fc" id="L4583">        jjNtk = -1;</span>
<span class="fc bfc" id="L4584" title="All 2 branches covered.">        if (token.kind == kind) {</span>
<span class="fc" id="L4585">            jjGen++;</span>
<span class="fc bfc" id="L4586" title="All 2 branches covered.">            if (++jjGc &gt; 100) {</span>
<span class="fc" id="L4587">                jjGc = 0;</span>
<span class="fc bfc" id="L4588" title="All 2 branches covered.">                for (JJCalls jj2Rtn : jj2Rtns) {</span>
<span class="fc" id="L4589">                    JJCalls c = jj2Rtn;</span>
<span class="fc bfc" id="L4590" title="All 2 branches covered.">                    while (c != null) {</span>
<span class="fc bfc" id="L4591" title="All 2 branches covered.">                        if (c.gen &lt; jjGen) c.first = null;</span>
<span class="fc" id="L4592">                        c = c.next;</span>
                    }
                }
            }
<span class="fc" id="L4596">            return token;</span>
        }
<span class="fc" id="L4598">        token = oldToken;</span>
<span class="fc" id="L4599">        jjKind = kind;</span>
<span class="fc" id="L4600">        throw generateParseException();</span>
    }

    @SuppressWarnings(&quot;serial&quot;)
    private static final class LookaheadSuccess extends Error {
    }

<span class="fc" id="L4607">    private final LookaheadSuccess jjLs = new LookaheadSuccess();</span>

    private boolean jjScanToken(int kind) {
<span class="fc bfc" id="L4610" title="All 2 branches covered.">        if (jjScanpos == jjLastpos) {</span>
<span class="fc" id="L4611">            jjLa--;</span>
<span class="fc bfc" id="L4612" title="All 2 branches covered.">            if (jjScanpos.next == null) {</span>
<span class="fc" id="L4613">                jjLastpos = jjScanpos = jjScanpos.next = tokenSource.getNextToken();</span>
            } else {
<span class="fc" id="L4615">                jjLastpos = jjScanpos = jjScanpos.next;</span>
            }
        } else {
<span class="fc" id="L4618">            jjScanpos = jjScanpos.next;</span>
        }
<span class="fc bfc" id="L4620" title="All 2 branches covered.">        if (jjRescan) {</span>
<span class="fc" id="L4621">            int i = 0;</span>
<span class="fc" id="L4622">            Token tok = token;</span>
<span class="pc bpc" id="L4623" title="1 of 4 branches missed.">            while (tok != null &amp;&amp; tok != jjScanpos) {</span>
<span class="fc" id="L4624">                i++;</span>
<span class="fc" id="L4625">                tok = tok.next;</span>
            }
<span class="pc bpc" id="L4627" title="1 of 2 branches missed.">            if (tok != null) jjAddErrorToken(kind, i);</span>
        }
<span class="fc bfc" id="L4629" title="All 2 branches covered.">        if (jjScanpos.kind != kind) return true;</span>
<span class="pc bpc" id="L4630" title="1 of 4 branches missed.">        if (jjLa == 0 &amp;&amp; jjScanpos == jjLastpos) throw jjLs;</span>
<span class="fc" id="L4631">        return false;</span>
    }


    /**
     * Get the next Token.
     */
    public final Token getNextToken() {
<span class="pc bpc" id="L4639" title="1 of 2 branches missed.">        if (token.next != null) token = token.next;</span>
<span class="nc" id="L4640">        else token = token.next = tokenSource.getNextToken();</span>
<span class="fc" id="L4641">        jjNtk = -1;</span>
<span class="fc" id="L4642">        jjGen++;</span>
<span class="fc" id="L4643">        return token;</span>
    }

    /**
     * Get the specific Token.
     */
    public final Token getToken(int index) {
<span class="fc bfc" id="L4650" title="All 2 branches covered.">        Token t = jjLookingAhead ? jjScanpos : token;</span>
<span class="fc bfc" id="L4651" title="All 2 branches covered.">        for (int i = 0; i &lt; index; i++) {</span>
<span class="fc bfc" id="L4652" title="All 2 branches covered.">            if (t.next != null) t = t.next;</span>
<span class="fc" id="L4653">            else t = t.next = tokenSource.getNextToken();</span>
        }
<span class="fc" id="L4655">        return t;</span>
    }

    private int jjNtkF() {
        /**
         * Next token.
         */
        Token jjNt;
<span class="fc bfc" id="L4663" title="All 2 branches covered.">        if ((jjNt = token.next) == null) {</span>
<span class="fc" id="L4664">            token.next = tokenSource.getNextToken();</span>
<span class="fc" id="L4665">            jjNtk = (token.next).kind;</span>
        } else {
<span class="fc" id="L4667">            jjNtk = jjNt.kind;</span>
        }
<span class="fc" id="L4669">        return jjNtk;</span>
    }

<span class="fc" id="L4672">    private final List&lt;int[]&gt; jjExpentries = new ArrayList&lt;&gt;();</span>
    private int[] jjExpentry;
<span class="fc" id="L4674">    private int jjKind = -1;</span>
<span class="fc" id="L4675">    private final int[] jjLasttokens = new int[100];</span>
    private int jjEndpos;

    private void jjAddErrorToken(int kind, int pos) {
<span class="pc bpc" id="L4679" title="1 of 2 branches missed.">        if (pos &gt;= 100) {</span>
<span class="nc" id="L4680">            return;</span>
        }

<span class="fc bfc" id="L4683" title="All 2 branches covered.">        if (pos == jjEndpos + 1) {</span>
<span class="fc" id="L4684">            jjLasttokens[jjEndpos++] = kind;</span>
<span class="fc bfc" id="L4685" title="All 2 branches covered.">        } else if (jjEndpos != 0) {</span>
<span class="fc" id="L4686">            jjExpentry = new int[jjEndpos];</span>

<span class="fc" id="L4688">            System.arraycopy(jjLasttokens, 0, jjExpentry, 0, jjEndpos);</span>

<span class="fc bfc" id="L4690" title="All 2 branches covered.">            for (int[] oldentry : jjExpentries) {</span>
<span class="fc bfc" id="L4691" title="All 2 branches covered.">                if (oldentry.length == jjExpentry.length) {</span>
<span class="fc" id="L4692">                    boolean isMatched = true;</span>

<span class="fc bfc" id="L4694" title="All 2 branches covered.">                    for (int i = 0; i &lt; jjExpentry.length; i++) {</span>
<span class="fc bfc" id="L4695" title="All 2 branches covered.">                        if (oldentry[i] != jjExpentry[i]) {</span>
<span class="fc" id="L4696">                            isMatched = false;</span>
<span class="fc" id="L4697">                            break;</span>
                        }

                    }
<span class="fc bfc" id="L4701" title="All 2 branches covered.">                    if (isMatched) {</span>
<span class="fc" id="L4702">                        jjExpentries.add(jjExpentry);</span>
<span class="fc" id="L4703">                        break;</span>
                    }
                }
<span class="fc" id="L4706">            }</span>

<span class="fc bfc" id="L4708" title="All 2 branches covered.">            if (pos != 0) {</span>
<span class="fc" id="L4709">                jjEndpos = pos;</span>
<span class="fc" id="L4710">                jjLasttokens[jjEndpos - 1] = kind;</span>
            }
        }
<span class="fc" id="L4713">    }</span>

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
<span class="fc" id="L4719">        jjExpentries.clear();</span>
<span class="fc" id="L4720">        boolean[] la1tokens = new boolean[80];</span>
<span class="fc bfc" id="L4721" title="All 2 branches covered.">        if (jjKind &gt;= 0) {</span>
<span class="fc" id="L4722">            la1tokens[jjKind] = true;</span>
<span class="fc" id="L4723">            jjKind = -1;</span>
        }
<span class="fc bfc" id="L4725" title="All 2 branches covered.">        for (int i = 0; i &lt; 160; i++) {</span>
<span class="fc bfc" id="L4726" title="All 2 branches covered.">            if (jjLa1[i] == jjGen) {</span>
<span class="fc bfc" id="L4727" title="All 2 branches covered.">                for (int j = 0; j &lt; 32; j++) {</span>
<span class="fc bfc" id="L4728" title="All 2 branches covered.">                    if ((jjLa10[i] &amp; (1 &lt;&lt; j)) != 0) {</span>
<span class="fc" id="L4729">                        la1tokens[j] = true;</span>
                    }
<span class="fc bfc" id="L4731" title="All 2 branches covered.">                    if ((jjLa11[i] &amp; (1 &lt;&lt; j)) != 0) {</span>
<span class="fc" id="L4732">                        la1tokens[32 + j] = true;</span>
                    }
<span class="fc bfc" id="L4734" title="All 2 branches covered.">                    if ((jjLa12[i] &amp; (1 &lt;&lt; j)) != 0) {</span>
<span class="fc" id="L4735">                        la1tokens[64 + j] = true;</span>
                    }
                }
            }
        }
<span class="fc bfc" id="L4740" title="All 2 branches covered.">        for (int i = 0; i &lt; 80; i++) {</span>
<span class="fc bfc" id="L4741" title="All 2 branches covered.">            if (la1tokens[i]) {</span>
<span class="fc" id="L4742">                jjExpentry = new int[1];</span>
<span class="fc" id="L4743">                jjExpentry[0] = i;</span>
<span class="fc" id="L4744">                jjExpentries.add(jjExpentry);</span>
            }
        }
<span class="fc" id="L4747">        jjEndpos = 0;</span>
<span class="fc" id="L4748">        jjRescanToken();</span>
<span class="fc" id="L4749">        jjAddErrorToken(0, 0);</span>
<span class="fc" id="L4750">        int[][] exptokseq = new int[jjExpentries.size()][];</span>
<span class="fc bfc" id="L4751" title="All 2 branches covered.">        for (int i = 0; i &lt; jjExpentries.size(); i++) {</span>
<span class="fc" id="L4752">            exptokseq[i] = jjExpentries.get(i);</span>
        }
<span class="fc" id="L4754">        return new ParseException(token, exptokseq, tokenImage);</span>
    }

    private void jjRescanToken() {
<span class="fc" id="L4758">        jjRescan = true;</span>
<span class="fc bfc" id="L4759" title="All 2 branches covered.">        for (int i = 0; i &lt; 20; i++) {</span>
            try {
<span class="fc" id="L4761">                JJCalls p = jj2Rtns[i];</span>

                do {
<span class="fc bfc" id="L4764" title="All 2 branches covered.">                    if (p.gen &gt; jjGen) {</span>
<span class="fc" id="L4765">                        jjLa = p.arg;</span>
<span class="fc" id="L4766">                        jjLastpos = jjScanpos = p.first;</span>
<span class="pc bpc" id="L4767" title="16 of 21 branches missed.">                        switch (i) {</span>
                            case 0:
<span class="fc" id="L4769">                                jj31();</span>
<span class="fc" id="L4770">                                break;</span>
                            case 1:
<span class="fc" id="L4772">                                jj32();</span>
<span class="fc" id="L4773">                                break;</span>
                            case 2:
<span class="fc" id="L4775">                                jj33();</span>
<span class="fc" id="L4776">                                break;</span>
                            case 3:
<span class="nc" id="L4778">                                jj34();</span>
<span class="nc" id="L4779">                                break;</span>
                            case 4:
<span class="fc" id="L4781">                                jj35();</span>
<span class="fc" id="L4782">                                break;</span>
                            case 5:
<span class="nc" id="L4784">                                jj36();</span>
<span class="nc" id="L4785">                                break;</span>
                            case 6:
<span class="nc" id="L4787">                                jj37();</span>
<span class="nc" id="L4788">                                break;</span>
                            case 7:
<span class="fc" id="L4790">                                jj38();</span>
<span class="fc" id="L4791">                                break;</span>
                            case 8:
<span class="nc" id="L4793">                                jj39();</span>
<span class="nc" id="L4794">                                break;</span>
                            case 9:
<span class="nc" id="L4796">                                jj310();</span>
<span class="nc" id="L4797">                                break;</span>
                            case 10:
<span class="nc" id="L4799">                                jj311();</span>
<span class="nc" id="L4800">                                break;</span>
                            case 11:
<span class="nc" id="L4802">                                jj312();</span>
<span class="nc" id="L4803">                                break;</span>
                            case 12:
<span class="nc" id="L4805">                                jj313();</span>
<span class="nc" id="L4806">                                break;</span>
                            case 13:
<span class="nc" id="L4808">                                jj314();</span>
<span class="nc" id="L4809">                                break;</span>
                            case 14:
<span class="nc" id="L4811">                                jj315();</span>
<span class="nc" id="L4812">                                break;</span>
                            case 15:
<span class="nc" id="L4814">                                jj316();</span>
<span class="nc" id="L4815">                                break;</span>
                            case 16:
<span class="nc" id="L4817">                                jj317();</span>
<span class="nc" id="L4818">                                break;</span>
                            case 17:
<span class="nc" id="L4820">                                jj318();</span>
<span class="nc" id="L4821">                                break;</span>
                            case 18:
<span class="nc" id="L4823">                                jj319();</span>
<span class="nc" id="L4824">                                break;</span>
                            case 19:
<span class="nc" id="L4826">                                jj320();</span>
                                break;
                        }
                    }
<span class="fc" id="L4830">                    p = p.next;</span>
<span class="pc bpc" id="L4831" title="1 of 2 branches missed.">                } while (p != null);</span>

<span class="nc" id="L4833">            } catch (LookaheadSuccess ls) {</span>
<span class="fc" id="L4834">            }</span>
        }
<span class="fc" id="L4836">        jjRescan = false;</span>
<span class="fc" id="L4837">    }</span>

    private void jjSave(int index, int xla) {
<span class="fc" id="L4840">        JJCalls p = jj2Rtns[index];</span>
<span class="pc bpc" id="L4841" title="1 of 2 branches missed.">        while (p.gen &gt; jjGen) {</span>
<span class="nc bnc" id="L4842" title="All 2 branches missed.">            if (p.next == null) {</span>
<span class="nc" id="L4843">                p = p.next = new JJCalls();</span>
<span class="nc" id="L4844">                break;</span>
            }
<span class="nc" id="L4846">            p = p.next;</span>
        }

<span class="fc" id="L4849">        p.gen = jjGen + xla - jjLa;</span>
<span class="fc" id="L4850">        p.first = token;</span>
<span class="fc" id="L4851">        p.arg = xla;</span>
<span class="fc" id="L4852">    }</span>

<span class="fc" id="L4854">    static final class JJCalls {</span>
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>